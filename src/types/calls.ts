import assert from 'assert'
import {Chain, ChainContext, CallContext, Call, Result, Option} from './support'
import * as v1 from './v1'
import * as v801 from './v801'
import * as v802 from './v802'
import * as v803 from './v803'
import * as v804 from './v804'
import * as v805 from './v805'
import * as v900 from './v900'
import * as v901 from './v901'
import * as v902 from './v902'
import * as v906 from './v906'
import * as v908 from './v908'
import * as v910 from './v910'
import * as v912 from './v912'
import * as v914 from './v914'
import * as v915 from './v915'
import * as v916 from './v916'
import * as v918 from './v918'
import * as v920 from './v920'
import * as v922 from './v922'
import * as v923 from './v923'
import * as v926 from './v926'
import * as v927 from './v927'
import * as v930 from './v930'
import * as v932 from './v932'
import * as v940 from './v940'
import * as v942 from './v942'
import * as v944 from './v944'
import * as v946 from './v946'
import * as v948 from './v948'
import * as v952 from './v952'
import * as v954 from './v954'
import * as v956 from './v956'
import * as v958 from './v958'
import * as v962 from './v962'
import * as v964 from './v964'
import * as v967 from './v967'
import * as v968 from './v968'
import * as v970 from './v970'
import * as v972 from './v972'

export class AssetRegistryForceSetMultilocationCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssetRegistry.force_set_multilocation')
        this._chain = ctx._chain
        this.call = call
    }

    get isV968(): boolean {
        return this._chain.getCallHash('AssetRegistry.force_set_multilocation') === '3d6c5f2d326a9f2a8c7ba305fbde262c21dbaed97fbd0f03733914341acaf34a'
    }

    get asV968(): {currencyId: v968.CurrencyId, location: v968.VersionedMultiLocation, weight: bigint} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('AssetRegistry.force_set_multilocation') === 'b760dd0156a493c1cbf3bcfec9526c47bb0f896ea417eb1bba7b827ee7aee8b9'
    }

    get asV970(): {currencyId: v970.CurrencyId, location: v970.VersionedMultiLocation, weight: bigint} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    get isV972(): boolean {
        return this._chain.getCallHash('AssetRegistry.force_set_multilocation') === 'd077d19577717c3371dff93a17e861ea34dd5365db105b1f360b820c7da96129'
    }

    get asV972(): {currencyId: v972.CurrencyId, location: v972.VersionedMultiLocation, weight: v972.Weight} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class AssetRegistryRegisterForeignAssetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssetRegistry.register_foreign_asset')
        this._chain = ctx._chain
        this.call = call
    }

    get isV932(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_foreign_asset') === '40860164f36f031eb3910029aa2d246e7ed7940a1d49f635d83f41026cf6331e'
    }

    get asV932(): {location: v932.VersionedMultiLocation, metadata: v932.AssetMetadata} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class AssetRegistryRegisterMultilocationCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssetRegistry.register_multilocation')
        this._chain = ctx._chain
        this.call = call
    }

    get isV956(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_multilocation') === '8456abdf6b713cd9d8ea6cdf23d1c13cecdd1aec7c2ee5f981e4beb57fe83611'
    }

    get asV956(): {currencyId: v956.CurrencyId, location: v956.VersionedMultiLocation, weight: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_multilocation') === '3d6c5f2d326a9f2a8c7ba305fbde262c21dbaed97fbd0f03733914341acaf34a'
    }

    get asV962(): {currencyId: v962.CurrencyId, location: v962.VersionedMultiLocation, weight: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_multilocation') === 'b760dd0156a493c1cbf3bcfec9526c47bb0f896ea417eb1bba7b827ee7aee8b9'
    }

    get asV970(): {currencyId: v970.CurrencyId, location: v970.VersionedMultiLocation, weight: bigint} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    get isV972(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_multilocation') === 'd077d19577717c3371dff93a17e861ea34dd5365db105b1f360b820c7da96129'
    }

    get asV972(): {currencyId: v972.CurrencyId, location: v972.VersionedMultiLocation, weight: v972.Weight} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class AssetRegistryRegisterNativeAssetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssetRegistry.register_native_asset')
        this._chain = ctx._chain
        this.call = call
    }

    get isV948(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_native_asset') === 'b499672aaaa3f131148d423f65a52454ababaf4e3dc7719fc3a8410ce9023320'
    }

    get asV948(): {currencyId: v948.CurrencyId, location: v948.VersionedMultiLocation, metadata: v948.AssetMetadata} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_native_asset') === '36b9a1c030df6885a54254e49123788e3768eab6f3cf550a65a3317274fa855f'
    }

    get asV956(): {currencyId: v956.CurrencyId, location: v956.VersionedMultiLocation, metadata: v956.AssetMetadata} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_native_asset') === '08ca887bd5682b4ff2d34523abc3678694964bc7cebe0376d6f5d0d979883e88'
    }

    get asV962(): {currencyId: v962.CurrencyId, location: v962.VersionedMultiLocation, metadata: v962.AssetMetadata} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_native_asset') === 'e98fcd3355866ed5e598c45181ea384c5a9d3fc21822057978f1e709aa0c55ff'
    }

    get asV970(): {currencyId: v970.CurrencyId, location: v970.VersionedMultiLocation, metadata: v970.AssetMetadata} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    get isV972(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_native_asset') === 'd76afe806033bf2a7ebcf1d7ed6857ffed2055e244225c6a82465589bb21bfc1'
    }

    get asV972(): {currencyId: v972.CurrencyId, location: v972.VersionedMultiLocation, metadata: v972.AssetMetadata} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class AssetRegistryRegisterTokenMetadataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssetRegistry.register_token_metadata')
        this._chain = ctx._chain
        this.call = call
    }

    get isV956(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_token_metadata') === 'fedeb9107761e870f0d7a66a21bfb3970436de3c1e702e0690844b664a356d78'
    }

    get asV956(): {metadata: v956.AssetMetadata} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }
}

export class AssetRegistryRegisterVsbondMetadataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssetRegistry.register_vsbond_metadata')
        this._chain = ctx._chain
        this.call = call
    }

    get isV956(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_vsbond_metadata') === 'b32ee339bd6dbb60225681cab3ce4d9f6b84d78deed463e3a19a96bf607f12d3'
    }

    get asV956(): {tokenId: number, paraId: number, firstSlot: number, lastSlot: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }
}

export class AssetRegistryRegisterVstokenMetadataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssetRegistry.register_vstoken_metadata')
        this._chain = ctx._chain
        this.call = call
    }

    get isV956(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_vstoken_metadata') === 'aedf244ace8e8060c538210af429a18d2c7b8a392b556881fd484f6b18dfeff0'
    }

    get asV956(): {tokenId: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }
}

export class AssetRegistryRegisterVtokenMetadataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssetRegistry.register_vtoken_metadata')
        this._chain = ctx._chain
        this.call = call
    }

    get isV956(): boolean {
        return this._chain.getCallHash('AssetRegistry.register_vtoken_metadata') === 'aedf244ace8e8060c538210af429a18d2c7b8a392b556881fd484f6b18dfeff0'
    }

    get asV956(): {tokenId: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }
}

export class AssetRegistryUpdateForeignAssetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssetRegistry.update_foreign_asset')
        this._chain = ctx._chain
        this.call = call
    }

    get isV932(): boolean {
        return this._chain.getCallHash('AssetRegistry.update_foreign_asset') === 'd45f03bb21fc8668bb18d1bca7dc4f40fc60b517ad916b41b017ff8d5215a414'
    }

    get asV932(): {foreignAssetId: number, location: v932.VersionedMultiLocation, metadata: v932.AssetMetadata} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class AssetRegistryUpdateNativeAssetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'AssetRegistry.update_native_asset')
        this._chain = ctx._chain
        this.call = call
    }

    get isV948(): boolean {
        return this._chain.getCallHash('AssetRegistry.update_native_asset') === 'b499672aaaa3f131148d423f65a52454ababaf4e3dc7719fc3a8410ce9023320'
    }

    get asV948(): {currencyId: v948.CurrencyId, location: v948.VersionedMultiLocation, metadata: v948.AssetMetadata} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('AssetRegistry.update_native_asset') === '36b9a1c030df6885a54254e49123788e3768eab6f3cf550a65a3317274fa855f'
    }

    get asV956(): {currencyId: v956.CurrencyId, location: v956.VersionedMultiLocation, metadata: v956.AssetMetadata} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('AssetRegistry.update_native_asset') === '08ca887bd5682b4ff2d34523abc3678694964bc7cebe0376d6f5d0d979883e88'
    }

    get asV962(): {currencyId: v962.CurrencyId, location: v962.VersionedMultiLocation, metadata: v962.AssetMetadata} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('AssetRegistry.update_native_asset') === 'e98fcd3355866ed5e598c45181ea384c5a9d3fc21822057978f1e709aa0c55ff'
    }

    get asV970(): {currencyId: v970.CurrencyId, location: v970.VersionedMultiLocation, metadata: v970.AssetMetadata} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    get isV972(): boolean {
        return this._chain.getCallHash('AssetRegistry.update_native_asset') === 'd76afe806033bf2a7ebcf1d7ed6857ffed2055e244225c6a82465589bb21bfc1'
    }

    get asV972(): {currencyId: v972.CurrencyId, location: v972.VersionedMultiLocation, metadata: v972.AssetMetadata} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class AuthorshipSetUnclesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Authorship.set_uncles')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Provide a set of uncles.
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Authorship.set_uncles') === 'efd6e78708f873b5d0804d67dee4f6351287add79134d8ee5b59dcfa2a5e21af'
    }

    /**
     *  Provide a set of uncles.
     */
    get asV1(): {newUncles: v1.Header[]} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Provide a set of uncles.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Authorship.set_uncles') === '491502deec691ea043fa56fc39b50b58deab8a6411c511016c06289ee5867611'
    }

    /**
     * Provide a set of uncles.
     */
    get asV906(): {newUncles: v906.Header[]} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Provide a set of uncles.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Authorship.set_uncles') === 'cf2d7dac8c8babfdda54dfcca36fda32336dc937b0f1767c6b2332a9b718e0b5'
    }

    /**
     * Provide a set of uncles.
     */
    get asV916(): {newUncles: v916.Header[]} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesForceTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.force_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Exactly as `transfer`, except the origin must be root and the source account may be
     *  specified.
     *  # <weight>
     *  - Same as transfer, but additional read and write because the source account is
     *    not assumed to be in the overlay.
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Balances.force_transfer') === '906df11f4f65ebd03a2b87ba248e1fba11c3a0bca42c892bee828bac3ec80348'
    }

    /**
     *  Exactly as `transfer`, except the origin must be root and the source account may be
     *  specified.
     *  # <weight>
     *  - Same as transfer, but additional read and write because the source account is
     *    not assumed to be in the overlay.
     *  # </weight>
     */
    get asV1(): {source: v1.LookupSource, dest: v1.LookupSource, value: bigint} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesForceUnreserveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.force_unreserve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unreserve some balance from a user by force.
     * 
     * Can only be called by ROOT.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Balances.force_unreserve') === 'ed3d74aa1f96dbb29cc25c5f10c3b3af4a67b188eed8095131d1726f67820911'
    }

    /**
     * Unreserve some balance from a user by force.
     * 
     * Can only be called by ROOT.
     */
    get asV906(): {who: v906.MultiAddress, amount: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesSetBalanceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.set_balance')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the balances of a given account.
     * 
     *  This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     *  also decrease the total issuance of the system (`TotalIssuance`).
     *  If the new free or reserved balance is below the existential deposit,
     *  it will reset the account nonce (`frame_system::AccountNonce`).
     * 
     *  The dispatch origin for this call is `root`.
     * 
     *  # <weight>
     *  - Independent of the arguments.
     *  - Contains a limited number of reads and writes.
     *  ---------------------
     *  - Base Weight:
     *      - Creating: 27.56 µs
     *      - Killing: 35.11 µs
     *  - DB Weight: 1 Read, 1 Write to `who`
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Balances.set_balance') === '94e2a75e6cd4bfc2ec9211ae3a29870014cac2dd2f37c1f9634b6e4bbef0442f'
    }

    /**
     *  Set the balances of a given account.
     * 
     *  This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     *  also decrease the total issuance of the system (`TotalIssuance`).
     *  If the new free or reserved balance is below the existential deposit,
     *  it will reset the account nonce (`frame_system::AccountNonce`).
     * 
     *  The dispatch origin for this call is `root`.
     * 
     *  # <weight>
     *  - Independent of the arguments.
     *  - Contains a limited number of reads and writes.
     *  ---------------------
     *  - Base Weight:
     *      - Creating: 27.56 µs
     *      - Killing: 35.11 µs
     *  - DB Weight: 1 Read, 1 Write to `who`
     *  # </weight>
     */
    get asV1(): {who: v1.LookupSource, newFree: bigint, newReserved: bigint} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer some liquid free balance to another account.
     * 
     *  `transfer` will set the `FreeBalance` of the sender and receiver.
     *  It will decrease the total issuance of the system by the `TransferFee`.
     *  If the sender's account is below the existential deposit as a result
     *  of the transfer, the account will be reaped.
     * 
     *  The dispatch origin for this call must be `Signed` by the transactor.
     * 
     *  # <weight>
     *  - Dependent on arguments but not critical, given proper implementations for
     *    input config types. See related functions below.
     *  - It contains a limited number of reads and writes internally and no complex computation.
     * 
     *  Related functions:
     * 
     *    - `ensure_can_withdraw` is always called internally but has a bounded complexity.
     *    - Transferring balances to accounts that did not exist before will cause
     *       `T::OnNewAccount::on_new_account` to be called.
     *    - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
     *    - `transfer_keep_alive` works the same way as `transfer`, but has an additional
     *      check that the transfer will not kill the origin account.
     *  ---------------------------------
     *  - Base Weight: 73.64 µs, worst case scenario (account created, account removed)
     *  - DB Weight: 1 Read and 1 Write to destination account
     *  - Origin account is already in memory, so no DB operations for them.
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Balances.transfer') === 'c3f0f475940fc4bef49b298f76ba345680f20fc48d5899b4678314a07e2ce090'
    }

    /**
     *  Transfer some liquid free balance to another account.
     * 
     *  `transfer` will set the `FreeBalance` of the sender and receiver.
     *  It will decrease the total issuance of the system by the `TransferFee`.
     *  If the sender's account is below the existential deposit as a result
     *  of the transfer, the account will be reaped.
     * 
     *  The dispatch origin for this call must be `Signed` by the transactor.
     * 
     *  # <weight>
     *  - Dependent on arguments but not critical, given proper implementations for
     *    input config types. See related functions below.
     *  - It contains a limited number of reads and writes internally and no complex computation.
     * 
     *  Related functions:
     * 
     *    - `ensure_can_withdraw` is always called internally but has a bounded complexity.
     *    - Transferring balances to accounts that did not exist before will cause
     *       `T::OnNewAccount::on_new_account` to be called.
     *    - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
     *    - `transfer_keep_alive` works the same way as `transfer`, but has an additional
     *      check that the transfer will not kill the origin account.
     *  ---------------------------------
     *  - Base Weight: 73.64 µs, worst case scenario (account created, account removed)
     *  - DB Weight: 1 Read and 1 Write to destination account
     *  - Origin account is already in memory, so no DB operations for them.
     *  # </weight>
     */
    get asV1(): {dest: v1.LookupSource, value: bigint} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesTransferAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.transfer_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer the entire transferable balance from the caller account.
     * 
     *  NOTE: This function only attempts to transfer _transferable_ balances. This means that
     *  any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     *  transferred by this function. To ensure that this function results in a killed account,
     *  you might need to prepare the account by removing any reference counters, storage
     *  deposits, etc...
     * 
     *  The dispatch origin of this call must be Signed.
     * 
     *  - `dest`: The recipient of the transfer.
     *  - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     *    of the funds the account has, causing the sender account to be killed (false), or
     *    transfer everything except at least the existential deposit, which will guarantee to
     *    keep the sender account alive (true).
     *    # <weight>
     *  - O(1). Just like transfer, but reading the user's transferable balance first.
     *    #</weight>
     */
    get isV801(): boolean {
        return this._chain.getCallHash('Balances.transfer_all') === '56952003e07947f758a9928d8462037abffea6a7fa991c0d3451f5c47d45f254'
    }

    /**
     *  Transfer the entire transferable balance from the caller account.
     * 
     *  NOTE: This function only attempts to transfer _transferable_ balances. This means that
     *  any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     *  transferred by this function. To ensure that this function results in a killed account,
     *  you might need to prepare the account by removing any reference counters, storage
     *  deposits, etc...
     * 
     *  The dispatch origin of this call must be Signed.
     * 
     *  - `dest`: The recipient of the transfer.
     *  - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     *    of the funds the account has, causing the sender account to be killed (false), or
     *    transfer everything except at least the existential deposit, which will guarantee to
     *    keep the sender account alive (true).
     *    # <weight>
     *  - O(1). Just like transfer, but reading the user's transferable balance first.
     *    #</weight>
     */
    get asV801(): {dest: v801.LookupSource, keepAlive: boolean} {
        assert(this.isV801)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesTransferKeepAliveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.transfer_keep_alive')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Same as the [`transfer`] call, but with a check that the transfer will not kill the
     *  origin account.
     * 
     *  99% of the time you want [`transfer`] instead.
     * 
     *  [`transfer`]: struct.Pallet.html#method.transfer
     *  # <weight>
     *  - Cheaper than transfer because account cannot be killed.
     *  - Base Weight: 51.4 µs
     *  - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)
     *  #</weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Balances.transfer_keep_alive') === 'c3f0f475940fc4bef49b298f76ba345680f20fc48d5899b4678314a07e2ce090'
    }

    /**
     *  Same as the [`transfer`] call, but with a check that the transfer will not kill the
     *  origin account.
     * 
     *  99% of the time you want [`transfer`] instead.
     * 
     *  [`transfer`]: struct.Pallet.html#method.transfer
     *  # <weight>
     *  - Cheaper than transfer because account cannot be killed.
     *  - Base Weight: 51.4 µs
     *  - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)
     *  #</weight>
     */
    get asV1(): {dest: v1.LookupSource, value: bigint} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesAcceptCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.accept_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Accept the curator role for a bounty.
     *  A deposit will be reserved from curator and refund upon successful payout.
     * 
     *  May only be called from the curator.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Bounties.accept_curator') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Accept the curator role for a bounty.
     *  A deposit will be reserved from curator and refund upon successful payout.
     * 
     *  May only be called from the curator.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV803(): {bountyId: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesApproveBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.approve_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Approve a bounty proposal. At a later time, the bounty will be funded and become active
     *  and the original deposit will be returned.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Bounties.approve_bounty') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Approve a bounty proposal. At a later time, the bounty will be funded and become active
     *  and the original deposit will be returned.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV803(): {bountyId: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesAwardBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.award_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Award bounty to a beneficiary account. The beneficiary will be able to claim the funds after a delay.
     * 
     *  The dispatch origin for this call must be the curator of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to award.
     *  - `beneficiary`: The beneficiary account whom will receive the payout.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Bounties.award_bounty') === 'd740fadb3b6bd5fcbc882e8a8741448f60283d3c52cc1fc64c08d97c4b7467ae'
    }

    /**
     *  Award bounty to a beneficiary account. The beneficiary will be able to claim the funds after a delay.
     * 
     *  The dispatch origin for this call must be the curator of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to award.
     *  - `beneficiary`: The beneficiary account whom will receive the payout.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV803(): {bountyId: number, beneficiary: v803.LookupSource} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesClaimBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.claim_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Claim the payout from an awarded bounty after payout delay.
     * 
     *  The dispatch origin for this call must be the beneficiary of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to claim.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Bounties.claim_bounty') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Claim the payout from an awarded bounty after payout delay.
     * 
     *  The dispatch origin for this call must be the beneficiary of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to claim.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV803(): {bountyId: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesCloseBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.close_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel a proposed or active bounty. All the funds will be sent to treasury and
     *  the curator deposit will be unreserved if possible.
     * 
     *  Only `T::RejectOrigin` is able to cancel a bounty.
     * 
     *  - `bounty_id`: Bounty ID to cancel.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Bounties.close_bounty') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Cancel a proposed or active bounty. All the funds will be sent to treasury and
     *  the curator deposit will be unreserved if possible.
     * 
     *  Only `T::RejectOrigin` is able to cancel a bounty.
     * 
     *  - `bounty_id`: Bounty ID to cancel.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV803(): {bountyId: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesExtendBountyExpiryCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.extend_bounty_expiry')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Extend the expiry time of an active bounty.
     * 
     *  The dispatch origin for this call must be the curator of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to extend.
     *  - `remark`: additional information.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Bounties.extend_bounty_expiry') === '710d6b76ffcee45bd9bffc1f299fa0b621450769559963379fa259c0f427f1bb'
    }

    /**
     *  Extend the expiry time of an active bounty.
     * 
     *  The dispatch origin for this call must be the curator of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to extend.
     *  - `remark`: additional information.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV803(): {bountyId: number, remark: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesProposeBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.propose_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Propose a new bounty.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     *  `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
     *  or slashed when rejected.
     * 
     *  - `curator`: The curator account whom will manage this bounty.
     *  - `fee`: The curator fee.
     *  - `value`: The total payment amount of this bounty, curator fee included.
     *  - `description`: The description of this bounty.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Bounties.propose_bounty') === '6a012b4069a991972d0d3268cb20dfba3163919c325c7ebbe980b2dc15f1b1f5'
    }

    /**
     *  Propose a new bounty.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     *  `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
     *  or slashed when rejected.
     * 
     *  - `curator`: The curator account whom will manage this bounty.
     *  - `fee`: The curator fee.
     *  - `value`: The total payment amount of this bounty, curator fee included.
     *  - `description`: The description of this bounty.
     */
    get asV803(): {value: bigint, description: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesProposeCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.propose_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Assign a curator to a funded bounty.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Bounties.propose_curator') === '2496ed9b22c4f45280f8b1f616ce6e1fff5629ded2a6ed9237e80ab77e4bff2f'
    }

    /**
     *  Assign a curator to a funded bounty.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV803(): {bountyId: number, curator: v803.LookupSource, fee: bigint} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesUnassignCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.unassign_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unassign curator from a bounty.
     * 
     *  This function can only be called by the `RejectOrigin` a signed origin.
     * 
     *  If this function is called by the `RejectOrigin`, we assume that the curator is malicious
     *  or inactive. As a result, we will slash the curator when possible.
     * 
     *  If the origin is the curator, we take this as a sign they are unable to do their job and
     *  they willingly give up. We could slash them, but for now we allow them to recover their
     *  deposit and exit without issue. (We may want to change this if it is abused.)
     * 
     *  Finally, the origin can be anyone if and only if the curator is "inactive". This allows
     *  anyone in the community to call out that a curator is not doing their due diligence, and
     *  we should pick a new curator. In this case the curator should also be slashed.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Bounties.unassign_curator') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Unassign curator from a bounty.
     * 
     *  This function can only be called by the `RejectOrigin` a signed origin.
     * 
     *  If this function is called by the `RejectOrigin`, we assume that the curator is malicious
     *  or inactive. As a result, we will slash the curator when possible.
     * 
     *  If the origin is the curator, we take this as a sign they are unable to do their job and
     *  they willingly give up. We could slash them, but for now we allow them to recover their
     *  deposit and exit without issue. (We may want to change this if it is abused.)
     * 
     *  Finally, the origin can be anyone if and only if the curator is "inactive". This allows
     *  anyone in the community to call out that a curator is not doing their due diligence, and
     *  we should pick a new curator. In this case the curator should also be slashed.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV803(): {bountyId: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class CallSwitchgearDisableTransfersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CallSwitchgear.disable_transfers')
        this._chain = ctx._chain
        this.call = call
    }

    get isV908(): boolean {
        return this._chain.getCallHash('CallSwitchgear.disable_transfers') === '0858dc5a88d9cdcdcd8a06954874130ac7ca796251732d066d10d73ae7bc8d05'
    }

    get asV908(): {currencyId: v908.CurrencyId} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    get isV916(): boolean {
        return this._chain.getCallHash('CallSwitchgear.disable_transfers') === '5bf47dbb4f089f6f9b480a3982a7634a3eb8103a380f4349526b886b4fbf5a90'
    }

    get asV916(): {currencyId: v916.CurrencyId} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    get isV920(): boolean {
        return this._chain.getCallHash('CallSwitchgear.disable_transfers') === '570e12c9b0a55312b18f0c4e8a583a8cdf2e82e7c7181384bfe572aa4007d365'
    }

    get asV920(): {currencyId: v920.CurrencyId} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    get isV932(): boolean {
        return this._chain.getCallHash('CallSwitchgear.disable_transfers') === '5cb19321013a7eb509c005d6d39283ab9fae33ba97862a6a354fae8216ee5379'
    }

    get asV932(): {currencyId: v932.CurrencyId} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('CallSwitchgear.disable_transfers') === '7d8a3e7d779f11164e04f6a37a9fa89298621358fdfcab3b535b4b783a6c8037'
    }

    get asV956(): {currencyId: v956.CurrencyId} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('CallSwitchgear.disable_transfers') === '0a9d3c015dc155696ea30a98c73282f04dad76fa0e64157d75dc0b4c7d3bfec6'
    }

    get asV962(): {currencyId: v962.CurrencyId} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class CallSwitchgearEnableTransfersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CallSwitchgear.enable_transfers')
        this._chain = ctx._chain
        this.call = call
    }

    get isV908(): boolean {
        return this._chain.getCallHash('CallSwitchgear.enable_transfers') === '0858dc5a88d9cdcdcd8a06954874130ac7ca796251732d066d10d73ae7bc8d05'
    }

    get asV908(): {currencyId: v908.CurrencyId} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    get isV916(): boolean {
        return this._chain.getCallHash('CallSwitchgear.enable_transfers') === '5bf47dbb4f089f6f9b480a3982a7634a3eb8103a380f4349526b886b4fbf5a90'
    }

    get asV916(): {currencyId: v916.CurrencyId} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    get isV920(): boolean {
        return this._chain.getCallHash('CallSwitchgear.enable_transfers') === '570e12c9b0a55312b18f0c4e8a583a8cdf2e82e7c7181384bfe572aa4007d365'
    }

    get asV920(): {currencyId: v920.CurrencyId} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    get isV932(): boolean {
        return this._chain.getCallHash('CallSwitchgear.enable_transfers') === '5cb19321013a7eb509c005d6d39283ab9fae33ba97862a6a354fae8216ee5379'
    }

    get asV932(): {currencyId: v932.CurrencyId} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('CallSwitchgear.enable_transfers') === '7d8a3e7d779f11164e04f6a37a9fa89298621358fdfcab3b535b4b783a6c8037'
    }

    get asV956(): {currencyId: v956.CurrencyId} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('CallSwitchgear.enable_transfers') === '0a9d3c015dc155696ea30a98c73282f04dad76fa0e64157d75dc0b4c7d3bfec6'
    }

    get asV962(): {currencyId: v962.CurrencyId} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class CallSwitchgearSwitchoffTransactionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CallSwitchgear.switchoff_transaction')
        this._chain = ctx._chain
        this.call = call
    }

    get isV908(): boolean {
        return this._chain.getCallHash('CallSwitchgear.switchoff_transaction') === '9f7ea81680daeafc9598d45a2a8cebeeecb2ddd4c023d1961eb29f8509623297'
    }

    get asV908(): {palletName: Uint8Array, functionName: Uint8Array} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class CallSwitchgearSwitchonTransactionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CallSwitchgear.switchon_transaction')
        this._chain = ctx._chain
        this.call = call
    }

    get isV908(): boolean {
        return this._chain.getCallHash('CallSwitchgear.switchon_transaction') === '9f7ea81680daeafc9598d45a2a8cebeeecb2ddd4c023d1961eb29f8509623297'
    }

    get asV908(): {palletName: Uint8Array, functionName: Uint8Array} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class CollatorSelectionLeaveIntentCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CollatorSelection.leave_intent')
        this._chain = ctx._chain
        this.call = call
    }

    get isV1(): boolean {
        return this._chain.getCallHash('CollatorSelection.leave_intent') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    get asV1(): null {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class CollatorSelectionRegisterAsCandidateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CollatorSelection.register_as_candidate')
        this._chain = ctx._chain
        this.call = call
    }

    get isV1(): boolean {
        return this._chain.getCallHash('CollatorSelection.register_as_candidate') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    get asV1(): null {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class CollatorSelectionSetCandidacyBondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CollatorSelection.set_candidacy_bond')
        this._chain = ctx._chain
        this.call = call
    }

    get isV1(): boolean {
        return this._chain.getCallHash('CollatorSelection.set_candidacy_bond') === 'a862ec70ffc8f3bd1c3d634825c052f8531eba68afa42769689fc18a6d718eda'
    }

    get asV1(): {bond: bigint} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class CollatorSelectionSetDesiredCandidatesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CollatorSelection.set_desired_candidates')
        this._chain = ctx._chain
        this.call = call
    }

    get isV1(): boolean {
        return this._chain.getCallHash('CollatorSelection.set_desired_candidates') === '405f1447d8db6ecc920213976cf7f98b6e74c5ceb4e2ecf66c742895e40e5d78'
    }

    get asV1(): {max: number} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class CollatorSelectionSetInvulnerablesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CollatorSelection.set_invulnerables')
        this._chain = ctx._chain
        this.call = call
    }

    get isV1(): boolean {
        return this._chain.getCallHash('CollatorSelection.set_invulnerables') === '4f4db85b7e763f702804fa793ac5cba68cfd546b497830a9c3c21dced2b91524'
    }

    get asV1(): {new: Uint8Array[]} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilCloseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.close')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     *  May be called by any signed account in order to finish voting and close the proposal.
     * 
     *  If called before the end of the voting period it will only close the vote if it is
     *  has enough votes to be approved or disapproved.
     * 
     *  If called after the end of the voting period abstentions are counted as rejections
     *  unless there is a prime member set and the prime member cast an approval.
     * 
     *  If the close operation completes successfully with disapproval, the transaction fee will
     *  be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     *  + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.
     *  + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     *                    `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1 + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - `P1` is the complexity of `proposal` preimage.
     *    - `P2` is proposal-count (code-bounded)
     *  - DB:
     *   - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *   - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)
     *   - any mutations done while executing `proposal` (`P1`)
     *  - up to 3 events
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Council.close') === '45a5978a11ceb5a8b2c51f7152abaa939cd8bd4bcdc5e1162029cedba4b598ea'
    }

    /**
     *  Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     *  May be called by any signed account in order to finish voting and close the proposal.
     * 
     *  If called before the end of the voting period it will only close the vote if it is
     *  has enough votes to be approved or disapproved.
     * 
     *  If called after the end of the voting period abstentions are counted as rejections
     *  unless there is a prime member set and the prime member cast an approval.
     * 
     *  If the close operation completes successfully with disapproval, the transaction fee will
     *  be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     *  + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.
     *  + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     *                    `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1 + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - `P1` is the complexity of `proposal` preimage.
     *    - `P2` is proposal-count (code-bounded)
     *  - DB:
     *   - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *   - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)
     *   - any mutations done while executing `proposal` (`P1`)
     *  - up to 3 events
     *  # </weight>
     */
    get asV803(): {proposalHash: Uint8Array, index: number, proposalWeightBound: bigint, lengthBound: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Council.close') === 'a88911953f51bddf0f0aeafa7caa7ca904d30cdb24f940ff177d2acf7088d3bd'
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get asV968(): {proposalHash: Uint8Array, index: number, proposalWeightBound: v968.Weight, lengthBound: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilCloseOldWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.close_old_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Council.close_old_weight') === '45a5978a11ceb5a8b2c51f7152abaa939cd8bd4bcdc5e1162029cedba4b598ea'
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get asV968(): {proposalHash: Uint8Array, index: number, proposalWeightBound: bigint, lengthBound: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilDisapproveProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.disapprove_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Disapprove a proposal, close, and remove it from the system, regardless of its current state.
     * 
     *  Must be called by the Root origin.
     * 
     *  Parameters:
     *  * `proposal_hash`: The hash of the proposal that should be disapproved.
     * 
     *  # <weight>
     *  Complexity: O(P) where P is the number of max proposals
     *  DB Weight:
     *  * Reads: Proposals
     *  * Writes: Voting, Proposals, ProposalOf
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Council.disapprove_proposal') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Disapprove a proposal, close, and remove it from the system, regardless of its current state.
     * 
     *  Must be called by the Root origin.
     * 
     *  Parameters:
     *  * `proposal_hash`: The hash of the proposal that should be disapproved.
     * 
     *  # <weight>
     *  Complexity: O(P) where P is the number of max proposals
     *  DB Weight:
     *  * Reads: Proposals
     *  * Writes: Voting, Proposals, ProposalOf
     *  # </weight>
     */
    get asV803(): {proposalHash: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilExecuteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.execute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Council.execute') === '27f6a6026111ae912cb775e7c7575ac686a5246ab2023eefb2a4c6cf0b0a10f7'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV803(): {proposal: v803.Proposal, lengthBound: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Council.execute') === '8850de99fc2383fea1e7b57ee91d7e0344547bd550b5f9edd969e20b8316cbed'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV804(): {proposal: v804.Proposal, lengthBound: number} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV805(): boolean {
        return this._chain.getCallHash('Council.execute') === 'd9beed75f76bee3d1d51830a36bea790fe2f299013dc1c2d47e8306dfae0e58f'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV805(): {proposal: v805.Proposal, lengthBound: number} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Council.execute') === '1e92547ce4d17433a13b9787015b7637d7180d0320a22d6141642efe4e2bd640'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV900(): {proposal: v900.Proposal, lengthBound: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV901(): boolean {
        return this._chain.getCallHash('Council.execute') === '13919797c046b3f2c226e33bdb37783265aeb9ec62066ff7213d1daa55bc685e'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV901(): {proposal: v901.Proposal, lengthBound: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV902(): boolean {
        return this._chain.getCallHash('Council.execute') === '1301104cd7dc0913dee33169f560f38004241998429c7f907272b720b6500b6b'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV902(): {proposal: v902.Proposal, lengthBound: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Council.execute') === '0226d7889075d9de23eae00a0f4f8506369c481f563020d18d7899f4789e816d'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV906(): {proposal: v906.Call, lengthBound: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Council.execute') === 'dfcbb7a3bd8c12241fe884340f5a0eb4342d6353df6b41bd2f466324564d73a3'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV908(): {proposal: v908.Call, lengthBound: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV910(): boolean {
        return this._chain.getCallHash('Council.execute') === '3946658118c41c09817fb96079b8a80dc1869ad2e8dddefa60e21be947644e2f'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV910(): {proposal: v910.Call, lengthBound: number} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV912(): boolean {
        return this._chain.getCallHash('Council.execute') === 'f4d616078afaf8d66b7f449abc5929045286d49f0356ac165bad90ab55793ebe'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV912(): {proposal: v912.Call, lengthBound: number} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV914(): boolean {
        return this._chain.getCallHash('Council.execute') === 'a253f2ffdad4ce4963fabdcbdb4f0ecb699a8ffb62b86bf6d17920d79be5582b'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV914(): {proposal: v914.Call, lengthBound: number} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV915(): boolean {
        return this._chain.getCallHash('Council.execute') === '46f8efcbc4205f7d5063aa4112148197705c2f21c14d96eb2cca8d9655388bc4'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV915(): {proposal: v915.Call, lengthBound: number} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Council.execute') === 'ddba31f02ddc643e11a28819f5f2b8c5ce608509a7912a8e3b8d82621308b75d'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV916(): {proposal: v916.Call, lengthBound: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Council.execute') === '60311d415a7c99d5d81d5b48e18043ebd41a8cee6c24f6c06784c153d78ea611'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV918(): {proposal: v918.Call, lengthBound: number} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Council.execute') === '53c6f266dc888e69d85d729e026dcac368f25ca6c90a13a8e23e19f108385302'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV920(): {proposal: v920.Call, lengthBound: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Council.execute') === 'ae81b2670e133df35551453cbac26008cb81e1f9119cf1264e4cbbce3506ae7d'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV922(): {proposal: v922.Call, lengthBound: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Council.execute') === 'f75980f024746a26a55f3be648696ec2f43474b5c1d0810dc3d9b251d7241119'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV923(): {proposal: v923.Call, lengthBound: number} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Council.execute') === '0adbd3c3a36f0cdda59ffcdccd11eefc50205022a2f2d12a53f13efeaf9c8e6f'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV926(): {proposal: v926.Call, lengthBound: number} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Council.execute') === '90d35c54a9da0e98b6e5df6ae13290b84eea776c8d67d6de0c90ca8ceb5631ed'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV927(): {proposal: v927.Call, lengthBound: number} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Council.execute') === 'd93772935aa643c6ae09211527d9cd19aceb46765f5215b3db12b97e3407f92f'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV930(): {proposal: v930.Call, lengthBound: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Council.execute') === '3bda03f889c473ffdbb6a5ff8c4409b716ffd0db010e16faa77b4210cb7492f9'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV932(): {proposal: v932.Call, lengthBound: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Council.execute') === 'adc855918dedbf35bb3f8bfe251af1f10d8984aee584cb22646e5faf6fccff22'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV940(): {proposal: v940.Call, lengthBound: number} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Council.execute') === '3e219488d64bacae47fae6b558e0365f20f157a99d206e7069ff40136e17a75d'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV942(): {proposal: v942.Call, lengthBound: number} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Council.execute') === '604f6f6cebc0054e31e3948497a11b5483da04907b88c7528b3d59c2879a5a8e'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV944(): {proposal: v944.Call, lengthBound: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Council.execute') === 'e76d5058de1501f820707933b07203bcbb6c9c575fe12b18f86d20de8ac93e02'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV946(): {proposal: v946.Call, lengthBound: number} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Council.execute') === '7f95a68b5f3e595dcfc07645a529e2533b4233c10b186e82f42452fb8b0758d7'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV948(): {proposal: v948.Call, lengthBound: number} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Council.execute') === '489e981197f44668ee0fb8fceb04ade0564182a6d5a78a199152d65e9b982df7'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV952(): {proposal: v952.Call, lengthBound: number} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Council.execute') === '205dc4e1fbd08c181adddeaa3696b2185a3ffdc91896d96e6baa9653a04d00bb'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV954(): {proposal: v954.Call, lengthBound: number} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Council.execute') === '6a89d2479337f16d37f8cf3418203ed190560fdd8d9cc12060629be477795c43'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV956(): {proposal: v956.Call, lengthBound: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Council.execute') === '3ca271f3d090267c335c525e9805294601c37f20201306c91e8952adb5b1d891'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV958(): {proposal: v958.Call, lengthBound: number} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Council.execute') === '4d7eee56b958953354082203991d3eabb545f2fe76edb4fa562d97b64c44c477'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV962(): {proposal: v962.Call, lengthBound: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Council.execute') === '09466763e4e740ecef18d01cba8b80fc3efe06028c85b873152ece91f05c2467'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV964(): {proposal: v964.Call, lengthBound: number} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Council.execute') === '470cb5abd4b0cb96c9e2860f6e3e5d12d215d41fbe04a9c2b245639651475638'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV967(): {proposal: v967.Call, lengthBound: number} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Council.execute') === '8524c24cd96496a043448ab62cc2e078f1fdb16edb6eda4dcf135f509e879915'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV968(): {proposal: v968.Call, lengthBound: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Council.execute') === 'be03f2909dec303e32cc1616233f3a1127b7377846880dcf2b3f7fac77590392'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV970(): {proposal: v970.Call, lengthBound: number} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Council.execute') === 'c245940a9eb46c2c23d12b8669b1052fcb616bced5919f2e33cb606a6c64e5e0'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV972(): {proposal: v972.Call, lengthBound: number} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilProposeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.propose')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Council.propose') === '1ca5ee39de53202f0ba51d0800a1cf1a0a29ffcd6297a6c888b3801c9b8423de'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV803(): {threshold: number, proposal: v803.Proposal, lengthBound: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Council.propose') === 'aba8538d4414977fb3ff48657c028923bb6e6d9209937d0b83997cfd033a0738'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV804(): {threshold: number, proposal: v804.Proposal, lengthBound: number} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV805(): boolean {
        return this._chain.getCallHash('Council.propose') === 'e040b3ffd1bf4f1145407369fe90663cc07d0c16c24a3a7a1bce7db69eceedf4'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV805(): {threshold: number, proposal: v805.Proposal, lengthBound: number} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Council.propose') === '71351f28414f6ae5546e358268f9187cf3d34bb24b19b9536c89a6f365a705a5'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV900(): {threshold: number, proposal: v900.Proposal, lengthBound: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV901(): boolean {
        return this._chain.getCallHash('Council.propose') === '7d657a76204435cebf16856e19705f2287b31d0e3c0713d8697cd514399b9108'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV901(): {threshold: number, proposal: v901.Proposal, lengthBound: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV902(): boolean {
        return this._chain.getCallHash('Council.propose') === '3c80bf8c2e4221ae2599942acc021ec32fb955e5786ed04751b85078078de86f'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV902(): {threshold: number, proposal: v902.Proposal, lengthBound: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Council.propose') === 'f5219ff63063b8fab2d44c6523ea0536d92381661e66b675c2cfe59ee4832818'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV906(): {threshold: number, proposal: v906.Call, lengthBound: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Council.propose') === '67b9a985960bc7295f0af482ea8f244055af5997a162a3ec0d2a35b0b485c474'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV908(): {threshold: number, proposal: v908.Call, lengthBound: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV910(): boolean {
        return this._chain.getCallHash('Council.propose') === '89a0b2acc6f0129f4c63ebac17f420a1cd2b8c377f34f6f50feece04393c54f3'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV910(): {threshold: number, proposal: v910.Call, lengthBound: number} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV912(): boolean {
        return this._chain.getCallHash('Council.propose') === 'cf76a682a8b99c713d296be9c18290f8dbd8bd839a033b51a36e824acd78c361'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV912(): {threshold: number, proposal: v912.Call, lengthBound: number} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV914(): boolean {
        return this._chain.getCallHash('Council.propose') === '9b441912114922155879e4dcab07257b487007f5c83cb365ff01e9b8b333e9ac'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV914(): {threshold: number, proposal: v914.Call, lengthBound: number} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV915(): boolean {
        return this._chain.getCallHash('Council.propose') === '3802b615250234e0a6fa3872a6cdc901c3bf6a0c8316e02d05cdeef4907cb36e'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV915(): {threshold: number, proposal: v915.Call, lengthBound: number} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Council.propose') === '9161c3230fd2212002390a50fd879c80c63ab1eec7ec4787563a9e8fdca558db'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV916(): {threshold: number, proposal: v916.Call, lengthBound: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Council.propose') === '754c77df144d1d00da22bfcfbe7710ebdcdf2146a1f08ebffd0e91d95f67783c'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV918(): {threshold: number, proposal: v918.Call, lengthBound: number} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Council.propose') === '99bc1d8f4758e63a324dae53aedd6b338dd934d6e7058e5661b40a8761459534'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV920(): {threshold: number, proposal: v920.Call, lengthBound: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Council.propose') === '82d324ae3629c31d2fe86f3e1fb83272650a4f607c024806d9288abe13083c17'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV922(): {threshold: number, proposal: v922.Call, lengthBound: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Council.propose') === 'b690deb2817fcb580a28a20471554c33655fc4dcf91ec23178134ccee0fb2f17'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV923(): {threshold: number, proposal: v923.Call, lengthBound: number} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Council.propose') === '84f61a84c8356e24ab9bd68f7c1c2d26bcaa4292ff3eeb838cc7395f9314a91a'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV926(): {threshold: number, proposal: v926.Call, lengthBound: number} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Council.propose') === 'a8aa747055da9c04b5de1a5ad16e7a332ce9650e8302dd2e52ad39f3f50ae4b8'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV927(): {threshold: number, proposal: v927.Call, lengthBound: number} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Council.propose') === '29a9778bffbb79b9ab07977a78ef24cce9cbce1567339f7ecbbd10330cf41578'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV930(): {threshold: number, proposal: v930.Call, lengthBound: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Council.propose') === 'd60961ea735abef7cfc834a23fab4a4d4bbcce0b2330c59caf83580901b4cdbf'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV932(): {threshold: number, proposal: v932.Call, lengthBound: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Council.propose') === '711dc586de516e5f30eadb8681ae1dc2d55693f9c84c862fbd34742b4587404c'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV940(): {threshold: number, proposal: v940.Call, lengthBound: number} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Council.propose') === 'c3f00b703b2d2464186b23f2f1d6f981a77e572267b0ebd9b1d4a8afd8575fcf'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV942(): {threshold: number, proposal: v942.Call, lengthBound: number} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Council.propose') === '3ef5937b1b4c3bdb4e5cc75a1514965ecb0331de393cf32c1333cfdbba45ab1b'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV944(): {threshold: number, proposal: v944.Call, lengthBound: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Council.propose') === '2b01969fada1d70522b1cc3e10b99d04b59f531ea3f870d3b05a6580bfd16729'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV946(): {threshold: number, proposal: v946.Call, lengthBound: number} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Council.propose') === '19c5666cc1ab51a086d59ef7021d791b2396bd2d72f277d5ba77bd4e94cd6e37'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV948(): {threshold: number, proposal: v948.Call, lengthBound: number} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Council.propose') === '19253b17f491c46d120f34c0cee9adc0c5315351e1d70c7553b1292c28ce2c89'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV952(): {threshold: number, proposal: v952.Call, lengthBound: number} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Council.propose') === '25b4990d6684bb47ee24d6e485bdde1e177b1f3bf33289b5907a1b3e6d8a7870'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV954(): {threshold: number, proposal: v954.Call, lengthBound: number} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Council.propose') === '5f46bae18c543a35e21563d7ac7038d09aaef00fa5e5f0030fc249848c6674ee'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV956(): {threshold: number, proposal: v956.Call, lengthBound: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Council.propose') === 'b2429ea5b67dcb3613a44ce4eca41aab2a7d818fcb6d93bc52e54cf039057fdd'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV958(): {threshold: number, proposal: v958.Call, lengthBound: number} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Council.propose') === '85860d42d52d56e49bf59b1e1c7235b4243e529836debf5ac042da4db040978a'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV962(): {threshold: number, proposal: v962.Call, lengthBound: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Council.propose') === '80af865ba4783036af1e2c253d52784398579cecdaaa1d9626f65edf4d597380'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV964(): {threshold: number, proposal: v964.Call, lengthBound: number} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Council.propose') === '25631c1487ed3953a6b6ac285dc2317f6b9f99bddb9cef1639383e5cf82d522e'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV967(): {threshold: number, proposal: v967.Call, lengthBound: number} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Council.propose') === '172d0946e3216408981ba8703fd12bd1b40170c41cc9da8061bccbd2c4119143'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV968(): {threshold: number, proposal: v968.Call, lengthBound: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Council.propose') === 'b2b73888fc3098733b33b553f1487e271d9bf8105869378cb4f77091600b4d14'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV970(): {threshold: number, proposal: v970.Call, lengthBound: number} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Council.propose') === '3045fee08872ddc64e0b5aef0e83be55f34c08fba3c390c4cf5a50bcc32a2203'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV972(): {threshold: number, proposal: v972.Call, lengthBound: number} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilSetMembersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.set_members')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the collective's membership.
     * 
     *  - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     *  - `prime`: The prime member whose vote sets the default.
     *  - `old_count`: The upper bound for the previous number of members in storage.
     *                 Used for weight estimation.
     * 
     *  Requires root origin.
     * 
     *  NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     *        the weight estimations rely on it to estimate dispatchable weight.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(MP + N)` where:
     *    - `M` old-members-count (code- and governance-bounded)
     *    - `N` new-members-count (code- and governance-bounded)
     *    - `P` proposals-count (code-bounded)
     *  - DB:
     *    - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members
     *    - 1 storage read (codec `O(P)`) for reading the proposals
     *    - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
     *    - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Council.set_members') === '71b7fcb1d8a62eff96a9ef006517578ce9189e6d931948a256a04ca75ff68d4a'
    }

    /**
     *  Set the collective's membership.
     * 
     *  - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     *  - `prime`: The prime member whose vote sets the default.
     *  - `old_count`: The upper bound for the previous number of members in storage.
     *                 Used for weight estimation.
     * 
     *  Requires root origin.
     * 
     *  NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     *        the weight estimations rely on it to estimate dispatchable weight.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(MP + N)` where:
     *    - `M` old-members-count (code- and governance-bounded)
     *    - `N` new-members-count (code- and governance-bounded)
     *    - `P` proposals-count (code-bounded)
     *  - DB:
     *    - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members
     *    - 1 storage read (codec `O(P)`) for reading the proposals
     *    - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
     *    - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
     *  # </weight>
     */
    get asV803(): {newMembers: Uint8Array[], prime: (Uint8Array | undefined), oldCount: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add an aye or nay vote for the sender to the given proposal.
     * 
     *  Requires the sender to be a member.
     * 
     *  Transaction fees will be waived if the member is voting on any particular proposal
     *  for the first time and the call is successful. Subsequent vote changes will charge a fee.
     *  # <weight>
     *  ## Weight
     *  - `O(M)` where `M` is members-count (code- and governance-bounded)
     *  - DB:
     *    - 1 storage read `Members` (codec `O(M)`)
     *    - 1 storage mutation `Voting` (codec `O(M)`)
     *  - 1 event
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Council.vote') === 'f8a1069a57f7b721f47c086d08b6838ae1a0c08f58caddb82428ba5f1407540f'
    }

    /**
     *  Add an aye or nay vote for the sender to the given proposal.
     * 
     *  Requires the sender to be a member.
     * 
     *  Transaction fees will be waived if the member is voting on any particular proposal
     *  for the first time and the call is successful. Subsequent vote changes will charge a fee.
     *  # <weight>
     *  ## Weight
     *  - `O(M)` where `M` is members-count (code- and governance-bounded)
     *  - DB:
     *    - 1 storage read `Members` (codec `O(M)`)
     *    - 1 storage mutation `Voting` (codec `O(M)`)
     *  - 1 event
     *  # </weight>
     */
    get asV803(): {proposal: Uint8Array, index: number, approve: boolean} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilMembershipAddMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CouncilMembership.add_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add a member `who` to the set.
     * 
     *  May only be called from `T::AddOrigin`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('CouncilMembership.add_member') === 'b8a0d2208835f6ada60dd21cd93533d703777b3779109a7c6a2f26bad68c2f3b'
    }

    /**
     *  Add a member `who` to the set.
     * 
     *  May only be called from `T::AddOrigin`.
     */
    get asV803(): {who: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a member `who` to the set.
     * 
     * May only be called from `T::AddOrigin`.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('CouncilMembership.add_member') === 'bb6d6c7e28eeb3aad04d22b6921e046cbe5b8efaf6ef127a2c0c9535239f94e7'
    }

    /**
     * Add a member `who` to the set.
     * 
     * May only be called from `T::AddOrigin`.
     */
    get asV968(): {who: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilMembershipChangeKeyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CouncilMembership.change_key')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Swap out the sending member for some other key `new`.
     * 
     *  May only be called from `Signed` origin of a current member.
     * 
     *  Prime membership is passed from the origin account to `new`, if extant.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('CouncilMembership.change_key') === 'f866dcb3e8857987a2d21e57c13216c10bb21546a718b81d5e2c0989d6e95df7'
    }

    /**
     *  Swap out the sending member for some other key `new`.
     * 
     *  May only be called from `Signed` origin of a current member.
     * 
     *  Prime membership is passed from the origin account to `new`, if extant.
     */
    get asV803(): {new: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Swap out the sending member for some other key `new`.
     * 
     * May only be called from `Signed` origin of a current member.
     * 
     * Prime membership is passed from the origin account to `new`, if extant.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('CouncilMembership.change_key') === 'd0eb457ece644571cebe79cbdd64ef1453c382048ffec79f9c403f7bc8f90020'
    }

    /**
     * Swap out the sending member for some other key `new`.
     * 
     * May only be called from `Signed` origin of a current member.
     * 
     * Prime membership is passed from the origin account to `new`, if extant.
     */
    get asV968(): {new: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilMembershipClearPrimeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CouncilMembership.clear_prime')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove the prime member if it exists.
     * 
     *  May only be called from `T::PrimeOrigin`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('CouncilMembership.clear_prime') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Remove the prime member if it exists.
     * 
     *  May only be called from `T::PrimeOrigin`.
     */
    get asV803(): null {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilMembershipRemoveMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CouncilMembership.remove_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a member `who` from the set.
     * 
     *  May only be called from `T::RemoveOrigin`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('CouncilMembership.remove_member') === 'b8a0d2208835f6ada60dd21cd93533d703777b3779109a7c6a2f26bad68c2f3b'
    }

    /**
     *  Remove a member `who` from the set.
     * 
     *  May only be called from `T::RemoveOrigin`.
     */
    get asV803(): {who: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove a member `who` from the set.
     * 
     * May only be called from `T::RemoveOrigin`.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('CouncilMembership.remove_member') === 'bb6d6c7e28eeb3aad04d22b6921e046cbe5b8efaf6ef127a2c0c9535239f94e7'
    }

    /**
     * Remove a member `who` from the set.
     * 
     * May only be called from `T::RemoveOrigin`.
     */
    get asV968(): {who: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilMembershipResetMembersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CouncilMembership.reset_members')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Change the membership to a new set, disregarding the existing membership. Be nice and
     *  pass `members` pre-sorted.
     * 
     *  May only be called from `T::ResetOrigin`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('CouncilMembership.reset_members') === 'd8adca14f9b9cadeaf2b2e6dd47991d05cb423ce3a00dccbb9efa35e36f5a65a'
    }

    /**
     *  Change the membership to a new set, disregarding the existing membership. Be nice and
     *  pass `members` pre-sorted.
     * 
     *  May only be called from `T::ResetOrigin`.
     */
    get asV803(): {members: Uint8Array[]} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilMembershipSetPrimeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CouncilMembership.set_prime')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the prime member. Must be a current member.
     * 
     *  May only be called from `T::PrimeOrigin`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('CouncilMembership.set_prime') === 'b8a0d2208835f6ada60dd21cd93533d703777b3779109a7c6a2f26bad68c2f3b'
    }

    /**
     *  Set the prime member. Must be a current member.
     * 
     *  May only be called from `T::PrimeOrigin`.
     */
    get asV803(): {who: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the prime member. Must be a current member.
     * 
     * May only be called from `T::PrimeOrigin`.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('CouncilMembership.set_prime') === 'bb6d6c7e28eeb3aad04d22b6921e046cbe5b8efaf6ef127a2c0c9535239f94e7'
    }

    /**
     * Set the prime member. Must be a current member.
     * 
     * May only be called from `T::PrimeOrigin`.
     */
    get asV968(): {who: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilMembershipSwapMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CouncilMembership.swap_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Swap out one member `remove` for another `add`.
     * 
     *  May only be called from `T::SwapOrigin`.
     * 
     *  Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('CouncilMembership.swap_member') === 'f9cf5ef851567c52b54f359126b80e6fa967b49f082dd77310b8461819cd13df'
    }

    /**
     *  Swap out one member `remove` for another `add`.
     * 
     *  May only be called from `T::SwapOrigin`.
     * 
     *  Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    get asV803(): {remove: Uint8Array, add: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Swap out one member `remove` for another `add`.
     * 
     * May only be called from `T::SwapOrigin`.
     * 
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('CouncilMembership.swap_member') === '6204d1b2fba84c1b9c33991cd1e58bf8c021ede5edfb777acbb025799df5bc4f'
    }

    /**
     * Swap out one member `remove` for another `add`.
     * 
     * May only be called from `T::SwapOrigin`.
     * 
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    get asV968(): {remove: v968.MultiAddress, add: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class CrossInOutAddToIssueWhitelistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CrossInOut.add_to_issue_whitelist')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('CrossInOut.add_to_issue_whitelist') === '7744d5c2e503066b8cb07aca0a7406cf18808997ce244498314e13bee09c2824'
    }

    get asV962(): {currencyId: v962.CurrencyId, account: Uint8Array} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class CrossInOutAddToRegisterWhitelistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CrossInOut.add_to_register_whitelist')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('CrossInOut.add_to_register_whitelist') === '7744d5c2e503066b8cb07aca0a7406cf18808997ce244498314e13bee09c2824'
    }

    get asV962(): {currencyId: v962.CurrencyId, account: Uint8Array} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class CrossInOutChangeOuterLinkedAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CrossInOut.change_outer_linked_account')
        this._chain = ctx._chain
        this.call = call
    }

    get isV964(): boolean {
        return this._chain.getCallHash('CrossInOut.change_outer_linked_account') === 'a428df37863242f7ce3ee02a2e15251337ada6584e7521982c05bd93a69999cc'
    }

    get asV964(): {currencyId: v964.CurrencyId, foreignLocation: v964.V1MultiLocation} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('CrossInOut.change_outer_linked_account') === 'f3c886410a02820ec635869a663c0bccd963de42b7e88ce1126db226055d263e'
    }

    get asV970(): {currencyId: v970.CurrencyId, foreignLocation: v970.V1MultiLocation, account: Uint8Array} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }
}

export class CrossInOutCrossInCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CrossInOut.cross_in')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('CrossInOut.cross_in') === '448565d9d11bb51b175523b5303a17ba282449b36f19039483f1bf6d097f8e2d'
    }

    get asV962(): {location: v962.V1MultiLocation, currencyId: v962.CurrencyId, amount: bigint, remark: (Uint8Array | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('CrossInOut.cross_in') === '7a47d18c41efa7c3c5d35c2be8ac0c9848b3ea1bd668a9694491ed8d0d29e6f8'
    }

    get asV970(): {location: v970.V1MultiLocation, currencyId: v970.CurrencyId, amount: bigint, remark: (Uint8Array | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }
}

export class CrossInOutCrossOutCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CrossInOut.cross_out')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Destroy some balance from an account and issue cross-out event.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('CrossInOut.cross_out') === 'c635eaaf52ffe6f13bfd2bf1acd062484cf4314b6a2baec7ae9aee7341109498'
    }

    /**
     * Destroy some balance from an account and issue cross-out event.
     */
    get asV962(): {currencyId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class CrossInOutDeregisterCurrencyForCrossInOutCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CrossInOut.deregister_currency_for_cross_in_out')
        this._chain = ctx._chain
        this.call = call
    }

    get isV967(): boolean {
        return this._chain.getCallHash('CrossInOut.deregister_currency_for_cross_in_out') === '0a9d3c015dc155696ea30a98c73282f04dad76fa0e64157d75dc0b4c7d3bfec6'
    }

    get asV967(): {currencyId: v967.CurrencyId} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }
}

export class CrossInOutRegisterCurrencyForCrossInOutCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CrossInOut.register_currency_for_cross_in_out')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('CrossInOut.register_currency_for_cross_in_out') === 'c6af28f7d481ca6cdf69fbe83549fb136b4581b4c69e1d28ef838055c0af93da'
    }

    get asV962(): {currencyId: v962.CurrencyId, operation: boolean} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV967(): boolean {
        return this._chain.getCallHash('CrossInOut.register_currency_for_cross_in_out') === '0a9d3c015dc155696ea30a98c73282f04dad76fa0e64157d75dc0b4c7d3bfec6'
    }

    get asV967(): {currencyId: v967.CurrencyId} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }
}

export class CrossInOutRegisterLinkedAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CrossInOut.register_linked_account')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('CrossInOut.register_linked_account') === '7dc95c274d6ef133d5c7c43172f1ed326af120c7c9def37d3a052196c98b8507'
    }

    get asV962(): {currencyId: v962.CurrencyId, who: Uint8Array, foreignLocation: v962.V1MultiLocation} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('CrossInOut.register_linked_account') === 'ea062bb9e8c196a152adc91cebebcd23a74792a0437b645a1fb60d371c621b89'
    }

    get asV970(): {currencyId: v970.CurrencyId, who: Uint8Array, foreignLocation: v970.V1MultiLocation} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }
}

export class CrossInOutRemoveFromIssueWhitelistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CrossInOut.remove_from_issue_whitelist')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('CrossInOut.remove_from_issue_whitelist') === '7744d5c2e503066b8cb07aca0a7406cf18808997ce244498314e13bee09c2824'
    }

    get asV962(): {currencyId: v962.CurrencyId, account: Uint8Array} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class CrossInOutRemoveFromRegisterWhitelistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CrossInOut.remove_from_register_whitelist')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('CrossInOut.remove_from_register_whitelist') === '7744d5c2e503066b8cb07aca0a7406cf18808997ce244498314e13bee09c2824'
    }

    get asV962(): {currencyId: v962.CurrencyId, account: Uint8Array} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class CrossInOutSetCrossingMinimumAmountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'CrossInOut.set_crossing_minimum_amount')
        this._chain = ctx._chain
        this.call = call
    }

    get isV964(): boolean {
        return this._chain.getCallHash('CrossInOut.set_crossing_minimum_amount') === '374b27cf5e4ee14009fad03e4ff93bc50ff078e22788bc9e84e022b42e1ad02d'
    }

    get asV964(): {currencyId: v964.CurrencyId, crossInMinimum: bigint, crossOutMinimum: bigint} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }
}

export class CurrenciesTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Currencies.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer some balance to another account under `currency_id`.
     * 
     *  The dispatch origin for this call must be `Signed` by the
     *  transactor.
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Currencies.transfer') === '4c4cbab1d07da2115964fbc45ffe538519770d4ed8cefd19ca4b8a0091deb605'
    }

    /**
     *  Transfer some balance to another account under `currency_id`.
     * 
     *  The dispatch origin for this call must be `Signed` by the
     *  transactor.
     */
    get asV802(): {dest: v802.LookupSource, currencyId: v802.CurrencyIdOf, amount: bigint} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some balance to another account under `currency_id`.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Currencies.transfer') === 'b9fb4d5743e79104d370b60713a3be4e66245f43aaa364cb6d61b0588d7e7a02'
    }

    /**
     * Transfer some balance to another account under `currency_id`.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     */
    get asV906(): {dest: v906.MultiAddress, currencyId: v906.CurrencyId, amount: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some balance to another account under `currency_id`.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Currencies.transfer') === 'a9948001bd2c3683445876d000abbd80e9ab09caa7edc5287f1cfad9aa0a3f16'
    }

    /**
     * Transfer some balance to another account under `currency_id`.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     */
    get asV916(): {dest: v916.MultiAddress, currencyId: v916.CurrencyId, amount: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some balance to another account under `currency_id`.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Currencies.transfer') === 'a1a170cec9dafb23176128f9246a564eec06ec01b8778cde87df8e380c5547ad'
    }

    /**
     * Transfer some balance to another account under `currency_id`.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     */
    get asV920(): {dest: v920.MultiAddress, currencyId: v920.CurrencyId, amount: bigint} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some balance to another account under `currency_id`.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Currencies.transfer') === 'a76551106730e876302af72d8d390053d6c4f5b7fc5028597728d896db6977f5'
    }

    /**
     * Transfer some balance to another account under `currency_id`.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     */
    get asV932(): {dest: v932.MultiAddress, currencyId: v932.CurrencyId, amount: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some balance to another account under `currency_id`.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Currencies.transfer') === 'b6188ad53f64db3b57f68ca0a0374dc7feaac8f5a460fcd009e7836959c34140'
    }

    /**
     * Transfer some balance to another account under `currency_id`.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     */
    get asV956(): {dest: v956.MultiAddress, currencyId: v956.CurrencyId, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some balance to another account under `currency_id`.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Currencies.transfer') === '04924dbf38b6be9c9b1c8f45f093016a733b1ae1eed8f532c3f518d69b77390a'
    }

    /**
     * Transfer some balance to another account under `currency_id`.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     */
    get asV962(): {dest: v962.MultiAddress, currencyId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class CurrenciesTransferNativeCurrencyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Currencies.transfer_native_currency')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer some native currency to another account.
     * 
     *  The dispatch origin for this call must be `Signed` by the
     *  transactor.
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Currencies.transfer_native_currency') === '99123a58f21a27e3615c09aa5e891295609109fa77378a29bc61ee98ab991b92'
    }

    /**
     *  Transfer some native currency to another account.
     * 
     *  The dispatch origin for this call must be `Signed` by the
     *  transactor.
     */
    get asV802(): {dest: v802.LookupSource, amount: bigint} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }
}

export class CurrenciesUpdateBalanceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Currencies.update_balance')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  update amount of account `who` under `currency_id`.
     * 
     *  The dispatch origin of this call must be _Root_.
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Currencies.update_balance') === 'dfa05f9cc5b6d5d3cd451f905533f1396aea66813d2529a62b74c3bf4e1e0c5e'
    }

    /**
     *  update amount of account `who` under `currency_id`.
     * 
     *  The dispatch origin of this call must be _Root_.
     */
    get asV802(): {who: v802.LookupSource, currencyId: v802.CurrencyIdOf, amount: bigint} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     * update amount of account `who` under `currency_id`.
     * 
     * The dispatch origin of this call must be _Root_.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Currencies.update_balance') === '838d6297444133a8546a183186d97a32d3c1ac1e8477f3a78f8da7958d10d97f'
    }

    /**
     * update amount of account `who` under `currency_id`.
     * 
     * The dispatch origin of this call must be _Root_.
     */
    get asV906(): {who: v906.MultiAddress, currencyId: v906.CurrencyId, amount: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * update amount of account `who` under `currency_id`.
     * 
     * The dispatch origin of this call must be _Root_.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Currencies.update_balance') === '602ec05c9e7cf2dd56b0043356db01c28547d3a5e2a63fe61e6b1ca295e04faf'
    }

    /**
     * update amount of account `who` under `currency_id`.
     * 
     * The dispatch origin of this call must be _Root_.
     */
    get asV916(): {who: v916.MultiAddress, currencyId: v916.CurrencyId, amount: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * update amount of account `who` under `currency_id`.
     * 
     * The dispatch origin of this call must be _Root_.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Currencies.update_balance') === '7465d54d2e5b2c7fd6840f59a6f52a6dcef2a99bb6431e83cb106909d325cf38'
    }

    /**
     * update amount of account `who` under `currency_id`.
     * 
     * The dispatch origin of this call must be _Root_.
     */
    get asV920(): {who: v920.MultiAddress, currencyId: v920.CurrencyId, amount: bigint} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * update amount of account `who` under `currency_id`.
     * 
     * The dispatch origin of this call must be _Root_.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Currencies.update_balance') === '1155b464b64af2408cca6b52136cc4b0ad3aa47d270636ba44a4c5c2e8a07f6e'
    }

    /**
     * update amount of account `who` under `currency_id`.
     * 
     * The dispatch origin of this call must be _Root_.
     */
    get asV932(): {who: v932.MultiAddress, currencyId: v932.CurrencyId, amount: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * update amount of account `who` under `currency_id`.
     * 
     * The dispatch origin of this call must be _Root_.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Currencies.update_balance') === 'c6895da2e1b99aae1286f9f828a6334bfb3df7f98855002c294f50e5411333be'
    }

    /**
     * update amount of account `who` under `currency_id`.
     * 
     * The dispatch origin of this call must be _Root_.
     */
    get asV956(): {who: v956.MultiAddress, currencyId: v956.CurrencyId, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * update amount of account `who` under `currency_id`.
     * 
     * The dispatch origin of this call must be _Root_.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Currencies.update_balance') === '733c75fabd38eb237eb6db8a0df9e6e4200db05e9b9524d0349c98dc4d02c532'
    }

    /**
     * update amount of account `who` under `currency_id`.
     * 
     * The dispatch origin of this call must be _Root_.
     */
    get asV962(): {who: v962.MultiAddress, currencyId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyBlacklistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.blacklist')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Permanently place a proposal into the blacklist. This prevents it from ever being
     *  proposed again.
     * 
     *  If called on a queued public or external proposal, then this will result in it being
     *  removed. If the `ref_index` supplied is an active referendum with the proposal hash,
     *  then it will be cancelled.
     * 
     *  The dispatch origin of this call must be `BlacklistOrigin`.
     * 
     *  - `proposal_hash`: The proposal hash to blacklist permanently.
     *  - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
     *  cancelled.
     * 
     *  Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
     *    reasonable value).
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.blacklist') === '8d8922c0775adfb1df719211ab4fc6fb40b6cc8864038bcb1b544d9cf039b30a'
    }

    /**
     *  Permanently place a proposal into the blacklist. This prevents it from ever being
     *  proposed again.
     * 
     *  If called on a queued public or external proposal, then this will result in it being
     *  removed. If the `ref_index` supplied is an active referendum with the proposal hash,
     *  then it will be cancelled.
     * 
     *  The dispatch origin of this call must be `BlacklistOrigin`.
     * 
     *  - `proposal_hash`: The proposal hash to blacklist permanently.
     *  - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
     *  cancelled.
     * 
     *  Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
     *    reasonable value).
     */
    get asV803(): {proposalHash: Uint8Array, maybeRefIndex: (number | undefined)} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyCancelProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.cancel_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a proposal.
     * 
     *  The dispatch origin of this call must be `CancelProposalOrigin`.
     * 
     *  - `prop_index`: The index of the proposal to cancel.
     * 
     *  Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.cancel_proposal') === '0e50c7564a4a7f4e6a09a0abcc8022f4445c064144d2318ed086e6080bee800d'
    }

    /**
     *  Remove a proposal.
     * 
     *  The dispatch origin of this call must be `CancelProposalOrigin`.
     * 
     *  - `prop_index`: The index of the proposal to cancel.
     * 
     *  Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
     */
    get asV803(): {propIndex: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyCancelQueuedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.cancel_queued')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel a proposal queued for enactment.
     * 
     *  The dispatch origin of this call must be _Root_.
     * 
     *  - `which`: The index of the referendum to cancel.
     * 
     *  Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.cancel_queued') === '60780274011857b5305b5413b2b4742e5d41eb58a0948049d0672e81af198cb7'
    }

    /**
     *  Cancel a proposal queued for enactment.
     * 
     *  The dispatch origin of this call must be _Root_.
     * 
     *  - `which`: The index of the referendum to cancel.
     * 
     *  Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`.
     */
    get asV803(): {which: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyCancelReferendumCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.cancel_referendum')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a referendum.
     * 
     *  The dispatch origin of this call must be _Root_.
     * 
     *  - `ref_index`: The index of the referendum to cancel.
     * 
     *  # Weight: `O(1)`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.cancel_referendum') === 'efe4ecff834678ca8b73ea6e2f38e514997eb402e82da2ce4cf036008844a857'
    }

    /**
     *  Remove a referendum.
     * 
     *  The dispatch origin of this call must be _Root_.
     * 
     *  - `ref_index`: The index of the referendum to cancel.
     * 
     *  # Weight: `O(1)`.
     */
    get asV803(): {refIndex: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyClearPublicProposalsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.clear_public_proposals')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Clears all public proposals.
     * 
     *  The dispatch origin of this call must be _Root_.
     * 
     *  Weight: `O(1)`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.clear_public_proposals') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Clears all public proposals.
     * 
     *  The dispatch origin of this call must be _Root_.
     * 
     *  Weight: `O(1)`.
     */
    get asV803(): null {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyDelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.delegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Delegate the voting power (with some given conviction) of the sending account.
     * 
     *  The balance delegated is locked for as long as it's delegated, and thereafter for the
     *  time appropriate for the conviction's lock period.
     * 
     *  The dispatch origin of this call must be _Signed_, and the signing account must either:
     *    - be delegating already; or
     *    - have no voting activity (if there is, then it will need to be removed/consolidated
     *      through `reap_vote` or `unvote`).
     * 
     *  - `to`: The account whose voting the `target` account's voting power will follow.
     *  - `conviction`: The conviction that will be attached to the delegated votes. When the
     *    account is undelegated, the funds will be locked for the corresponding period.
     *  - `balance`: The amount of the account's balance to be used in delegating. This must
     *    not be more than the account's current balance.
     * 
     *  Emits `Delegated`.
     * 
     *  Weight: `O(R)` where R is the number of referendums the voter delegating to has
     *    voted on. Weight is charged as if maximum votes.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.delegate') === '719d303e364256b757876a8d1b18c8d62a96223d68ffc6f6c1bf18240e8d9793'
    }

    /**
     *  Delegate the voting power (with some given conviction) of the sending account.
     * 
     *  The balance delegated is locked for as long as it's delegated, and thereafter for the
     *  time appropriate for the conviction's lock period.
     * 
     *  The dispatch origin of this call must be _Signed_, and the signing account must either:
     *    - be delegating already; or
     *    - have no voting activity (if there is, then it will need to be removed/consolidated
     *      through `reap_vote` or `unvote`).
     * 
     *  - `to`: The account whose voting the `target` account's voting power will follow.
     *  - `conviction`: The conviction that will be attached to the delegated votes. When the
     *    account is undelegated, the funds will be locked for the corresponding period.
     *  - `balance`: The amount of the account's balance to be used in delegating. This must
     *    not be more than the account's current balance.
     * 
     *  Emits `Delegated`.
     * 
     *  Weight: `O(R)` where R is the number of referendums the voter delegating to has
     *    voted on. Weight is charged as if maximum votes.
     */
    get asV803(): {to: Uint8Array, conviction: v803.Conviction, balance: bigint} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Delegate the voting power (with some given conviction) of the sending account.
     * 
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     * 
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     *   - be delegating already; or
     *   - have no voting activity (if there is, then it will need to be removed/consolidated
     *     through `reap_vote` or `unvote`).
     * 
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     *   account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     *   be more than the account's current balance.
     * 
     * Emits `Delegated`.
     * 
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     *   voted on. Weight is charged as if maximum votes.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Democracy.delegate') === 'db1dd187dadcd6aeb77ad01c1101f445ff84405d1edf14f83f5cb3bde184925d'
    }

    /**
     * Delegate the voting power (with some given conviction) of the sending account.
     * 
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     * 
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     *   - be delegating already; or
     *   - have no voting activity (if there is, then it will need to be removed/consolidated
     *     through `reap_vote` or `unvote`).
     * 
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     *   account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     *   be more than the account's current balance.
     * 
     * Emits `Delegated`.
     * 
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     *   voted on. Weight is charged as if maximum votes.
     */
    get asV968(): {to: v968.MultiAddress, conviction: v968.Conviction, balance: bigint} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyEmergencyCancelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.emergency_cancel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
     *  referendum.
     * 
     *  The dispatch origin of this call must be `CancellationOrigin`.
     * 
     *  -`ref_index`: The index of the referendum to cancel.
     * 
     *  Weight: `O(1)`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.emergency_cancel') === '8a84371403a09e2f8fc2aac80f5a8a53229b346c4b3859069867b8e656b13450'
    }

    /**
     *  Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
     *  referendum.
     * 
     *  The dispatch origin of this call must be `CancellationOrigin`.
     * 
     *  -`ref_index`: The index of the referendum to cancel.
     * 
     *  Weight: `O(1)`.
     */
    get asV803(): {refIndex: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyEnactProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.enact_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Enact a proposal from a referendum. For now we just make the weight be the maximum.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.enact_proposal') === 'de192ab0f058d1fb7eacc523bf0e05128d16509ec21bf445f0eefa47c89e60bf'
    }

    /**
     *  Enact a proposal from a referendum. For now we just make the weight be the maximum.
     */
    get asV803(): {proposalHash: Uint8Array, index: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyExternalProposeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.external_propose')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule a referendum to be tabled once it is legal to schedule an external
     *  referendum.
     * 
     *  The dispatch origin of this call must be `ExternalOrigin`.
     * 
     *  - `proposal_hash`: The preimage hash of the proposal.
     * 
     *  Weight: `O(V)` with V number of vetoers in the blacklist of proposal.
     *    Decoding vec of length V. Charged as maximum
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.external_propose') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Schedule a referendum to be tabled once it is legal to schedule an external
     *  referendum.
     * 
     *  The dispatch origin of this call must be `ExternalOrigin`.
     * 
     *  - `proposal_hash`: The preimage hash of the proposal.
     * 
     *  Weight: `O(V)` with V number of vetoers in the blacklist of proposal.
     *    Decoding vec of length V. Charged as maximum
     */
    get asV803(): {proposalHash: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a referendum to be tabled once it is legal to schedule an external
     * referendum.
     * 
     * The dispatch origin of this call must be `ExternalOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Democracy.external_propose') === 'e44fb402f80afe0e08cb6de5a4ed457a1a66e080379319fd281acd81eaf457ac'
    }

    /**
     * Schedule a referendum to be tabled once it is legal to schedule an external
     * referendum.
     * 
     * The dispatch origin of this call must be `ExternalOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     */
    get asV968(): {proposal: v968.Bounded} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyExternalProposeDefaultCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.external_propose_default')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     *  schedule an external referendum.
     * 
     *  The dispatch of this call must be `ExternalDefaultOrigin`.
     * 
     *  - `proposal_hash`: The preimage hash of the proposal.
     * 
     *  Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     *  pre-scheduled `external_propose` call.
     * 
     *  Weight: `O(1)`
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.external_propose_default') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     *  schedule an external referendum.
     * 
     *  The dispatch of this call must be `ExternalDefaultOrigin`.
     * 
     *  - `proposal_hash`: The preimage hash of the proposal.
     * 
     *  Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     *  pre-scheduled `external_propose` call.
     * 
     *  Weight: `O(1)`
     */
    get asV803(): {proposalHash: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     * schedule an external referendum.
     * 
     * The dispatch of this call must be `ExternalDefaultOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     * 
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     * 
     * Weight: `O(1)`
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Democracy.external_propose_default') === 'e44fb402f80afe0e08cb6de5a4ed457a1a66e080379319fd281acd81eaf457ac'
    }

    /**
     * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     * schedule an external referendum.
     * 
     * The dispatch of this call must be `ExternalDefaultOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     * 
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     * 
     * Weight: `O(1)`
     */
    get asV968(): {proposal: v968.Bounded} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyExternalProposeMajorityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.external_propose_majority')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     *  an external referendum.
     * 
     *  The dispatch of this call must be `ExternalMajorityOrigin`.
     * 
     *  - `proposal_hash`: The preimage hash of the proposal.
     * 
     *  Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     *  pre-scheduled `external_propose` call.
     * 
     *  Weight: `O(1)`
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.external_propose_majority') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     *  an external referendum.
     * 
     *  The dispatch of this call must be `ExternalMajorityOrigin`.
     * 
     *  - `proposal_hash`: The preimage hash of the proposal.
     * 
     *  Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     *  pre-scheduled `external_propose` call.
     * 
     *  Weight: `O(1)`
     */
    get asV803(): {proposalHash: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     * an external referendum.
     * 
     * The dispatch of this call must be `ExternalMajorityOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     * 
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     * 
     * Weight: `O(1)`
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Democracy.external_propose_majority') === 'e44fb402f80afe0e08cb6de5a4ed457a1a66e080379319fd281acd81eaf457ac'
    }

    /**
     * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     * an external referendum.
     * 
     * The dispatch of this call must be `ExternalMajorityOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     * 
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     * 
     * Weight: `O(1)`
     */
    get asV968(): {proposal: v968.Bounded} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyFastTrackCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.fast_track')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule the currently externally-proposed majority-carries referendum to be tabled
     *  immediately. If there is no externally-proposed referendum currently, or if there is one
     *  but it is not a majority-carries referendum then it fails.
     * 
     *  The dispatch of this call must be `FastTrackOrigin`.
     * 
     *  - `proposal_hash`: The hash of the current external proposal.
     *  - `voting_period`: The period that is allowed for voting on this proposal. Increased to
     *    `FastTrackVotingPeriod` if too low.
     *  - `delay`: The number of block after voting has ended in approval and this should be
     *    enacted. This doesn't have a minimum amount.
     * 
     *  Emits `Started`.
     * 
     *  Weight: `O(1)`
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.fast_track') === '27cb200e922e485b41e3150b3d7bf5e8624346f6ff1d78601373ba3d80689c89'
    }

    /**
     *  Schedule the currently externally-proposed majority-carries referendum to be tabled
     *  immediately. If there is no externally-proposed referendum currently, or if there is one
     *  but it is not a majority-carries referendum then it fails.
     * 
     *  The dispatch of this call must be `FastTrackOrigin`.
     * 
     *  - `proposal_hash`: The hash of the current external proposal.
     *  - `voting_period`: The period that is allowed for voting on this proposal. Increased to
     *    `FastTrackVotingPeriod` if too low.
     *  - `delay`: The number of block after voting has ended in approval and this should be
     *    enacted. This doesn't have a minimum amount.
     * 
     *  Emits `Started`.
     * 
     *  Weight: `O(1)`
     */
    get asV803(): {proposalHash: Uint8Array, votingPeriod: number, delay: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyNoteImminentPreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.note_imminent_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register the preimage for an upcoming proposal. This requires the proposal to be
     *  in the dispatch queue. No deposit is needed. When this call is successful, i.e.
     *  the preimage has not been uploaded before and matches some imminent proposal,
     *  no fee is paid.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `encoded_proposal`: The preimage of a proposal.
     * 
     *  Emits `PreimageNoted`.
     * 
     *  Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit).
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.note_imminent_preimage') === 'bc60303cdd91077cf965a8aec4728ff7f49fea4055259a274e22145314e7c9eb'
    }

    /**
     *  Register the preimage for an upcoming proposal. This requires the proposal to be
     *  in the dispatch queue. No deposit is needed. When this call is successful, i.e.
     *  the preimage has not been uploaded before and matches some imminent proposal,
     *  no fee is paid.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `encoded_proposal`: The preimage of a proposal.
     * 
     *  Emits `PreimageNoted`.
     * 
     *  Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit).
     */
    get asV803(): {encodedProposal: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyNoteImminentPreimageOperationalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.note_imminent_preimage_operational')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.note_imminent_preimage_operational') === 'bc60303cdd91077cf965a8aec4728ff7f49fea4055259a274e22145314e7c9eb'
    }

    /**
     *  Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`.
     */
    get asV803(): {encodedProposal: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyNotePreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.note_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register the preimage for an upcoming proposal. This doesn't require the proposal to be
     *  in the dispatch queue but does require a deposit, returned once enacted.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `encoded_proposal`: The preimage of a proposal.
     * 
     *  Emits `PreimageNoted`.
     * 
     *  Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit).
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.note_preimage') === 'bc60303cdd91077cf965a8aec4728ff7f49fea4055259a274e22145314e7c9eb'
    }

    /**
     *  Register the preimage for an upcoming proposal. This doesn't require the proposal to be
     *  in the dispatch queue but does require a deposit, returned once enacted.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `encoded_proposal`: The preimage of a proposal.
     * 
     *  Emits `PreimageNoted`.
     * 
     *  Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit).
     */
    get asV803(): {encodedProposal: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyNotePreimageOperationalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.note_preimage_operational')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Same as `note_preimage` but origin is `OperationalPreimageOrigin`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.note_preimage_operational') === 'bc60303cdd91077cf965a8aec4728ff7f49fea4055259a274e22145314e7c9eb'
    }

    /**
     *  Same as `note_preimage` but origin is `OperationalPreimageOrigin`.
     */
    get asV803(): {encodedProposal: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyProposeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.propose')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Propose a sensitive action to be taken.
     * 
     *  The dispatch origin of this call must be _Signed_ and the sender must
     *  have funds to cover the deposit.
     * 
     *  - `proposal_hash`: The hash of the proposal preimage.
     *  - `value`: The amount of deposit (must be at least `MinimumDeposit`).
     * 
     *  Emits `Proposed`.
     * 
     *  Weight: `O(p)`
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.propose') === '99f964e94c86db2029fab3e54a9230e36fe7533d252b5ecbc36f16c06e11f18b'
    }

    /**
     *  Propose a sensitive action to be taken.
     * 
     *  The dispatch origin of this call must be _Signed_ and the sender must
     *  have funds to cover the deposit.
     * 
     *  - `proposal_hash`: The hash of the proposal preimage.
     *  - `value`: The amount of deposit (must be at least `MinimumDeposit`).
     * 
     *  Emits `Proposed`.
     * 
     *  Weight: `O(p)`
     */
    get asV803(): {proposalHash: Uint8Array, value: bigint} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Propose a sensitive action to be taken.
     * 
     * The dispatch origin of this call must be _Signed_ and the sender must
     * have funds to cover the deposit.
     * 
     * - `proposal_hash`: The hash of the proposal preimage.
     * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
     * 
     * Emits `Proposed`.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Democracy.propose') === 'db924825c9fd40cb04a839b510db55dcdd425c7b06116ccd22d4834d1201e8db'
    }

    /**
     * Propose a sensitive action to be taken.
     * 
     * The dispatch origin of this call must be _Signed_ and the sender must
     * have funds to cover the deposit.
     * 
     * - `proposal_hash`: The hash of the proposal preimage.
     * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
     * 
     * Emits `Proposed`.
     */
    get asV968(): {proposal: v968.Bounded, value: bigint} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyReapPreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.reap_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove an expired proposal preimage and collect the deposit.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `proposal_hash`: The preimage hash of a proposal.
     *  - `proposal_length_upper_bound`: an upper bound on length of the proposal.
     *    Extrinsic is weighted according to this value with no refund.
     * 
     *  This will only work after `VotingPeriod` blocks from the time that the preimage was
     *  noted, if it's the same account doing it. If it's a different account, then it'll only
     *  work an additional `EnactmentPeriod` later.
     * 
     *  Emits `PreimageReaped`.
     * 
     *  Weight: `O(D)` where D is length of proposal.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.reap_preimage') === '23573ffc912e8a31889875352d3543e4538e2f3beb6a89ef86d10cf1cb8b7aca'
    }

    /**
     *  Remove an expired proposal preimage and collect the deposit.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `proposal_hash`: The preimage hash of a proposal.
     *  - `proposal_length_upper_bound`: an upper bound on length of the proposal.
     *    Extrinsic is weighted according to this value with no refund.
     * 
     *  This will only work after `VotingPeriod` blocks from the time that the preimage was
     *  noted, if it's the same account doing it. If it's a different account, then it'll only
     *  work an additional `EnactmentPeriod` later.
     * 
     *  Emits `PreimageReaped`.
     * 
     *  Weight: `O(D)` where D is length of proposal.
     */
    get asV803(): {proposalHash: Uint8Array, proposalLenUpperBound: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyRemoveOtherVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.remove_other_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a vote for a referendum.
     * 
     *  If the `target` is equal to the signer, then this function is exactly equivalent to
     *  `remove_vote`. If not equal to the signer, then the vote must have expired,
     *  either because the referendum was cancelled, because the voter lost the referendum or
     *  because the conviction period is over.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `target`: The account of the vote to be removed; this account must have voted for
     *    referendum `index`.
     *  - `index`: The index of referendum of the vote to be removed.
     * 
     *  Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *    Weight is calculated for the maximum number of vote.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.remove_other_vote') === '57db819150acc73e380a9908a05d4f777cd3af825527d7ad88560426e1d0f652'
    }

    /**
     *  Remove a vote for a referendum.
     * 
     *  If the `target` is equal to the signer, then this function is exactly equivalent to
     *  `remove_vote`. If not equal to the signer, then the vote must have expired,
     *  either because the referendum was cancelled, because the voter lost the referendum or
     *  because the conviction period is over.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `target`: The account of the vote to be removed; this account must have voted for
     *    referendum `index`.
     *  - `index`: The index of referendum of the vote to be removed.
     * 
     *  Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *    Weight is calculated for the maximum number of vote.
     */
    get asV803(): {target: Uint8Array, index: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove a vote for a referendum.
     * 
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the referendum was cancelled, because the voter lost the referendum or
     * because the conviction period is over.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account of the vote to be removed; this account must have voted for
     *   referendum `index`.
     * - `index`: The index of referendum of the vote to be removed.
     * 
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Democracy.remove_other_vote') === 'aa27aa9ca79b071acb7c348d5debf4b8542cab46a065a81173a118cc67e763b9'
    }

    /**
     * Remove a vote for a referendum.
     * 
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the referendum was cancelled, because the voter lost the referendum or
     * because the conviction period is over.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account of the vote to be removed; this account must have voted for
     *   referendum `index`.
     * - `index`: The index of referendum of the vote to be removed.
     * 
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get asV968(): {target: v968.MultiAddress, index: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyRemoveVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.remove_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a vote for a referendum.
     * 
     *  If:
     *  - the referendum was cancelled, or
     *  - the referendum is ongoing, or
     *  - the referendum has ended such that
     *    - the vote of the account was in opposition to the result; or
     *    - there was no conviction to the account's vote; or
     *    - the account made a split vote
     *  ...then the vote is removed cleanly and a following call to `unlock` may result in more
     *  funds being available.
     * 
     *  If, however, the referendum has ended and:
     *  - it finished corresponding to the vote of the account, and
     *  - the account made a standard vote with conviction, and
     *  - the lock period of the conviction is not over
     *  ...then the lock will be aggregated into the overall account's lock, which may involve
     *  *overlocking* (where the two locks are combined into a single lock that is the maximum
     *  of both the amount locked and the time is it locked for).
     * 
     *  The dispatch origin of this call must be _Signed_, and the signer must have a vote
     *  registered for referendum `index`.
     * 
     *  - `index`: The index of referendum of the vote to be removed.
     * 
     *  Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *    Weight is calculated for the maximum number of vote.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.remove_vote') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     *  Remove a vote for a referendum.
     * 
     *  If:
     *  - the referendum was cancelled, or
     *  - the referendum is ongoing, or
     *  - the referendum has ended such that
     *    - the vote of the account was in opposition to the result; or
     *    - there was no conviction to the account's vote; or
     *    - the account made a split vote
     *  ...then the vote is removed cleanly and a following call to `unlock` may result in more
     *  funds being available.
     * 
     *  If, however, the referendum has ended and:
     *  - it finished corresponding to the vote of the account, and
     *  - the account made a standard vote with conviction, and
     *  - the lock period of the conviction is not over
     *  ...then the lock will be aggregated into the overall account's lock, which may involve
     *  *overlocking* (where the two locks are combined into a single lock that is the maximum
     *  of both the amount locked and the time is it locked for).
     * 
     *  The dispatch origin of this call must be _Signed_, and the signer must have a vote
     *  registered for referendum `index`.
     * 
     *  - `index`: The index of referendum of the vote to be removed.
     * 
     *  Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *    Weight is calculated for the maximum number of vote.
     */
    get asV803(): {index: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracySecondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.second')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Signals agreement with a particular proposal.
     * 
     *  The dispatch origin of this call must be _Signed_ and the sender
     *  must have funds to cover the deposit, equal to the original deposit.
     * 
     *  - `proposal`: The index of the proposal to second.
     *  - `seconds_upper_bound`: an upper bound on the current number of seconds on this
     *    proposal. Extrinsic is weighted according to this value with no refund.
     * 
     *  Weight: `O(S)` where S is the number of seconds a proposal already has.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.second') === 'abe1357aae784eefd21f6999076deb6cfbc92fcb9e80c21e93a944ceb739423c'
    }

    /**
     *  Signals agreement with a particular proposal.
     * 
     *  The dispatch origin of this call must be _Signed_ and the sender
     *  must have funds to cover the deposit, equal to the original deposit.
     * 
     *  - `proposal`: The index of the proposal to second.
     *  - `seconds_upper_bound`: an upper bound on the current number of seconds on this
     *    proposal. Extrinsic is weighted according to this value with no refund.
     * 
     *  Weight: `O(S)` where S is the number of seconds a proposal already has.
     */
    get asV803(): {proposal: number, secondsUpperBound: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Signals agreement with a particular proposal.
     * 
     * The dispatch origin of this call must be _Signed_ and the sender
     * must have funds to cover the deposit, equal to the original deposit.
     * 
     * - `proposal`: The index of the proposal to second.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Democracy.second') === '7ac80a800d6686f21181e7b5b45c8949dc5b807bc6ec111188c7c6850a21b898'
    }

    /**
     * Signals agreement with a particular proposal.
     * 
     * The dispatch origin of this call must be _Signed_ and the sender
     * must have funds to cover the deposit, equal to the original deposit.
     * 
     * - `proposal`: The index of the proposal to second.
     */
    get asV968(): {proposal: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyUndelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.undelegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Undelegate the voting power of the sending account.
     * 
     *  Tokens may be unlocked following once an amount of time consistent with the lock period
     *  of the conviction with which the delegation was issued.
     * 
     *  The dispatch origin of this call must be _Signed_ and the signing account must be
     *  currently delegating.
     * 
     *  Emits `Undelegated`.
     * 
     *  Weight: `O(R)` where R is the number of referendums the voter delegating to has
     *    voted on. Weight is charged as if maximum votes.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.undelegate') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Undelegate the voting power of the sending account.
     * 
     *  Tokens may be unlocked following once an amount of time consistent with the lock period
     *  of the conviction with which the delegation was issued.
     * 
     *  The dispatch origin of this call must be _Signed_ and the signing account must be
     *  currently delegating.
     * 
     *  Emits `Undelegated`.
     * 
     *  Weight: `O(R)` where R is the number of referendums the voter delegating to has
     *    voted on. Weight is charged as if maximum votes.
     */
    get asV803(): null {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyUnlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.unlock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unlock tokens that have an expired lock.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `target`: The account to remove the lock on.
     * 
     *  Weight: `O(R)` with R number of vote of target.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.unlock') === '66d8abf7976ff596d8d614948b9d84cb24f0b898d88d24eb2cc035ae5e93c7b8'
    }

    /**
     *  Unlock tokens that have an expired lock.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `target`: The account to remove the lock on.
     * 
     *  Weight: `O(R)` with R number of vote of target.
     */
    get asV803(): {target: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Unlock tokens that have an expired lock.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account to remove the lock on.
     * 
     * Weight: `O(R)` with R number of vote of target.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Democracy.unlock') === 'b473bcbba83335e310f2f681307dcf6b16b8d79ec99a4fb2202c34bed7de3b65'
    }

    /**
     * Unlock tokens that have an expired lock.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account to remove the lock on.
     * 
     * Weight: `O(R)` with R number of vote of target.
     */
    get asV968(): {target: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyVetoExternalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.veto_external')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Veto and blacklist the external proposal hash.
     * 
     *  The dispatch origin of this call must be `VetoOrigin`.
     * 
     *  - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
     * 
     *  Emits `Vetoed`.
     * 
     *  Weight: `O(V + log(V))` where V is number of `existing vetoers`
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.veto_external') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Veto and blacklist the external proposal hash.
     * 
     *  The dispatch origin of this call must be `VetoOrigin`.
     * 
     *  - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
     * 
     *  Emits `Vetoed`.
     * 
     *  Weight: `O(V + log(V))` where V is number of `existing vetoers`
     */
    get asV803(): {proposalHash: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     *  otherwise it is a vote to keep the status quo.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `ref_index`: The index of the referendum to vote for.
     *  - `vote`: The vote configuration.
     * 
     *  Weight: `O(R)` where R is the number of referendums the voter has voted on.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Democracy.vote') === '6cdb35b5ffcb74405cdf222b0cc0bf7ad7025d59f676bea6712d77bcc9aff1db'
    }

    /**
     *  Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     *  otherwise it is a vote to keep the status quo.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `ref_index`: The index of the referendum to vote for.
     *  - `vote`: The vote configuration.
     * 
     *  Weight: `O(R)` where R is the number of referendums the voter has voted on.
     */
    get asV803(): {refIndex: number, vote: v803.AccountVote} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `ref_index`: The index of the referendum to vote for.
     * - `vote`: The vote configuration.
     * 
     * Weight: `O(R)` where R is the number of referendums the voter has voted on.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Democracy.vote') === '3936a4cb49f77280bd94142d4ec458afcf5cb8a5e5b0d602b1b1530928021e28'
    }

    /**
     * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `ref_index`: The index of the referendum to vote for.
     * - `vote`: The vote configuration.
     * 
     * Weight: `O(R)` where R is the number of referendums the voter has voted on.
     */
    get asV906(): {refIndex: number, vote: v906.AccountVote} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class DmpQueueServiceOverweightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'DmpQueue.service_overweight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Service a single overweight message.
     * 
     *  - `origin`: Must pass `ExecuteOverweightOrigin`.
     *  - `index`: The index of the overweight message to service.
     *  - `weight_limit`: The amount of weight that message execution may take.
     * 
     *  Errors:
     *  - `Unknown`: Message of `index` is unknown.
     *  - `OverLimit`: Message execution may use greater than `weight_limit`.
     * 
     *  Events:
     *  - `OverweightServiced`: On success.
     */
    get isV1(): boolean {
        return this._chain.getCallHash('DmpQueue.service_overweight') === 'f6b281f58290b6af96ac2dda36163d81223f37d0a8a100877e2526969a57d772'
    }

    /**
     *  Service a single overweight message.
     * 
     *  - `origin`: Must pass `ExecuteOverweightOrigin`.
     *  - `index`: The index of the overweight message to service.
     *  - `weight_limit`: The amount of weight that message execution may take.
     * 
     *  Errors:
     *  - `Unknown`: Message of `index` is unknown.
     *  - `OverLimit`: Message execution may use greater than `weight_limit`.
     * 
     *  Events:
     *  - `OverweightServiced`: On success.
     */
    get asV1(): {index: bigint, weightLimit: bigint} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Service a single overweight message.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('DmpQueue.service_overweight') === '80fae8875bf513efc1e06b7dac547fccfc1e5fc45888cc8afd9b43812cf51bf5'
    }

    /**
     * Service a single overweight message.
     */
    get asV972(): {index: bigint, weightLimit: v972.Weight} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingChargeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.charge')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.charge') === '2b1eee04b11ab8f5a7e03ba8801e6eaed476dbaa9cd014582deaf1235d0b0ebb'
    }

    get asV944(): {pid: number, rewards: [v944.CurrencyId, bigint][]} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Farming.charge') === '6b72c993f37312a3d0b03768ae08eb824c34201515a8f9acc96d8d21b5b73a02'
    }

    get asV956(): {pid: number, rewards: [v956.CurrencyId, bigint][]} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Farming.charge') === 'f303d190e72fe199cfe439422dd9eee6c44b3b051b2f2d3f008aee8fd2fa2ee4'
    }

    get asV962(): {pid: number, rewards: [v962.CurrencyId, bigint][]} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.claim')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.claim') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    get asV944(): {pid: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingClosePoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.close_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.close_pool') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    get asV944(): {pid: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingCreateFarmingPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.create_farming_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.create_farming_pool') === 'dd5a171d1dbe1b0885fea285a8a5f9a6af31b6960a40b4f052b6d96a9e56b166'
    }

    get asV944(): {tokensProportion: [v944.CurrencyId, number][], basicRewards: [v944.CurrencyId, bigint][], gaugeInit: ([v944.CurrencyId, number, [v944.CurrencyId, bigint][]] | undefined), minDepositToStart: bigint, afterBlockToStart: number, withdrawLimitTime: number, claimLimitTime: number, withdrawLimitCount: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Farming.create_farming_pool') === 'ff8736e63452b0075e130e3bc32995d83273da9382e66b35ddd6d8c98f440eff'
    }

    get asV956(): {tokensProportion: [v956.CurrencyId, number][], basicRewards: [v956.CurrencyId, bigint][], gaugeInit: ([v956.CurrencyId, number, [v956.CurrencyId, bigint][]] | undefined), minDepositToStart: bigint, afterBlockToStart: number, withdrawLimitTime: number, claimLimitTime: number, withdrawLimitCount: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Farming.create_farming_pool') === '96b901eb3baffc32bbdc44f9a89646c5258ffeb7bcd3745f458971fed16646ca'
    }

    get asV962(): {tokensProportion: [v962.CurrencyId, number][], basicRewards: [v962.CurrencyId, bigint][], gaugeInit: ([v962.CurrencyId, number, [v962.CurrencyId, bigint][]] | undefined), minDepositToStart: bigint, afterBlockToStart: number, withdrawLimitTime: number, claimLimitTime: number, withdrawLimitCount: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.deposit')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.deposit') === 'a28d0355269fc3b9488e0c49a6be3ee58a83f98e213877ce6c5a5db79848f72e'
    }

    get asV944(): {pid: number, addValue: bigint, gaugeInfo: ([bigint, number] | undefined)} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingEditPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.edit_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.edit_pool') === '63ec2cecec45600cbe262c869795afb1969855603b2097616160852acada3347'
    }

    get asV944(): {pid: number, basicRewards: ([v944.CurrencyId, bigint][] | undefined), withdrawLimitTime: (number | undefined), claimLimitTime: (number | undefined), gaugeBasicRewards: ([v944.CurrencyId, bigint][] | undefined)} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    get isV946(): boolean {
        return this._chain.getCallHash('Farming.edit_pool') === 'e21f0ff32c2a1d9ce248fdfd94e5f7e893aa9e9be63bebd9b60cf5006cee4fc8'
    }

    get asV946(): {pid: number, basicRewards: ([v946.CurrencyId, bigint][] | undefined), withdrawLimitTime: (number | undefined), claimLimitTime: (number | undefined), gaugeBasicRewards: ([v946.CurrencyId, bigint][] | undefined), withdrawLimitCount: (number | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Farming.edit_pool') === '7580d9acb3b5df38494520c2e8ef23fc39eed3bc0301144ea13c76225dfbe62b'
    }

    get asV956(): {pid: number, basicRewards: ([v956.CurrencyId, bigint][] | undefined), withdrawLimitTime: (number | undefined), claimLimitTime: (number | undefined), gaugeBasicRewards: ([v956.CurrencyId, bigint][] | undefined), withdrawLimitCount: (number | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Farming.edit_pool') === 'bb6e85b06fbee0dd3676634ca1e3597a1dd49ce1a10d2c2e94717fbf0a4a2a4f'
    }

    get asV962(): {pid: number, basicRewards: ([v962.CurrencyId, bigint][] | undefined), withdrawLimitTime: (number | undefined), claimLimitTime: (number | undefined), gaugeBasicRewards: ([v962.CurrencyId, bigint][] | undefined), withdrawLimitCount: (number | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingForceGaugeClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.force_gauge_claim')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.force_gauge_claim') === '5fc91e49a454b9b911770c486bb364158255e35bb8ac14e2cd8df4b39cf2ba51'
    }

    get asV944(): {gid: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingForceRetirePoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.force_retire_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.force_retire_pool') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    get asV944(): {pid: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingGaugeWithdrawCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.gauge_withdraw')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.gauge_withdraw') === '5fc91e49a454b9b911770c486bb364158255e35bb8ac14e2cd8df4b39cf2ba51'
    }

    get asV944(): {gid: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingKillPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.kill_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.kill_pool') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    get asV944(): {pid: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingResetPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.reset_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.reset_pool') === 'c222bdc45308a6cefc86faea4042e8b713b883dc3e79270f07e0e88efd90d57f'
    }

    get asV944(): {pid: number, basicRewards: ([v944.CurrencyId, bigint][] | undefined), minDepositToStart: (bigint | undefined), afterBlockToStart: (number | undefined), withdrawLimitTime: (number | undefined), claimLimitTime: (number | undefined), withdrawLimitCount: (number | undefined), gaugeInit: ([v944.CurrencyId, number, [v944.CurrencyId, bigint][]] | undefined)} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Farming.reset_pool') === '11eb590f3ce6ed7c501479b4f9c6549ec1b73fe86226e44a7a2b0af2f429b757'
    }

    get asV956(): {pid: number, basicRewards: ([v956.CurrencyId, bigint][] | undefined), minDepositToStart: (bigint | undefined), afterBlockToStart: (number | undefined), withdrawLimitTime: (number | undefined), claimLimitTime: (number | undefined), withdrawLimitCount: (number | undefined), gaugeInit: ([v956.CurrencyId, number, [v956.CurrencyId, bigint][]] | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Farming.reset_pool') === 'eaac6c1c6dc56e40f38bb82d59a3fb70aa0764e5245f33217f3b52b73a3778fd'
    }

    get asV962(): {pid: number, basicRewards: ([v962.CurrencyId, bigint][] | undefined), minDepositToStart: (bigint | undefined), afterBlockToStart: (number | undefined), withdrawLimitTime: (number | undefined), claimLimitTime: (number | undefined), withdrawLimitCount: (number | undefined), gaugeInit: ([v962.CurrencyId, number, [v962.CurrencyId, bigint][]] | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingSetRetireLimitCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.set_retire_limit')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.set_retire_limit') === 'f707ff742083978d0b1f391a9771c28219f5e35ce5ba83507482cd04e92d916b'
    }

    get asV944(): {limit: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingWithdrawCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.withdraw')
        this._chain = ctx._chain
        this.call = call
    }

    get isV944(): boolean {
        return this._chain.getCallHash('Farming.withdraw') === '454abb679e1a2e79f4013724692d660b046b3f75254bd431a5bc3bea639b0900'
    }

    get asV944(): {pid: number, removeValue: (bigint | undefined)} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }
}

export class FarmingWithdrawClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Farming.withdraw_claim')
        this._chain = ctx._chain
        this.call = call
    }

    get isV948(): boolean {
        return this._chain.getCallHash('Farming.withdraw_claim') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    get asV948(): {pid: number} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }
}

export class FeeShareCreateDistributionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FeeShare.create_distribution')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('FeeShare.create_distribution') === 'a6549af2e240623c0b90966b341d9b15e6a44f468409fe2a590f6f1d0e3ff81f'
    }

    get asV962(): {tokenType: v962.CurrencyId[], tokensProportion: [Uint8Array, number][], ifAuto: boolean} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class FeeShareDeleteDistributionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FeeShare.delete_distribution')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('FeeShare.delete_distribution') === 'cc8ca4348d096f4a581f247e86d25d61a1848c1213f4daf4208bd619d6ea3b9c'
    }

    get asV962(): {distributionId: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class FeeShareEditDistributionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FeeShare.edit_distribution')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('FeeShare.edit_distribution') === 'acd5e840205584d0394626aeb0dbb3782a6f2bc8031368b443e1a3a57825aa7e'
    }

    get asV962(): {distributionId: number, tokenType: (v962.CurrencyId[] | undefined), tokensProportion: ([Uint8Array, number][] | undefined), ifAuto: (boolean | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class FeeShareExecuteDistributeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FeeShare.execute_distribute')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('FeeShare.execute_distribute') === 'cc8ca4348d096f4a581f247e86d25d61a1848c1213f4daf4208bd619d6ea3b9c'
    }

    get asV962(): {distributionId: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class FeeShareSetEraLengthCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FeeShare.set_era_length')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('FeeShare.set_era_length') === '53d96f652b53e38e3f01de5d96f525851439a23f1369af7229e4830e74b6dfc0'
    }

    get asV962(): {eraLength: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class FlexibleFeeSetUserFeeChargeOrderCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FlexibleFee.set_user_fee_charge_order')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set user fee charge assets order.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('FlexibleFee.set_user_fee_charge_order') === '88a1061237ddb2afd47388542f11a30221fa1192bc758dcfec9dc2de5f8332f9'
    }

    /**
     *  Set user fee charge assets order.
     */
    get asV803(): {assetOrderListVec: (v803.CurrencyId[] | undefined)} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set user fee charge assets order.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('FlexibleFee.set_user_fee_charge_order') === 'b527202106a89f8ba3aaf066a7bcbd872270ba5dae01cbc433f3509e892351cb'
    }

    /**
     * Set user fee charge assets order.
     */
    get asV906(): {assetOrderListVec: (v906.CurrencyId[] | undefined)} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set user fee charge assets order.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('FlexibleFee.set_user_fee_charge_order') === '593938aa8f53182e65e52c86ae0a11279b5e7ea7ff29dfd3b7c5030c2c4fa8db'
    }

    /**
     * Set user fee charge assets order.
     */
    get asV916(): {assetOrderListVec: (v916.CurrencyId[] | undefined)} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set user fee charge assets order.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('FlexibleFee.set_user_fee_charge_order') === '28979afa5f94887508783108902cfe3d98d2c9098425e5dedcc52d488d2ec311'
    }

    /**
     * Set user fee charge assets order.
     */
    get asV920(): {assetOrderListVec: (v920.CurrencyId[] | undefined)} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set user fee charge assets order.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('FlexibleFee.set_user_fee_charge_order') === '4babb7f66b86a295b441641375bca03bbe89cc6adaf7498a6eded8162b3ef943'
    }

    /**
     * Set user fee charge assets order.
     */
    get asV932(): {assetOrderListVec: (v932.CurrencyId[] | undefined)} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set user fee charge assets order.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('FlexibleFee.set_user_fee_charge_order') === 'dda19b4af543cb44e5913184d01b2b50d6d26eee64e8d54358073964b9d9b6aa'
    }

    /**
     * Set user fee charge assets order.
     */
    get asV956(): {assetOrderListVec: (v956.CurrencyId[] | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set user fee charge assets order.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('FlexibleFee.set_user_fee_charge_order') === 'ad45861cf893b4ee32a286e2a6e99f039d612e11295855ed8f3ff79963fce1fc'
    }

    /**
     * Set user fee charge assets order.
     */
    get asV962(): {assetOrderListVec: (v962.CurrencyId[] | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityAddRegistrarCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.add_registrar')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add a registrar to the system.
     * 
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     * 
     * - `account`: the account of the registrar.
     * 
     * Emits `RegistrarAdded` if successful.
     * 
     * # <weight>
     * - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
     * - One storage mutation (codec `O(R)`).
     * - One event.
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.add_registrar') === '7fb7672b764b0a4f0c4910fddefec0709628843df7ad0073a97eede13c53ca92'
    }

    /**
     * Add a registrar to the system.
     * 
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     * 
     * - `account`: the account of the registrar.
     * 
     * Emits `RegistrarAdded` if successful.
     * 
     * # <weight>
     * - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
     * - One storage mutation (codec `O(R)`).
     * - One event.
     * # </weight>
     */
    get asV908(): {account: Uint8Array} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a registrar to the system.
     * 
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     * 
     * - `account`: the account of the registrar.
     * 
     * Emits `RegistrarAdded` if successful.
     * 
     * # <weight>
     * - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
     * - One storage mutation (codec `O(R)`).
     * - One event.
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Identity.add_registrar') === 'e353992d04f5d236d5d55134120a063ffe366c5be1470e25ba5281ec18acc4d2'
    }

    /**
     * Add a registrar to the system.
     * 
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     * 
     * - `account`: the account of the registrar.
     * 
     * Emits `RegistrarAdded` if successful.
     * 
     * # <weight>
     * - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
     * - One storage mutation (codec `O(R)`).
     * - One event.
     * # </weight>
     */
    get asV968(): {account: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityAddSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.add_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add the given account to the sender's subs.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.add_sub') === 'ef8fb13f5dc864a3db268a8f01b166d2deee87052a98309538fe8961be9020a9'
    }

    /**
     * Add the given account to the sender's subs.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get asV908(): {sub: v908.MultiAddress, data: v908.Data} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityCancelRequestCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.cancel_request')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel a previous request.
     * 
     * Payment: A previously reserved deposit is returned on success.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     * 
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     * 
     * Emits `JudgementUnrequested` if successful.
     * 
     * # <weight>
     * - `O(R + X)`.
     * - One balance-reserve operation.
     * - One storage mutation `O(R + X)`.
     * - One event
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.cancel_request') === '89d659d6a17ba36d0dfc7c90a7f043581d7fe980043895169d7dda1416ff7e5b'
    }

    /**
     * Cancel a previous request.
     * 
     * Payment: A previously reserved deposit is returned on success.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     * 
     * - `reg_index`: The index of the registrar whose judgement is no longer requested.
     * 
     * Emits `JudgementUnrequested` if successful.
     * 
     * # <weight>
     * - `O(R + X)`.
     * - One balance-reserve operation.
     * - One storage mutation `O(R + X)`.
     * - One event
     * # </weight>
     */
    get asV908(): {regIndex: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityClearIdentityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.clear_identity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     * 
     * Payment: All reserved balances on the account are returned.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     * 
     * Emits `IdentityCleared` if successful.
     * 
     * # <weight>
     * - `O(R + S + X)`
     *   - where `R` registrar-count (governance-bounded).
     *   - where `S` subs-count (hard- and deposit-bounded).
     *   - where `X` additional-field-count (deposit-bounded and code-bounded).
     * - One balance-unreserve operation.
     * - `2` storage reads and `S + 2` storage deletions.
     * - One event.
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.clear_identity') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Clear an account's identity info and all sub-accounts and return all deposits.
     * 
     * Payment: All reserved balances on the account are returned.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     * 
     * Emits `IdentityCleared` if successful.
     * 
     * # <weight>
     * - `O(R + S + X)`
     *   - where `R` registrar-count (governance-bounded).
     *   - where `S` subs-count (hard- and deposit-bounded).
     *   - where `X` additional-field-count (deposit-bounded and code-bounded).
     * - One balance-unreserve operation.
     * - `2` storage reads and `S + 2` storage deletions.
     * - One event.
     * # </weight>
     */
    get asV908(): null {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityKillIdentityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.kill_identity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     * 
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     * 
     * The dispatch origin for this call must match `T::ForceOrigin`.
     * 
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * 
     * Emits `IdentityKilled` if successful.
     * 
     * # <weight>
     * - `O(R + S + X)`.
     * - One balance-reserve operation.
     * - `S + 2` storage mutations.
     * - One event.
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.kill_identity') === 'b473bcbba83335e310f2f681307dcf6b16b8d79ec99a4fb2202c34bed7de3b65'
    }

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     * 
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     * 
     * The dispatch origin for this call must match `T::ForceOrigin`.
     * 
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * 
     * Emits `IdentityKilled` if successful.
     * 
     * # <weight>
     * - `O(R + S + X)`.
     * - One balance-reserve operation.
     * - `S + 2` storage mutations.
     * - One event.
     * # </weight>
     */
    get asV908(): {target: v908.MultiAddress} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityProvideJudgementCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.provide_judgement')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Provide a judgement for an account's identity.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     * 
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * 
     * Emits `JudgementGiven` if successful.
     * 
     * # <weight>
     * - `O(R + X)`.
     * - One balance-transfer operation.
     * - Up to one account-lookup operation.
     * - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     * - One event.
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.provide_judgement') === 'abdb42b954610658025900cff996632ccf91d9ab5409152108d45ed12cca332b'
    }

    /**
     * Provide a judgement for an account's identity.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     * 
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * 
     * Emits `JudgementGiven` if successful.
     * 
     * # <weight>
     * - `O(R + X)`.
     * - One balance-transfer operation.
     * - Up to one account-lookup operation.
     * - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     * - One event.
     * # </weight>
     */
    get asV908(): {regIndex: number, target: v908.MultiAddress, judgement: v908.Judgement} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Provide a judgement for an account's identity.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     * 
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided.
     * 
     * Emits `JudgementGiven` if successful.
     * 
     * # <weight>
     * - `O(R + X)`.
     * - One balance-transfer operation.
     * - Up to one account-lookup operation.
     * - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     * - One event.
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Identity.provide_judgement') === 'c007729772966e732abd90ba68fc739fbdae7781f8862f6e45ad593cd34aed90'
    }

    /**
     * Provide a judgement for an account's identity.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     * 
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided.
     * 
     * Emits `JudgementGiven` if successful.
     * 
     * # <weight>
     * - `O(R + X)`.
     * - One balance-transfer operation.
     * - Up to one account-lookup operation.
     * - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     * - One event.
     * # </weight>
     */
    get asV968(): {regIndex: number, target: v968.MultiAddress, judgement: v968.Judgement, identity: Uint8Array} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityQuitSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.quit_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the sender as a sub-account.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     * 
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.quit_sub') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Remove the sender as a sub-account.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender (*not* the original depositor).
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * super-identity.
     * 
     * NOTE: This should not normally be used, but is provided in the case that the non-
     * controller of an account is maliciously registered as a sub-account.
     */
    get asV908(): null {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityRemoveSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.remove_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the given account from the sender's subs.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.remove_sub') === 'da8ee0ac4ebb51ed9fe85fbeb08186e79fab7cd448e7811d7ec80b60406fcee5'
    }

    /**
     * Remove the given account from the sender's subs.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get asV908(): {sub: v908.MultiAddress} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityRenameSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.rename_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Alter the associated name of the given sub-account.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.rename_sub') === 'ef8fb13f5dc864a3db268a8f01b166d2deee87052a98309538fe8961be9020a9'
    }

    /**
     * Alter the associated name of the given sub-account.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get asV908(): {sub: v908.MultiAddress, data: v908.Data} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityRequestJudgementCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.request_judgement')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Request a judgement from a registrar.
     * 
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     * 
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     * 
     * ```nocompile
     * Self::registrars().get(reg_index).unwrap().fee
     * ```
     * 
     * Emits `JudgementRequested` if successful.
     * 
     * # <weight>
     * - `O(R + X)`.
     * - One balance-reserve operation.
     * - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.
     * - One event.
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.request_judgement') === 'c6336282cbe5b8ccf3769cc13c92f532be2499335e3d52ebf566a888e92b5b7c'
    }

    /**
     * Request a judgement from a registrar.
     * 
     * Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     * given.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a
     * registered identity.
     * 
     * - `reg_index`: The index of the registrar whose judgement is requested.
     * - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     * 
     * ```nocompile
     * Self::registrars().get(reg_index).unwrap().fee
     * ```
     * 
     * Emits `JudgementRequested` if successful.
     * 
     * # <weight>
     * - `O(R + X)`.
     * - One balance-reserve operation.
     * - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.
     * - One event.
     * # </weight>
     */
    get asV908(): {regIndex: number, maxFee: bigint} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetAccountIdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_account_id')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Change the account associated with a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     * 
     * # <weight>
     * - `O(R)`.
     * - One storage mutation `O(R)`.
     * - Benchmark: 8.823 + R * 0.32 µs (min squares analysis)
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.set_account_id') === 'a333bb3ce3e314d48fcf93f14155097760db6249022181f1eb923c1343af6813'
    }

    /**
     * Change the account associated with a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     * 
     * # <weight>
     * - `O(R)`.
     * - One storage mutation `O(R)`.
     * - Benchmark: 8.823 + R * 0.32 µs (min squares analysis)
     * # </weight>
     */
    get asV908(): {index: number, new: Uint8Array} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Change the account associated with a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     * 
     * # <weight>
     * - `O(R)`.
     * - One storage mutation `O(R)`.
     * - Benchmark: 8.823 + R * 0.32 µs (min squares analysis)
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Identity.set_account_id') === 'c45757fa1a730c3232b2913a0ad261360f9647ab28a639d53a62b68f7bdde40e'
    }

    /**
     * Change the account associated with a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     * 
     * # <weight>
     * - `O(R)`.
     * - One storage mutation `O(R)`.
     * - Benchmark: 8.823 + R * 0.32 µs (min squares analysis)
     * # </weight>
     */
    get asV968(): {index: number, new: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the fee required for a judgement to be requested from a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     * 
     * # <weight>
     * - `O(R)`.
     * - One storage mutation `O(R)`.
     * - Benchmark: 7.315 + R * 0.329 µs (min squares analysis)
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.set_fee') === '6418458414c3cef3d5c80c88232d781e76733c675303b2937b9cd30ae58d0fe4'
    }

    /**
     * Set the fee required for a judgement to be requested from a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fee`: the new fee.
     * 
     * # <weight>
     * - `O(R)`.
     * - One storage mutation `O(R)`.
     * - Benchmark: 7.315 + R * 0.329 µs (min squares analysis)
     * # </weight>
     */
    get asV908(): {index: number, fee: bigint} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetFieldsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_fields')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the field information for a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     * 
     * # <weight>
     * - `O(R)`.
     * - One storage mutation `O(R)`.
     * - Benchmark: 7.464 + R * 0.325 µs (min squares analysis)
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.set_fields') === 'b2c8998acd304e28e4f4a78e6a07f5bf7caf587532734dbd94b85c01a31c3e13'
    }

    /**
     * Set the field information for a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `fields`: the fields that the registrar concerns themselves with.
     * 
     * # <weight>
     * - `O(R)`.
     * - One storage mutation `O(R)`.
     * - Benchmark: 7.464 + R * 0.325 µs (min squares analysis)
     * # </weight>
     */
    get asV908(): {index: number, fields: bigint} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetIdentityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_identity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set an account's identity information and reserve the appropriate deposit.
     * 
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `info`: The identity information.
     * 
     * Emits `IdentitySet` if successful.
     * 
     * # <weight>
     * - `O(X + X' + R)`
     *   - where `X` additional-field-count (deposit-bounded and code-bounded)
     *   - where `R` judgements-count (registrar-count-bounded)
     * - One balance reserve operation.
     * - One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`).
     * - One event.
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.set_identity') === 'ab457704fd8cda5fee32e84ab7782778f4117cd54400c364cf7597eee5bc60ca'
    }

    /**
     * Set an account's identity information and reserve the appropriate deposit.
     * 
     * If the account already has identity information, the deposit is taken as part payment
     * for the new deposit.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `info`: The identity information.
     * 
     * Emits `IdentitySet` if successful.
     * 
     * # <weight>
     * - `O(X + X' + R)`
     *   - where `X` additional-field-count (deposit-bounded and code-bounded)
     *   - where `R` judgements-count (registrar-count-bounded)
     * - One balance reserve operation.
     * - One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`).
     * - One event.
     * # </weight>
     */
    get asV908(): {info: v908.IdentityInfo} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetSubsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_subs')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the sub-accounts of the sender.
     * 
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     * 
     * - `subs`: The identity's (new) sub-accounts.
     * 
     * # <weight>
     * - `O(P + S)`
     *   - where `P` old-subs-count (hard- and deposit-bounded).
     *   - where `S` subs-count (hard- and deposit-bounded).
     * - At most one balance operations.
     * - DB:
     *   - `P + S` storage mutations (codec complexity `O(1)`)
     *   - One storage read (codec complexity `O(P)`).
     *   - One storage write (codec complexity `O(S)`).
     *   - One storage-exists (`IdentityOf::contains_key`).
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Identity.set_subs') === 'f156a100857e71b9e1eab839801795e8569b63b49f6c30333c5bf12811cbbe73'
    }

    /**
     * Set the sub-accounts of the sender.
     * 
     * Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     * and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * identity.
     * 
     * - `subs`: The identity's (new) sub-accounts.
     * 
     * # <weight>
     * - `O(P + S)`
     *   - where `P` old-subs-count (hard- and deposit-bounded).
     *   - where `S` subs-count (hard- and deposit-bounded).
     * - At most one balance operations.
     * - DB:
     *   - `P + S` storage mutations (codec complexity `O(1)`)
     *   - One storage read (codec complexity `O(P)`).
     *   - One storage write (codec complexity `O(S)`).
     *   - One storage-exists (`IdentityOf::contains_key`).
     * # </weight>
     */
    get asV908(): {subs: [Uint8Array, v908.Data][]} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class IndicesClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Indices.claim')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Assign an previously unassigned index.
     * 
     *  Payment: `Deposit` is reserved from the sender account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `index`: the index to be claimed. This must not be in use.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - One reserve operation.
     *  - One event.
     *  -------------------
     *  - DB Weight: 1 Read/Write (Accounts)
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Indices.claim') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     *  Assign an previously unassigned index.
     * 
     *  Payment: `Deposit` is reserved from the sender account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `index`: the index to be claimed. This must not be in use.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - One reserve operation.
     *  - One event.
     *  -------------------
     *  - DB Weight: 1 Read/Write (Accounts)
     *  # </weight>
     */
    get asV1(): {index: number} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class IndicesForceTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Indices.force_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force an index to an account. This doesn't require a deposit. If the index is already
     *  held, then any deposit is reimbursed to its current owner.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `index`: the index to be (re-)assigned.
     *  - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     *  - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - Up to one reserve operation.
     *  - One event.
     *  -------------------
     *  - DB Weight:
     *     - Reads: Indices Accounts, System Account (original owner)
     *     - Writes: Indices Accounts, System Account (original owner)
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Indices.force_transfer') === 'c512e4f612c8bf235b4e49fd86b93323981d8379e84e47bd23e3718caf3df8b7'
    }

    /**
     *  Force an index to an account. This doesn't require a deposit. If the index is already
     *  held, then any deposit is reimbursed to its current owner.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `index`: the index to be (re-)assigned.
     *  - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     *  - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - Up to one reserve operation.
     *  - One event.
     *  -------------------
     *  - DB Weight:
     *     - Reads: Indices Accounts, System Account (original owner)
     *     - Writes: Indices Accounts, System Account (original owner)
     *  # </weight>
     */
    get asV1(): {new: Uint8Array, index: number, freeze: boolean} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force an index to an account. This doesn't require a deposit. If the index is already
     * held, then any deposit is reimbursed to its current owner.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `index`: the index to be (re-)assigned.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
     * 
     * Emits `IndexAssigned` if successful.
     * 
     * # <weight>
     * - `O(1)`.
     * - One storage mutation (codec `O(1)`).
     * - Up to one reserve operation.
     * - One event.
     * -------------------
     * - DB Weight:
     *    - Reads: Indices Accounts, System Account (original owner)
     *    - Writes: Indices Accounts, System Account (original owner)
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Indices.force_transfer') === '44e5b9cf2dfede316bbf49f466345fecadceacc23f10a36f5e9f0feaa9062f21'
    }

    /**
     * Force an index to an account. This doesn't require a deposit. If the index is already
     * held, then any deposit is reimbursed to its current owner.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `index`: the index to be (re-)assigned.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
     * 
     * Emits `IndexAssigned` if successful.
     * 
     * # <weight>
     * - `O(1)`.
     * - One storage mutation (codec `O(1)`).
     * - Up to one reserve operation.
     * - One event.
     * -------------------
     * - DB Weight:
     *    - Reads: Indices Accounts, System Account (original owner)
     *    - Writes: Indices Accounts, System Account (original owner)
     * # </weight>
     */
    get asV968(): {new: v968.MultiAddress, index: number, freeze: boolean} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class IndicesFreeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Indices.free')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Free up an index owned by the sender.
     * 
     *  Payment: Any previous deposit placed for the index is unreserved in the sender account.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must own the index.
     * 
     *  - `index`: the index to be freed. This must be owned by the sender.
     * 
     *  Emits `IndexFreed` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - One reserve operation.
     *  - One event.
     *  -------------------
     *  - DB Weight: 1 Read/Write (Accounts)
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Indices.free') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     *  Free up an index owned by the sender.
     * 
     *  Payment: Any previous deposit placed for the index is unreserved in the sender account.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must own the index.
     * 
     *  - `index`: the index to be freed. This must be owned by the sender.
     * 
     *  Emits `IndexFreed` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - One reserve operation.
     *  - One event.
     *  -------------------
     *  - DB Weight: 1 Read/Write (Accounts)
     *  # </weight>
     */
    get asV1(): {index: number} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class IndicesFreezeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Indices.freeze')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Freeze an index so it will always point to the sender account. This consumes the deposit.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must have a
     *  non-frozen account `index`.
     * 
     *  - `index`: the index to be frozen in place.
     * 
     *  Emits `IndexFrozen` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - Up to one slash operation.
     *  - One event.
     *  -------------------
     *  - DB Weight: 1 Read/Write (Accounts)
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Indices.freeze') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     *  Freeze an index so it will always point to the sender account. This consumes the deposit.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must have a
     *  non-frozen account `index`.
     * 
     *  - `index`: the index to be frozen in place.
     * 
     *  Emits `IndexFrozen` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - Up to one slash operation.
     *  - One event.
     *  -------------------
     *  - DB Weight: 1 Read/Write (Accounts)
     *  # </weight>
     */
    get asV1(): {index: number} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class IndicesTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Indices.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Assign an index already owned by the sender to another account. The balance reservation
     *  is effectively transferred to the new account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `index`: the index to be re-assigned. This must be owned by the sender.
     *  - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - One transfer operation.
     *  - One event.
     *  -------------------
     *  - DB Weight:
     *     - Reads: Indices Accounts, System Account (recipient)
     *     - Writes: Indices Accounts, System Account (recipient)
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Indices.transfer') === 'fb7b2e881b4e1febd039cce6ff2d158ae42a8e4ab080ad01ff5d71477b8a690a'
    }

    /**
     *  Assign an index already owned by the sender to another account. The balance reservation
     *  is effectively transferred to the new account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `index`: the index to be re-assigned. This must be owned by the sender.
     *  - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - One transfer operation.
     *  - One event.
     *  -------------------
     *  - DB Weight:
     *     - Reads: Indices Accounts, System Account (recipient)
     *     - Writes: Indices Accounts, System Account (recipient)
     *  # </weight>
     */
    get asV1(): {new: Uint8Array, index: number} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Assign an index already owned by the sender to another account. The balance reservation
     * is effectively transferred to the new account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `index`: the index to be re-assigned. This must be owned by the sender.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * 
     * Emits `IndexAssigned` if successful.
     * 
     * # <weight>
     * - `O(1)`.
     * - One storage mutation (codec `O(1)`).
     * - One transfer operation.
     * - One event.
     * -------------------
     * - DB Weight:
     *    - Reads: Indices Accounts, System Account (recipient)
     *    - Writes: Indices Accounts, System Account (recipient)
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Indices.transfer') === 'efa0fce0f66ffea78bf034e140a4c098f218691a0858684e2be328296cae5a02'
    }

    /**
     * Assign an index already owned by the sender to another account. The balance reservation
     * is effectively transferred to the new account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `index`: the index to be re-assigned. This must be owned by the sender.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * 
     * Emits `IndexAssigned` if successful.
     * 
     * # <weight>
     * - `O(1)`.
     * - One storage mutation (codec `O(1)`).
     * - One transfer operation.
     * - One event.
     * -------------------
     * - DB Weight:
     *    - Reads: Indices Accounts, System Account (recipient)
     *    - Writes: Indices Accounts, System Account (recipient)
     * # </weight>
     */
    get asV968(): {new: v968.MultiAddress, index: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class LighteningRedeemAddKsmToPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LighteningRedeem.add_ksm_to_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Anyone can add KSM to the pool.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('LighteningRedeem.add_ksm_to_pool') === 'c6bffb285656342c74f1e49c6ffb5bc2a7ec44b2241c8fa2b4c6e98b1947b9dd'
    }

    /**
     * Anyone can add KSM to the pool.
     */
    get asV906(): {tokenAmount: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class LighteningRedeemEditExchangePriceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LighteningRedeem.edit_exchange_price')
        this._chain = ctx._chain
        this.call = call
    }

    get isV906(): boolean {
        return this._chain.getCallHash('LighteningRedeem.edit_exchange_price') === '64832f8afc3828008d8202e05767b95963f7b2f6c6654616244e4d9dc4e4db25'
    }

    get asV906(): {price: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class LighteningRedeemEditReleasePerDayCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LighteningRedeem.edit_release_per_day')
        this._chain = ctx._chain
        this.call = call
    }

    get isV906(): boolean {
        return this._chain.getCallHash('LighteningRedeem.edit_release_per_day') === '43c63b8bb6170fb194684978b9626ac8f2c1e2509423d031805dbad4c6cc8d4e'
    }

    get asV906(): {amountPerDay: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class LighteningRedeemEditReleaseStartAndEndBlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LighteningRedeem.edit_release_start_and_end_block')
        this._chain = ctx._chain
        this.call = call
    }

    get isV906(): boolean {
        return this._chain.getCallHash('LighteningRedeem.edit_release_start_and_end_block') === 'b68424c1cbec8a0654cbfa4086d7af7e74eda05f54d5b4531ec32016c5ca2d4d'
    }

    get asV906(): {start: number, end: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class LighteningRedeemExchangeForKsmCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LighteningRedeem.exchange_for_ksm')
        this._chain = ctx._chain
        this.call = call
    }

    get isV906(): boolean {
        return this._chain.getCallHash('LighteningRedeem.exchange_for_ksm') === 'c6bffb285656342c74f1e49c6ffb5bc2a7ec44b2241c8fa2b4c6e98b1947b9dd'
    }

    get asV906(): {tokenAmount: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningCancelUnlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.cancel_unlock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Caller cancels the specific pending-unlock.
     * 
     * __NOTE__: The extrinsic will retire the pool, which is reached the end of life.
     * 
     * The conditions to cancel:
     * - The pool state is `PoolState::Ongoing`.
     * - There is a `pending-unlock` that is specific by the parameter `index`;
     */
    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMining.cancel_unlock') === 'ba7e6ac23d7c895a7ac670567b7659bc50b5d2b6c47d712b3fd6b02651fcfa1e'
    }

    /**
     * Caller cancels the specific pending-unlock.
     * 
     * __NOTE__: The extrinsic will retire the pool, which is reached the end of life.
     * 
     * The conditions to cancel:
     * - The pool state is `PoolState::Ongoing`.
     * - There is a `pending-unlock` that is specific by the parameter `index`;
     */
    get asV922(): {pid: number, index: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningChargeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.charge')
        this._chain = ctx._chain
        this.call = call
    }

    get isV901(): boolean {
        return this._chain.getCallHash('LiquidityMining.charge') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    get asV901(): {pid: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.claim')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  User claims the rewards from a liquidity-pool.
     * 
     *  The extrinsic will:
     *  - Try to retire the liquidity-pool which has reached the end of life.
     * 
     *  The conditions to claim:
     *  - User should have enough token deposited in the liquidity-pool;
     *  - The liquidity-pool should be in special states: `Ongoing`;
     */
    get isV901(): boolean {
        return this._chain.getCallHash('LiquidityMining.claim') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    /**
     *  User claims the rewards from a liquidity-pool.
     * 
     *  The extrinsic will:
     *  - Try to retire the liquidity-pool which has reached the end of life.
     * 
     *  The conditions to claim:
     *  - User should have enough token deposited in the liquidity-pool;
     *  - The liquidity-pool should be in special states: `Ongoing`;
     */
    get asV901(): {pid: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningCreateEbFarmingPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.create_eb_farming_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV901(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_eb_farming_pool') === '18b27f0f0ce9d4ec3ce711aab5293aadd746a2e108f324a4a8a39ef39a24dbcc'
    }

    get asV901(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v901.CurrencyId, bigint], optionRewards: [v901.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_eb_farming_pool') === 'e5859e0c720a6d79c83f8dfee9653746470ffe13afa519b74295e8bfbbb7e8f5'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get asV906(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v906.CurrencyId, bigint], optionRewards: [v906.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_eb_farming_pool') === 'a620efa2fc730d5016bff223463eef4831d5b11f73e53a6168a7efa11f0a5fff'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get asV916(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v916.CurrencyId, bigint], optionRewards: [v916.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_eb_farming_pool') === '8e029adee6d5241aea7fe5d48e0295a27ad81780c5e4f7fbf8e82ad1836b90c6'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get asV920(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v920.CurrencyId, bigint], optionRewards: [v920.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_eb_farming_pool') === 'ebde90da2d6e6937034e357ec993ebb678d4674194de79c431f67839f775b544'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get asV932(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v932.CurrencyId, bigint], optionRewards: [v932.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_eb_farming_pool') === '1e7d05e8e7cd077cc92cc2128767e2741d166bb7ac4afd1d5f8f1570cbb29b7d'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get asV956(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v956.CurrencyId, bigint], optionRewards: [v956.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_eb_farming_pool') === '09b6a5bd9afa7826aaf4e1e117e1df5cfa7a77826af6624b3037ebfb99f05081'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get asV962(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v962.CurrencyId, bigint], optionRewards: [v962.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningCreateFarmingPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.create_farming_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV901(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_farming_pool') === '18b27f0f0ce9d4ec3ce711aab5293aadd746a2e108f324a4a8a39ef39a24dbcc'
    }

    get asV901(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v901.CurrencyId, bigint], optionRewards: [v901.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_farming_pool') === 'e5859e0c720a6d79c83f8dfee9653746470ffe13afa519b74295e8bfbbb7e8f5'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV906(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v906.CurrencyId, bigint], optionRewards: [v906.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_farming_pool') === 'a620efa2fc730d5016bff223463eef4831d5b11f73e53a6168a7efa11f0a5fff'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV916(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v916.CurrencyId, bigint], optionRewards: [v916.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_farming_pool') === '8e029adee6d5241aea7fe5d48e0295a27ad81780c5e4f7fbf8e82ad1836b90c6'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV920(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v920.CurrencyId, bigint], optionRewards: [v920.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_farming_pool') === 'da2654a724a4e501ea63060046ca605263bd3fd6b533e1e09553f2d6ae4bf0aa'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV922(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v922.CurrencyId, bigint], optionRewards: [v922.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_farming_pool') === '99301497cc720731fcf36addcfd26c6655f92626707dcaab09abeb6f8a242784'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV932(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v932.CurrencyId, bigint], optionRewards: [v932.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_farming_pool') === 'a723699cbf64f88891a7624039978832af59cb3dff3e73043aad5dd725997a76'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV956(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v956.CurrencyId, bigint], optionRewards: [v956.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_farming_pool') === 'd15a6f3e2cee697e9a8dda1a001d3e56ddb316840be58f85cf775c8cb17587c8'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV962(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v962.CurrencyId, bigint], optionRewards: [v962.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningCreateMiningPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.create_mining_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV901(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_mining_pool') === '72b1dd1c4649ecdba9cd0e246b6e397d8fa22a17e81a6cd20a5876f93d9244c4'
    }

    get asV901(): {tradingPair: [v901.CurrencyId, v901.CurrencyId], mainReward: [v901.CurrencyId, bigint], optionRewards: [v901.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_mining_pool') === '229600a0b093394689edc4f869e9ccb1c92883a18c20f802638f0f129b649666'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV906(): {tradingPair: [v906.CurrencyId, v906.CurrencyId], mainReward: [v906.CurrencyId, bigint], optionRewards: [v906.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_mining_pool') === '965289856bc5786f7701f9a91460ec75f5fe7bf0306c5ed6ca1273d9a0b091c8'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV916(): {tradingPair: [v916.CurrencyId, v916.CurrencyId], mainReward: [v916.CurrencyId, bigint], optionRewards: [v916.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_mining_pool') === '3206c8a1b2b22854baa45c6d78fd4270216321dc08e2d26e3143e27d7313855c'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV920(): {tradingPair: [v920.CurrencyId, v920.CurrencyId], mainReward: [v920.CurrencyId, bigint], optionRewards: [v920.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_mining_pool') === '8cf15f44c2a16200055a1366f994b56e95ce47c0ea81ef52ee8011bf964c641b'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV922(): {tradingPair: [v922.CurrencyId, v922.CurrencyId], mainReward: [v922.CurrencyId, bigint], optionRewards: [v922.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_mining_pool') === '52b8bdc47be136eef76ec62d90f8efa01bd7d70086604f31af0a03f22f7dfb8a'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV932(): {tradingPair: [v932.CurrencyId, v932.CurrencyId], mainReward: [v932.CurrencyId, bigint], optionRewards: [v932.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_mining_pool') === 'e774d4eced0daf75b6f4b343190035c335c506edaff9caf806eec9462552f04a'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV956(): {tradingPair: [v956.CurrencyId, v956.CurrencyId], mainReward: [v956.CurrencyId, bigint], optionRewards: [v956.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_mining_pool') === 'a0a170a0dd80731f3e2f52b6479370bee0f58c8d6f0de84f81e79691b34fe1e5'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV962(): {tradingPair: [v962.CurrencyId, v962.CurrencyId], mainReward: [v962.CurrencyId, bigint], optionRewards: [v962.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningCreateSingleTokenPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.create_single_token_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV912(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_single_token_pool') === '7b5d4f94566d3e828ef561cb7c0f77cdba1d266c245fa50fbbd79a038c852cd5'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV912(): {token: v912.CurrencyId, mainReward: [v912.CurrencyId, bigint], optionRewards: [v912.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_single_token_pool') === '6ddbfd37270964cfb04816fb4218e307708178ec3c16ab25b8264bbe7419093a'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV916(): {token: v916.CurrencyId, mainReward: [v916.CurrencyId, bigint], optionRewards: [v916.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_single_token_pool') === 'c8ca5702867a70e81203d04b24c40e8359b5403786dd01c35ad3205d49161d1c'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV920(): {token: v920.CurrencyId, mainReward: [v920.CurrencyId, bigint], optionRewards: [v920.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_single_token_pool') === '5ca7a7a5d4a9ca93b2364cc797a12dbd22c960ba281aa34242947455bebab2b2'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV922(): {token: v922.CurrencyId, mainReward: [v922.CurrencyId, bigint], optionRewards: [v922.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_single_token_pool') === '662b6a6a3bc31ccfaf25f6decc4356b852a337d5aac7cdfa6dacf7fbc6c0e26d'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV932(): {token: v932.CurrencyId, mainReward: [v932.CurrencyId, bigint], optionRewards: [v932.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_single_token_pool') === 'ddcb4bc08a60ce208da58b7af141459211f164e3b02bfd104546c66d575c0c12'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV956(): {token: v956.CurrencyId, mainReward: [v956.CurrencyId, bigint], optionRewards: [v956.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('LiquidityMining.create_single_token_pool') === 'bbd132e8b73d947d25b0ae5e3b032f55092db719d7c143e3a9a9c968ab4963d6'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV962(): {token: v962.CurrencyId, mainReward: [v962.CurrencyId, bigint], optionRewards: [v962.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  User deposits some token to a liquidity-pool.
     * 
     *  The extrinsic will:
     *  - Try to retire the liquidity-pool which has reached the end of life.
     *  - Try to settle the rewards when the liquidity-pool in `Ongoing`.
     * 
     *  The conditions to deposit:
     *  - User should deposit enough(greater than `T::MinimumDeposit`) token to liquidity-pool;
     *  - The liquidity-pool should be in special state: `Charged`, `Ongoing`;
     */
    get isV901(): boolean {
        return this._chain.getCallHash('LiquidityMining.deposit') === 'f84769812825534404a6e577b634fc8471ea480180c5ec7f8a4634e6f411434e'
    }

    /**
     *  User deposits some token to a liquidity-pool.
     * 
     *  The extrinsic will:
     *  - Try to retire the liquidity-pool which has reached the end of life.
     *  - Try to settle the rewards when the liquidity-pool in `Ongoing`.
     * 
     *  The conditions to deposit:
     *  - User should deposit enough(greater than `T::MinimumDeposit`) token to liquidity-pool;
     *  - The liquidity-pool should be in special state: `Charged`, `Ongoing`;
     */
    get asV901(): {pid: number, value: bigint} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningEditPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.edit_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Edit the parameters of a liquidity-pool.
     * 
     * __NOTE__: Forbid editing the liquidity-pool which type is `PoolType::EBFarming`;
     */
    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMining.edit_pool') === '6b4cc95739a1f5ed3d0d30a39e05bda8ce7855c1e8a26a27720ddf4d7a92e713'
    }

    /**
     * Edit the parameters of a liquidity-pool.
     * 
     * __NOTE__: Forbid editing the liquidity-pool which type is `PoolType::EBFarming`;
     */
    get asV922(): {pid: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningForceRetirePoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.force_retire_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV901(): boolean {
        return this._chain.getCallHash('LiquidityMining.force_retire_pool') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    get asV901(): {pid: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningKillPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.kill_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV901(): boolean {
        return this._chain.getCallHash('LiquidityMining.kill_pool') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    get asV901(): {pid: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningLazyMigrationV200Call {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.lazy_migration_v2_0_0')
        this._chain = ctx._chain
        this.call = call
    }

    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMining.lazy_migration_v2_0_0') === '5b3185b96241abf14961366b08bfd5bd4d6f0384b55a4a8cb0afa0389bbc8799'
    }

    get asV922(): {maxNums: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningRedeemCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.redeem')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  User redeems some deposit from a liquidity-pool.
     *  The deposit in the liquidity-pool should be greater than `T::MinimumDeposit` when the
     *  liquidity-pool is on `Ongoing` state; So user may not be able to redeem completely
     *  until the liquidity-pool is on `Retire` state.
     * 
     *  The extrinsic will:
     *  - Try to retire the liquidity-pool which has reached the end of life.
     *  - Try to settle the rewards.
     *  - Try to unreserve the remaining rewards to the pool investor when the deposit in the
     *    liquidity-pool is clear.
     *  - Try to delete the liquidity-pool in which the deposit becomes zero.
     *  - Try to delete the deposit-data in which the deposit becomes zero.
     * 
     *  The condition to redeem:
     *  - User should have some deposit in the liquidity-pool;
     *  - The liquidity-pool should be in special state: `Ongoing`, `Retired`;
     * 
     *  NOTE: All deposit will be redeemed when the pool is being `Retired`, no matter the
     *  `value` is.
     */
    get isV901(): boolean {
        return this._chain.getCallHash('LiquidityMining.redeem') === 'f84769812825534404a6e577b634fc8471ea480180c5ec7f8a4634e6f411434e'
    }

    /**
     *  User redeems some deposit from a liquidity-pool.
     *  The deposit in the liquidity-pool should be greater than `T::MinimumDeposit` when the
     *  liquidity-pool is on `Ongoing` state; So user may not be able to redeem completely
     *  until the liquidity-pool is on `Retire` state.
     * 
     *  The extrinsic will:
     *  - Try to retire the liquidity-pool which has reached the end of life.
     *  - Try to settle the rewards.
     *  - Try to unreserve the remaining rewards to the pool investor when the deposit in the
     *    liquidity-pool is clear.
     *  - Try to delete the liquidity-pool in which the deposit becomes zero.
     *  - Try to delete the deposit-data in which the deposit becomes zero.
     * 
     *  The condition to redeem:
     *  - User should have some deposit in the liquidity-pool;
     *  - The liquidity-pool should be in special state: `Ongoing`, `Retired`;
     * 
     *  NOTE: All deposit will be redeemed when the pool is being `Retired`, no matter the
     *  `value` is.
     */
    get asV901(): {pid: number, value: bigint} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningRedeemAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.redeem_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  User redeems all deposit from a liquidity-pool.
     *  The deposit in the liquidity-pool should be greater than `T::MinimumDeposit` when the
     *  liquidity-pool is on `Ongoing` state; So user may not be able to redeem completely
     *  until the liquidity-pool is on `Retire` state.
     * 
     *  The extrinsic will:
     *  - Try to retire the liquidity-pool which has reached the end of life.
     *  - Try to settle the rewards.
     *  - Try to unreserve the remaining rewards to the pool investor when the deposit in the
     *    liquidity-pool is clear.
     *  - Try to delete the liquidity-pool in which the deposit becomes zero.
     *  - Try to delete the deposit-data in which the deposit becomes zero.
     * 
     *  The condition to redeem:
     *  - User should have some deposit in the liquidity-pool;
     *  - The liquidity-pool should be in special state: `Ongoing`, `Retired`;
     */
    get isV901(): boolean {
        return this._chain.getCallHash('LiquidityMining.redeem_all') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    /**
     *  User redeems all deposit from a liquidity-pool.
     *  The deposit in the liquidity-pool should be greater than `T::MinimumDeposit` when the
     *  liquidity-pool is on `Ongoing` state; So user may not be able to redeem completely
     *  until the liquidity-pool is on `Retire` state.
     * 
     *  The extrinsic will:
     *  - Try to retire the liquidity-pool which has reached the end of life.
     *  - Try to settle the rewards.
     *  - Try to unreserve the remaining rewards to the pool investor when the deposit in the
     *    liquidity-pool is clear.
     *  - Try to delete the liquidity-pool in which the deposit becomes zero.
     *  - Try to delete the deposit-data in which the deposit becomes zero.
     * 
     *  The condition to redeem:
     *  - User should have some deposit in the liquidity-pool;
     *  - The liquidity-pool should be in special state: `Ongoing`, `Retired`;
     */
    get asV901(): {pid: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningUnlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.unlock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Caller unlocks the locked deposit in the liquidity-pool.
     * 
     * __NOTE__: The extrinsic will retire the pool, which is reached the end of life.
     * 
     * The conditions to unlock:
     * - The pool type is not `PoolType::EBFarming`.
     * - There are pending-unlocks in the deposit_data.
     * - The current block-height exceeded the unlock-height;
     */
    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMining.unlock') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    /**
     * Caller unlocks the locked deposit in the liquidity-pool.
     * 
     * __NOTE__: The extrinsic will retire the pool, which is reached the end of life.
     * 
     * The conditions to unlock:
     * - The pool type is not `PoolType::EBFarming`.
     * - There are pending-unlocks in the deposit_data.
     * - The current block-height exceeded the unlock-height;
     */
    get asV922(): {pid: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningVolunteerToRedeemCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMining.volunteer_to_redeem')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Help someone to redeem the deposit whose deposited in a liquidity-pool.
     * 
     *  NOTE: The liquidity-pool should be in retired state.
     */
    get isV901(): boolean {
        return this._chain.getCallHash('LiquidityMining.volunteer_to_redeem') === '21e04532874dbc1d541215f001a15327a0d1b6f6e75b75713a186f80a58532b0'
    }

    /**
     *  Help someone to redeem the deposit whose deposited in a liquidity-pool.
     * 
     *  NOTE: The liquidity-pool should be in retired state.
     */
    get asV901(): {pid: number, account: (Uint8Array | undefined)} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotCancelUnlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.cancel_unlock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Caller cancels the specific pending-unlock.
     * 
     * __NOTE__: The extrinsic will retire the pool, which is reached the end of life.
     * 
     * The conditions to cancel:
     * - The pool state is `PoolState::Ongoing`.
     * - There is a `pending-unlock` that is specific by the parameter `index`;
     */
    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.cancel_unlock') === 'ba7e6ac23d7c895a7ac670567b7659bc50b5d2b6c47d712b3fd6b02651fcfa1e'
    }

    /**
     * Caller cancels the specific pending-unlock.
     * 
     * __NOTE__: The extrinsic will retire the pool, which is reached the end of life.
     * 
     * The conditions to cancel:
     * - The pool state is `PoolState::Ongoing`.
     * - There is a `pending-unlock` that is specific by the parameter `index`;
     */
    get asV922(): {pid: number, index: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotChargeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.charge')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer the rewards which are used to distribute to depositors to a liquidity-pool.
     * 
     * _NOTE_: The extrinsic is only applied to the liquidity-pool at `PoolState::UnCharged`;
     * 	When the extrinsic was executed successfully, the liquidity-pool would be at
     * 	`PoolState::Charged`.
     */
    get isV910(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.charge') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    /**
     * Transfer the rewards which are used to distribute to depositors to a liquidity-pool.
     * 
     * _NOTE_: The extrinsic is only applied to the liquidity-pool at `PoolState::UnCharged`;
     * 	When the extrinsic was executed successfully, the liquidity-pool would be at
     * 	`PoolState::Charged`.
     */
    get asV910(): {pid: number} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.claim')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Caller withdraw the unclaimed rewards owned by self from a pool.
     * 
     * __NOTE__: The extrinsic will retire the pool, which is reached the end of life.
     * 
     * The conditions to claim:
     * - There is enough deposit owned by the caller in the pool.
     * - The pool is at `PoolState::Ongoing`.
     */
    get isV910(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.claim') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    /**
     * Caller withdraw the unclaimed rewards owned by self from a pool.
     * 
     * __NOTE__: The extrinsic will retire the pool, which is reached the end of life.
     * 
     * The conditions to claim:
     * - There is enough deposit owned by the caller in the pool.
     * - The pool is at `PoolState::Ongoing`.
     */
    get asV910(): {pid: number} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotCreateEbFarmingPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.create_eb_farming_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get isV910(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_eb_farming_pool') === 'e5859e0c720a6d79c83f8dfee9653746470ffe13afa519b74295e8bfbbb7e8f5'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get asV910(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v910.CurrencyId, bigint], optionRewards: [v910.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_eb_farming_pool') === 'a620efa2fc730d5016bff223463eef4831d5b11f73e53a6168a7efa11f0a5fff'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get asV916(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v916.CurrencyId, bigint], optionRewards: [v916.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_eb_farming_pool') === '8e029adee6d5241aea7fe5d48e0295a27ad81780c5e4f7fbf8e82ad1836b90c6'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get asV920(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v920.CurrencyId, bigint], optionRewards: [v920.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_eb_farming_pool') === 'ebde90da2d6e6937034e357ec993ebb678d4674194de79c431f67839f775b544'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get asV932(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v932.CurrencyId, bigint], optionRewards: [v932.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_eb_farming_pool') === '1e7d05e8e7cd077cc92cc2128767e2741d166bb7ac4afd1d5f8f1570cbb29b7d'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get asV956(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v956.CurrencyId, bigint], optionRewards: [v956.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_eb_farming_pool') === '09b6a5bd9afa7826aaf4e1e117e1df5cfa7a77826af6624b3037ebfb99f05081'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts reserved
     * `vsToken` and reserved `vsBond` as deposit.
     */
    get asV962(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v962.CurrencyId, bigint], optionRewards: [v962.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotCreateFarmingPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.create_farming_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV910(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_farming_pool') === 'e5859e0c720a6d79c83f8dfee9653746470ffe13afa519b74295e8bfbbb7e8f5'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV910(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v910.CurrencyId, bigint], optionRewards: [v910.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_farming_pool') === 'a620efa2fc730d5016bff223463eef4831d5b11f73e53a6168a7efa11f0a5fff'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV916(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v916.CurrencyId, bigint], optionRewards: [v916.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_farming_pool') === '8e029adee6d5241aea7fe5d48e0295a27ad81780c5e4f7fbf8e82ad1836b90c6'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV920(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v920.CurrencyId, bigint], optionRewards: [v920.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_farming_pool') === 'da2654a724a4e501ea63060046ca605263bd3fd6b533e1e09553f2d6ae4bf0aa'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV922(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v922.CurrencyId, bigint], optionRewards: [v922.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_farming_pool') === '99301497cc720731fcf36addcfd26c6655f92626707dcaab09abeb6f8a242784'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV932(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v932.CurrencyId, bigint], optionRewards: [v932.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_farming_pool') === 'a723699cbf64f88891a7624039978832af59cb3dff3e73043aad5dd725997a76'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV956(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v956.CurrencyId, bigint], optionRewards: [v956.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_farming_pool') === 'd15a6f3e2cee697e9a8dda1a001d3e56ddb316840be58f85cf775c8cb17587c8'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Farming`, Only accepts free `vsToken`
     * and free `vsBond` as deposit.
     */
    get asV962(): {index: number, firstSlot: number, lastSlot: number, mainReward: [v962.CurrencyId, bigint], optionRewards: [v962.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotCreateMiningPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.create_mining_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV910(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_mining_pool') === '229600a0b093394689edc4f869e9ccb1c92883a18c20f802638f0f129b649666'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV910(): {tradingPair: [v910.CurrencyId, v910.CurrencyId], mainReward: [v910.CurrencyId, bigint], optionRewards: [v910.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_mining_pool') === '965289856bc5786f7701f9a91460ec75f5fe7bf0306c5ed6ca1273d9a0b091c8'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV916(): {tradingPair: [v916.CurrencyId, v916.CurrencyId], mainReward: [v916.CurrencyId, bigint], optionRewards: [v916.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_mining_pool') === '3206c8a1b2b22854baa45c6d78fd4270216321dc08e2d26e3143e27d7313855c'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV920(): {tradingPair: [v920.CurrencyId, v920.CurrencyId], mainReward: [v920.CurrencyId, bigint], optionRewards: [v920.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_mining_pool') === '8cf15f44c2a16200055a1366f994b56e95ce47c0ea81ef52ee8011bf964c641b'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV922(): {tradingPair: [v922.CurrencyId, v922.CurrencyId], mainReward: [v922.CurrencyId, bigint], optionRewards: [v922.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_mining_pool') === '52b8bdc47be136eef76ec62d90f8efa01bd7d70086604f31af0a03f22f7dfb8a'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV932(): {tradingPair: [v932.CurrencyId, v932.CurrencyId], mainReward: [v932.CurrencyId, bigint], optionRewards: [v932.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_mining_pool') === 'e774d4eced0daf75b6f4b343190035c335c506edaff9caf806eec9462552f04a'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV956(): {tradingPair: [v956.CurrencyId, v956.CurrencyId], mainReward: [v956.CurrencyId, bigint], optionRewards: [v956.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_mining_pool') === 'a0a170a0dd80731f3e2f52b6479370bee0f58c8d6f0de84f81e79691b34fe1e5'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::Mining`, Only accepts `lpToken` as
     * deposit.
     */
    get asV962(): {tradingPair: [v962.CurrencyId, v962.CurrencyId], mainReward: [v962.CurrencyId, bigint], optionRewards: [v962.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotCreateSingleTokenPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.create_single_token_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV912(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_single_token_pool') === '7b5d4f94566d3e828ef561cb7c0f77cdba1d266c245fa50fbbd79a038c852cd5'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV912(): {token: v912.CurrencyId, mainReward: [v912.CurrencyId, bigint], optionRewards: [v912.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_single_token_pool') === '6ddbfd37270964cfb04816fb4218e307708178ec3c16ab25b8264bbe7419093a'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV916(): {token: v916.CurrencyId, mainReward: [v916.CurrencyId, bigint], optionRewards: [v916.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_single_token_pool') === 'c8ca5702867a70e81203d04b24c40e8359b5403786dd01c35ad3205d49161d1c'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV920(): {token: v920.CurrencyId, mainReward: [v920.CurrencyId, bigint], optionRewards: [v920.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_single_token_pool') === '5ca7a7a5d4a9ca93b2364cc797a12dbd22c960ba281aa34242947455bebab2b2'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV922(): {token: v922.CurrencyId, mainReward: [v922.CurrencyId, bigint], optionRewards: [v922.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_single_token_pool') === '662b6a6a3bc31ccfaf25f6decc4356b852a337d5aac7cdfa6dacf7fbc6c0e26d'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV932(): {token: v932.CurrencyId, mainReward: [v932.CurrencyId, bigint], optionRewards: [v932.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_single_token_pool') === 'ddcb4bc08a60ce208da58b7af141459211f164e3b02bfd104546c66d575c0c12'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV956(): {token: v956.CurrencyId, mainReward: [v956.CurrencyId, bigint], optionRewards: [v956.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.create_single_token_pool') === 'bbd132e8b73d947d25b0ae5e3b032f55092db719d7c143e3a9a9c968ab4963d6'
    }

    /**
     * Create a liquidity-pool which type is `PoolType::SingleToken`, accepts any token as
     * deposit.
     */
    get asV962(): {token: v962.CurrencyId, mainReward: [v962.CurrencyId, bigint], optionRewards: [v962.CurrencyId, bigint][], duration: number, minDepositToStart: bigint, afterBlockToStart: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Caller deposits some token to a liquidity-pool.
     * 
     * __NOTE__: The unclaimed rewards of caller will be withdrawn automatically if there has.
     * 
     * The conditions to deposit:
     * - The deposit caller was contributed to the pool should be bigger than
     *   `T::MinimumDeposit`;
     * - The pool is at `PoolState::Charged` or `PoolState::Ongoing`;
     */
    get isV910(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.deposit') === 'f84769812825534404a6e577b634fc8471ea480180c5ec7f8a4634e6f411434e'
    }

    /**
     * Caller deposits some token to a liquidity-pool.
     * 
     * __NOTE__: The unclaimed rewards of caller will be withdrawn automatically if there has.
     * 
     * The conditions to deposit:
     * - The deposit caller was contributed to the pool should be bigger than
     *   `T::MinimumDeposit`;
     * - The pool is at `PoolState::Charged` or `PoolState::Ongoing`;
     */
    get asV910(): {pid: number, value: bigint} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotEditPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.edit_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Edit the parameters of a liquidity-pool.
     * 
     * __NOTE__: Forbid editing the liquidity-pool which type is `PoolType::EBFarming`;
     */
    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.edit_pool') === '6b4cc95739a1f5ed3d0d30a39e05bda8ce7855c1e8a26a27720ddf4d7a92e713'
    }

    /**
     * Edit the parameters of a liquidity-pool.
     * 
     * __NOTE__: Forbid editing the liquidity-pool which type is `PoolType::EBFarming`;
     */
    get asV922(): {pid: number, redeemLimitTime: number, unlockLimitNums: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotForceRetirePoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.force_retire_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Make a liquidity-pool be at `PoolState::Retired` forcefully.
     * 
     * __NOTE__:
     * 1. If the pool is at `PoolState::Charged` but doesn't have any deposit, the data about
     * 	the pool would be deleted and the rewards charged would be returned back.
     * 
     * 2. If the pool is at `PoolState::Charged` and has some deposit, or `PoolState::Ongoing`,
     * 	the field `block_retired` of the pool would be set to the current block height.
     */
    get isV910(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.force_retire_pool') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    /**
     * Make a liquidity-pool be at `PoolState::Retired` forcefully.
     * 
     * __NOTE__:
     * 1. If the pool is at `PoolState::Charged` but doesn't have any deposit, the data about
     * 	the pool would be deleted and the rewards charged would be returned back.
     * 
     * 2. If the pool is at `PoolState::Charged` and has some deposit, or `PoolState::Ongoing`,
     * 	the field `block_retired` of the pool would be set to the current block height.
     */
    get asV910(): {pid: number} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotKillPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.kill_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Kill a liquidity-pool at `PoolState::Uncharged`.
     */
    get isV910(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.kill_pool') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    /**
     * Kill a liquidity-pool at `PoolState::Uncharged`.
     */
    get asV910(): {pid: number} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotLazyMigrationV200Call {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.lazy_migration_v2_0_0')
        this._chain = ctx._chain
        this.call = call
    }

    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.lazy_migration_v2_0_0') === '5b3185b96241abf14961366b08bfd5bd4d6f0384b55a4a8cb0afa0389bbc8799'
    }

    get asV922(): {maxNums: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotRedeemCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.redeem')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Caller redeems some deposit owned by self from a pool.
     * 
     * __NOTE__: The unclaimed rewards of caller will be withdrawn automatically if there has.
     * 
     * __NOTE__:
     * 0. If the pool is at `PoolState::Ongoing`, the caller may not redeem successfully
     * because of 	the `reward algorithm`, which requires `pool-ongoing` must have deposit more
     * than `T::MinimumDeposit`.
     * 
     * 1. If the pool is at `PoolState::Retired`, the extrinsic will redeem all deposits
     * owned by the caller, whatever the `value` is.
     * 
     * 2. If the pool is at `PoolState::Retired` and the deposit in the pool will become zero
     * after calling the extrinsic, the remaining rewards left in the pool will be returned
     * back to the charger.
     * 
     * The condition to redeem:
     * - There is enough deposit owned by the caller in the pool.
     * - The pool is at `PoolState::Ongoing` or `PoolState::Retired`.
     */
    get isV910(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.redeem') === 'f84769812825534404a6e577b634fc8471ea480180c5ec7f8a4634e6f411434e'
    }

    /**
     * Caller redeems some deposit owned by self from a pool.
     * 
     * __NOTE__: The unclaimed rewards of caller will be withdrawn automatically if there has.
     * 
     * __NOTE__:
     * 0. If the pool is at `PoolState::Ongoing`, the caller may not redeem successfully
     * because of 	the `reward algorithm`, which requires `pool-ongoing` must have deposit more
     * than `T::MinimumDeposit`.
     * 
     * 1. If the pool is at `PoolState::Retired`, the extrinsic will redeem all deposits
     * owned by the caller, whatever the `value` is.
     * 
     * 2. If the pool is at `PoolState::Retired` and the deposit in the pool will become zero
     * after calling the extrinsic, the remaining rewards left in the pool will be returned
     * back to the charger.
     * 
     * The condition to redeem:
     * - There is enough deposit owned by the caller in the pool.
     * - The pool is at `PoolState::Ongoing` or `PoolState::Retired`.
     */
    get asV910(): {pid: number, value: bigint} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotRedeemAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.redeem_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Caller redeems all deposit owned by self from a pool.
     * 
     * __NOTE__: The unclaimed rewards of caller will be withdrawn automatically if there has.
     * 
     * __NOTE__:
     * 0. If the pool is at `PoolState::Ongoing`, the caller may not redeem successfully
     * because of 	the `reward algorithm`, which requires `pool-ongoing` must have deposit more
     * than `T::MinimumDeposit`.
     * 
     * 1. If the pool is at `PoolState::Retired` and the deposit in the pool will become zero
     * after calling the extrinsic, the remaining rewards left in the pool will be
     * returned back to the charger.
     * 
     * The condition to redeem:
     * - There is enough deposit owned by the caller in the pool.
     * - The pool is at `PoolState::Ongoing` or `PoolState::Retired`.
     */
    get isV910(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.redeem_all') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    /**
     * Caller redeems all deposit owned by self from a pool.
     * 
     * __NOTE__: The unclaimed rewards of caller will be withdrawn automatically if there has.
     * 
     * __NOTE__:
     * 0. If the pool is at `PoolState::Ongoing`, the caller may not redeem successfully
     * because of 	the `reward algorithm`, which requires `pool-ongoing` must have deposit more
     * than `T::MinimumDeposit`.
     * 
     * 1. If the pool is at `PoolState::Retired` and the deposit in the pool will become zero
     * after calling the extrinsic, the remaining rewards left in the pool will be
     * returned back to the charger.
     * 
     * The condition to redeem:
     * - There is enough deposit owned by the caller in the pool.
     * - The pool is at `PoolState::Ongoing` or `PoolState::Retired`.
     */
    get asV910(): {pid: number} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotUnlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.unlock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Caller unlocks the locked deposit in the liquidity-pool.
     * 
     * __NOTE__: The extrinsic will retire the pool, which is reached the end of life.
     * 
     * The conditions to unlock:
     * - The pool type is not `PoolType::EBFarming`.
     * - There are pending-unlocks in the deposit_data.
     * - The current block-height exceeded the unlock-height;
     */
    get isV922(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.unlock') === 'e0d3b1898d0ebeeeab00a238a2b65a78f305e25439ec07795da1c76e12825bcc'
    }

    /**
     * Caller unlocks the locked deposit in the liquidity-pool.
     * 
     * __NOTE__: The extrinsic will retire the pool, which is reached the end of life.
     * 
     * The conditions to unlock:
     * - The pool type is not `PoolType::EBFarming`.
     * - There are pending-unlocks in the deposit_data.
     * - The current block-height exceeded the unlock-height;
     */
    get asV922(): {pid: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }
}

export class LiquidityMiningDotVolunteerToRedeemCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'LiquidityMiningDOT.volunteer_to_redeem')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * A selfless man intimately helps depositors of the pool to redeem their deposit,
     * aaaaaaah, such a grateful!!
     * 
     * If the `account` is `Option::None`, the extrinsic will give "freedom" for a lucky man
     * randomly;
     * 
     * If the `account` is specific and a depositor of the pool indeed, who will be given
     * "freedom" by the extrinsic.
     * 
     * The condition to redeem:
     * - The pool is at `PoolState::Retired`.
     */
    get isV910(): boolean {
        return this._chain.getCallHash('LiquidityMiningDOT.volunteer_to_redeem') === '21e04532874dbc1d541215f001a15327a0d1b6f6e75b75713a186f80a58532b0'
    }

    /**
     * A selfless man intimately helps depositors of the pool to redeem their deposit,
     * aaaaaaah, such a grateful!!
     * 
     * If the `account` is `Option::None`, the extrinsic will give "freedom" for a lucky man
     * randomly;
     * 
     * If the `account` is specific and a depositor of the pool indeed, who will be given
     * "freedom" by the extrinsic.
     * 
     * The condition to redeem:
     * - The pool is at `PoolState::Retired`.
     */
    get asV910(): {pid: number, account: (Uint8Array | undefined)} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }
}

export class MerkleDistributorAddToCreateWhitelistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MerkleDistributor.add_to_create_whitelist')
        this._chain = ctx._chain
        this.call = call
    }

    get isV923(): boolean {
        return this._chain.getCallHash('MerkleDistributor.add_to_create_whitelist') === '7fb7672b764b0a4f0c4910fddefec0709628843df7ad0073a97eede13c53ca92'
    }

    get asV923(): {account: Uint8Array} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }
}

export class MerkleDistributorChargeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MerkleDistributor.charge')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Charge currency to the account of merkle distributor
     * 
     * `merkle_distributor_id`: ID of a merkle distributor.
     */
    get isV914(): boolean {
        return this._chain.getCallHash('MerkleDistributor.charge') === '6208f40e3e9713cfeb14ee41b5443c010a5dcab1a32faa74385c82419a21194c'
    }

    /**
     * Charge currency to the account of merkle distributor
     * 
     * `merkle_distributor_id`: ID of a merkle distributor.
     */
    get asV914(): {merkleDistributorId: number} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }
}

export class MerkleDistributorClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MerkleDistributor.claim')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * `claim` Claim rewards through user information and merkle proof.
     * 
     * - `merkle_distributor_id`: ID of a merkle distributor.
     * - `index`: The index of the merkle tree leaf.
     * - `account`: The owner's account of merkle proof.
     * - `merkle_proof`: The hashes with merkle tree leaf can get merkle tree root.
     */
    get isV914(): boolean {
        return this._chain.getCallHash('MerkleDistributor.claim') === 'a24f9506007d3fedf96d2e7dc4f5b401acbc39e666835f68d77554308dc9cc98'
    }

    /**
     * `claim` Claim rewards through user information and merkle proof.
     * 
     * - `merkle_distributor_id`: ID of a merkle distributor.
     * - `index`: The index of the merkle tree leaf.
     * - `account`: The owner's account of merkle proof.
     * - `merkle_proof`: The hashes with merkle tree leaf can get merkle tree root.
     */
    get asV914(): {merkleDistributorId: number, index: number, account: v914.MultiAddress, amount: bigint, merkleProof: Uint8Array[]} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }
}

export class MerkleDistributorCreateMerkleDistributorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MerkleDistributor.create_merkle_distributor')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * `create_merkle_distributor` will create a merkle distributor,
     *  which allow specified users claim asset.
     * 
     * The dispatch origin for this call must be `Signed` by root.
     * 
     * - `merkle_root`: The root of a merkle tree.
     * - `description`: About the purpose of this distribution.
     * - `distribute_currency`: The id of currency about this distribution.
     * - `distribute_amount`: The total currency amount of this distribution.
     */
    get isV914(): boolean {
        return this._chain.getCallHash('MerkleDistributor.create_merkle_distributor') === 'da67b895201d6db530ac8b7b9b224fafb770661e85248550b4c6f9d05ddd9b03'
    }

    /**
     * `create_merkle_distributor` will create a merkle distributor,
     *  which allow specified users claim asset.
     * 
     * The dispatch origin for this call must be `Signed` by root.
     * 
     * - `merkle_root`: The root of a merkle tree.
     * - `description`: About the purpose of this distribution.
     * - `distribute_currency`: The id of currency about this distribution.
     * - `distribute_amount`: The total currency amount of this distribution.
     */
    get asV914(): {merkleRoot: Uint8Array, description: Uint8Array, distributeCurrency: v914.CurrencyId, distributeAmount: bigint} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * `create_merkle_distributor` will create a merkle distributor,
     *  which allow specified users claim asset.
     * 
     * The dispatch origin for this call must be `Signed` by root.
     * 
     * - `merkle_root`: The root of a merkle tree.
     * - `description`: About the purpose of this distribution.
     * - `distribute_currency`: The id of currency about this distribution.
     * - `distribute_amount`: The total currency amount of this distribution.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('MerkleDistributor.create_merkle_distributor') === '30f31e318f44b7e1c01ab2e5c3b26bf219f61935f026e270489c01902adf48cb'
    }

    /**
     * `create_merkle_distributor` will create a merkle distributor,
     *  which allow specified users claim asset.
     * 
     * The dispatch origin for this call must be `Signed` by root.
     * 
     * - `merkle_root`: The root of a merkle tree.
     * - `description`: About the purpose of this distribution.
     * - `distribute_currency`: The id of currency about this distribution.
     * - `distribute_amount`: The total currency amount of this distribution.
     */
    get asV916(): {merkleRoot: Uint8Array, description: Uint8Array, distributeCurrency: v916.CurrencyId, distributeAmount: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * `create_merkle_distributor` will create a merkle distributor,
     *  which allow specified users claim asset.
     * 
     * The dispatch origin for this call must be `Signed` by root.
     * 
     * - `merkle_root`: The root of a merkle tree.
     * - `description`: About the purpose of this distribution.
     * - `distribute_currency`: The id of currency about this distribution.
     * - `distribute_amount`: The total currency amount of this distribution.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('MerkleDistributor.create_merkle_distributor') === '8b92fac3bc1ec8b213e327aaa426ce52f0b093a8949275e48898f50de0671e1f'
    }

    /**
     * `create_merkle_distributor` will create a merkle distributor,
     *  which allow specified users claim asset.
     * 
     * The dispatch origin for this call must be `Signed` by root.
     * 
     * - `merkle_root`: The root of a merkle tree.
     * - `description`: About the purpose of this distribution.
     * - `distribute_currency`: The id of currency about this distribution.
     * - `distribute_amount`: The total currency amount of this distribution.
     */
    get asV920(): {merkleRoot: Uint8Array, description: Uint8Array, distributeCurrency: v920.CurrencyId, distributeAmount: bigint} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * `create_merkle_distributor` will create a merkle distributor,
     *  which allow specified users claim asset.
     * 
     * The dispatch origin for this call must be `Signed` by root.
     * 
     * - `merkle_root`: The root of a merkle tree.
     * - `description`: About the purpose of this distribution.
     * - `distribute_currency`: The id of currency about this distribution.
     * - `distribute_amount`: The total currency amount of this distribution.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('MerkleDistributor.create_merkle_distributor') === '5972440d0443f6a0e9ae134c95b7851aa530261f94856da68c146c9519d5e9aa'
    }

    /**
     * `create_merkle_distributor` will create a merkle distributor,
     *  which allow specified users claim asset.
     * 
     * The dispatch origin for this call must be `Signed` by root.
     * 
     * - `merkle_root`: The root of a merkle tree.
     * - `description`: About the purpose of this distribution.
     * - `distribute_currency`: The id of currency about this distribution.
     * - `distribute_amount`: The total currency amount of this distribution.
     */
    get asV932(): {merkleRoot: Uint8Array, description: Uint8Array, distributeCurrency: v932.CurrencyId, distributeAmount: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * `create_merkle_distributor` will create a merkle distributor,
     *  which allow specified users claim asset.
     * 
     * The dispatch origin for this call must be `Signed` by root.
     * 
     * - `merkle_root`: The root of a merkle tree.
     * - `description`: About the purpose of this distribution.
     * - `distribute_currency`: The id of currency about this distribution.
     * - `distribute_amount`: The total currency amount of this distribution.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('MerkleDistributor.create_merkle_distributor') === 'da44aca238fbef123f753acb7afc424e243bbc857aab5069f93d5904962fe609'
    }

    /**
     * `create_merkle_distributor` will create a merkle distributor,
     *  which allow specified users claim asset.
     * 
     * The dispatch origin for this call must be `Signed` by root.
     * 
     * - `merkle_root`: The root of a merkle tree.
     * - `description`: About the purpose of this distribution.
     * - `distribute_currency`: The id of currency about this distribution.
     * - `distribute_amount`: The total currency amount of this distribution.
     */
    get asV956(): {merkleRoot: Uint8Array, description: Uint8Array, distributeCurrency: v956.CurrencyId, distributeAmount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * `create_merkle_distributor` will create a merkle distributor,
     *  which allow specified users claim asset.
     * 
     * The dispatch origin for this call must be `Signed` by root.
     * 
     * - `merkle_root`: The root of a merkle tree.
     * - `description`: About the purpose of this distribution.
     * - `distribute_currency`: The id of currency about this distribution.
     * - `distribute_amount`: The total currency amount of this distribution.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('MerkleDistributor.create_merkle_distributor') === 'a3f5fc89295164cb12e1b0d4d4c8c09b5a8a272448b6e53e6fd1617a44226c02'
    }

    /**
     * `create_merkle_distributor` will create a merkle distributor,
     *  which allow specified users claim asset.
     * 
     * The dispatch origin for this call must be `Signed` by root.
     * 
     * - `merkle_root`: The root of a merkle tree.
     * - `description`: About the purpose of this distribution.
     * - `distribute_currency`: The id of currency about this distribution.
     * - `distribute_amount`: The total currency amount of this distribution.
     */
    get asV962(): {merkleRoot: Uint8Array, description: Uint8Array, distributeCurrency: v962.CurrencyId, distributeAmount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class MerkleDistributorEmergencyWithdrawCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MerkleDistributor.emergency_withdraw')
        this._chain = ctx._chain
        this.call = call
    }

    get isV914(): boolean {
        return this._chain.getCallHash('MerkleDistributor.emergency_withdraw') === 'b74763fb16c8045f344749ef03848ae32ac5a919c12a7fdb2f17d4a1c583f8e8'
    }

    get asV914(): {merkleDistributorId: number, recipient: v914.MultiAddress, amount: bigint} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }
}

export class MerkleDistributorRemoveFromCreateWhitelistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'MerkleDistributor.remove_from_create_whitelist')
        this._chain = ctx._chain
        this.call = call
    }

    get isV923(): boolean {
        return this._chain.getCallHash('MerkleDistributor.remove_from_create_whitelist') === '7fb7672b764b0a4f0c4910fddefec0709628843df7ad0073a97eede13c53ca92'
    }

    get asV923(): {account: Uint8Array} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }
}

export class MultisigApproveAsMultiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Multisig.approve_as_multi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  ----------------------------------
     *  - DB Weight:
     *      - Read: Multisig Storage, [Caller Account]
     *      - Write: Multisig Storage, [Caller Account]
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Multisig.approve_as_multi') === '615a5baaaa889f9e30839c70485b8c752e5eb050a85a23102b2f9f4c301be63a'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  ----------------------------------
     *  - DB Weight:
     *      - Read: Multisig Storage, [Caller Account]
     *      - Write: Multisig Storage, [Caller Account]
     *  # </weight>
     */
    get asV804(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v804.Timepoint | undefined), callHash: Uint8Array, maxWeight: bigint} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     * 
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     * # <weight>
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * ----------------------------------
     * - DB Weight:
     *     - Read: Multisig Storage, [Caller Account]
     *     - Write: Multisig Storage, [Caller Account]
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Multisig.approve_as_multi') === '88561668497d8fdee3be21d28e6e68bc1cd9568f418501a4b294fe2b9803acb4'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     * 
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     * # <weight>
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * ----------------------------------
     * - DB Weight:
     *     - Read: Multisig Storage, [Caller Account]
     *     - Write: Multisig Storage, [Caller Account]
     * # </weight>
     */
    get asV968(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v968.Timepoint | undefined), callHash: Uint8Array, maxWeight: v968.Weight} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class MultisigAsMultiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Multisig.as_multi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  -------------------------------
     *  - DB Weight:
     *      - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)
     *      - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '548dea53ff79fe99438cf591950a533c93f9772d03a3995ec72a80376fcae222'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  -------------------------------
     *  - DB Weight:
     *      - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)
     *      - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV804(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v804.Timepoint | undefined), call: Uint8Array, storeCall: boolean, maxWeight: bigint} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === 'f6739dccd29fadcde6516d3401747055ae8350b451578eda4600e2ce2d9ea8f1'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get asV968(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v968.Timepoint | undefined), call: v968.Call, maxWeight: v968.Weight} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === 'e7a4e920a51d60def38ef4b1cdbb7e55f14b88021f2ce8a497ca7dd8faf19f05'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get asV970(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v970.Timepoint | undefined), call: v970.Call, maxWeight: v970.Weight} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '46d29f1f458b441eb7b6ce2656f7d6afd5cf6e991a44dcb024d8d6b4b8e12164'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get asV972(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v972.Timepoint | undefined), call: v972.Call, maxWeight: v972.Weight} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class MultisigAsMultiThreshold1Call {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Multisig.as_multi_threshold_1')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'ce6c94d178f80804d1daaf9fd194431a6a5b2c77c225dddaaf5e083e8831d50f'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV804(): {otherSignatories: Uint8Array[], call: v804.Type_51} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV805(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'e4fa8662a18d433379985fe347606ecb0ad373a4fb346192b31019a8a98a7722'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV805(): {otherSignatories: Uint8Array[], call: v805.Type_118} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '1a61fe6aebe8a7f97cf5223d3c77abc946723ad62c9632da82ee1cc96c03bcba'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV900(): {otherSignatories: Uint8Array[], call: v900.Type_118} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV901(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '3e5392eff4e225336c2862496d8c766c50f687cd071d7bbfd4fe0acece1bd49d'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV901(): {otherSignatories: Uint8Array[], call: v901.Type_118} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV902(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'f9f9f3d172d527956ba0ff07ea0415554fc8fc786226861fe975c8ae425085e3'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV902(): {otherSignatories: Uint8Array[], call: v902.Type_118} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'd1bfd9169705fd4129c952873c15b6c27012c7502f953447f82ce23b0e167092'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV906(): {otherSignatories: Uint8Array[], call: v906.Call} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'f2abc2d52098062539f309ef7e0eedbdad29116eef0a750a3f64d3b732d9b4f9'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV908(): {otherSignatories: Uint8Array[], call: v908.Call} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV910(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'dda2731e7b61e1ef252d72060538bea0d1156fc5d003a5915f30af681ef2e34a'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV910(): {otherSignatories: Uint8Array[], call: v910.Call} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV912(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'ba0f097b15c74a7c48c0e7bb5ede1bc01f357c35db9f99bda9fb8569cebc26a5'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV912(): {otherSignatories: Uint8Array[], call: v912.Call} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV914(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '704db7c0e3f72eda3d2ca5ffcc61dfede031780b696840b0f7b6e49c2fb30d74'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV914(): {otherSignatories: Uint8Array[], call: v914.Call} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV915(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'b6725659955a6246ddfe9c4d9fe2c3f27fa62705f8a59fd917ace45f7fb571a0'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV915(): {otherSignatories: Uint8Array[], call: v915.Call} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '6af60792b711392a89d6130a090b3abdebcd6e860516c18afda383b929075caa'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV916(): {otherSignatories: Uint8Array[], call: v916.Call} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '44014b1683f64ccf7b0e78a69e95aab27125dc79ab285ffb442ee7f4bb8582f1'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV918(): {otherSignatories: Uint8Array[], call: v918.Call} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'd10503400ce68be69284697c993f94a4e197c202917328564375c82e7e2e12ba'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV920(): {otherSignatories: Uint8Array[], call: v920.Call} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '71fccd9b0e3104ae777e61983ec23ef7a44210d14f90147245c5d25bdd3df0c2'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV922(): {otherSignatories: Uint8Array[], call: v922.Call} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'c4638e4aad387733b53ba98c2bfdc02e3ced85f4cc918a61c1562bc6ae5128f9'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV923(): {otherSignatories: Uint8Array[], call: v923.Call} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '3ecd5f50dc89299e5a3b32c41dd1d937c24a842896d865eda86bace1d15a2f0e'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV926(): {otherSignatories: Uint8Array[], call: v926.Call} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '785ec76afcad736b01d2fd4968a9aeee35c8195605f12e42dc6219fb5659877c'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV927(): {otherSignatories: Uint8Array[], call: v927.Call} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'cada42e63d9cc5cae536fe13eac9fb4d778301da64981c6d64c3d7d8b1a0410d'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV930(): {otherSignatories: Uint8Array[], call: v930.Call} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '95528a59e85080b6a7e74c0bbda4f9ecb7fc1b9654163f7956bfdfa52a456c08'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV932(): {otherSignatories: Uint8Array[], call: v932.Call} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'fbf5abe718ea8d9c2086e83feb822bc698c34db988e0d25484723c17dcb3e62b'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV940(): {otherSignatories: Uint8Array[], call: v940.Call} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '99d176be5160dd8f1582651ce75ecb4f3c41707aa15883fe61b20d503bb043be'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV942(): {otherSignatories: Uint8Array[], call: v942.Call} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '10b0c64415368a60541d1e116305698c28b19a9b0f04e3afb6750eae9c1e2f12'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV944(): {otherSignatories: Uint8Array[], call: v944.Call} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '92c6b55d818913c00c9d387a7fef38b374a7e18ec82911c40310e808f980f345'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV946(): {otherSignatories: Uint8Array[], call: v946.Call} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '654853f38cf66e51d13280b55e7510102f43011e9b1dbba46f1e6e0e201090ca'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV948(): {otherSignatories: Uint8Array[], call: v948.Call} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '7a86faba2b39c61bead2285b2c05405694e417f90787ac128b12db29fb412c5f'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV952(): {otherSignatories: Uint8Array[], call: v952.Call} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'dd94abc9eabc246640bd540258e4e920cb2d38801e125e0ebdc03d967ebcaecc'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV954(): {otherSignatories: Uint8Array[], call: v954.Call} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'b61df3b0a5fc37409df12b252a72e50bfbfce38ee4e074d5bd308fb25c80a340'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV956(): {otherSignatories: Uint8Array[], call: v956.Call} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'e76c33ff40301d756659a8152e03cd83107b8083ec294b4f1c111347106a050c'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV958(): {otherSignatories: Uint8Array[], call: v958.Call} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '1c9a221c70a14e40794b5a62f80b1a826bc17ab6b5592cf99c4f8caddeaa0aa9'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV962(): {otherSignatories: Uint8Array[], call: v962.Call} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'd53b4a920970ec5ecf690d54fd7aa919241cab49043543cf6dfe3baa4c900c56'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV964(): {otherSignatories: Uint8Array[], call: v964.Call} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '36e4f82d2f4736f24f084e38d892038d67cc7774447597d22eff032601211916'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV967(): {otherSignatories: Uint8Array[], call: v967.Call} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'c478bd5191d2512243382bbda169535a854abe4958574309e2721bb6186e1aae'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV968(): {otherSignatories: Uint8Array[], call: v968.Call} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'b7772f13140d147211cb7b18a920010eb34e8b483925fefec7bbcf92c10e1c69'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV970(): {otherSignatories: Uint8Array[], call: v970.Call} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '1b73b88b7919937e1e6d34867ac5bb8185b2937717f8d71062fc65cfd792d6fc'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV972(): {otherSignatories: Uint8Array[], call: v972.Call} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class MultisigCancelAsMultiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Multisig.cancel_as_multi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     *  for this operation will be unreserved on success.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `timepoint`: The timepoint (block number and transaction index) of the first approval
     *  transaction for this dispatch.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - One event.
     *  - I/O: 1 read `O(S)`, one remove.
     *  - Storage: removes one item.
     *  ----------------------------------
     *  - DB Weight:
     *      - Read: Multisig Storage, [Caller Account], Refund Account, Calls
     *      - Write: Multisig Storage, [Caller Account], Refund Account, Calls
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Multisig.cancel_as_multi') === '4ccc75a4f739c659f177e3df98fba2ea59ddade74c4ebccd51b2fc4c52e923af'
    }

    /**
     *  Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     *  for this operation will be unreserved on success.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `timepoint`: The timepoint (block number and transaction index) of the first approval
     *  transaction for this dispatch.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - One event.
     *  - I/O: 1 read `O(S)`, one remove.
     *  - Storage: removes one item.
     *  ----------------------------------
     *  - DB Weight:
     *      - Read: Multisig Storage, [Caller Account], Refund Account, Calls
     *      - Write: Multisig Storage, [Caller Account], Refund Account, Calls
     *  # </weight>
     */
    get asV804(): {threshold: number, otherSignatories: Uint8Array[], timepoint: v804.Timepoint, callHash: Uint8Array} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }
}

export class OrmlXcmSendAsSovereignCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'OrmlXcm.send_as_sovereign')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Send an XCM message as parachain sovereign.
     */
    get isV805(): boolean {
        return this._chain.getCallHash('OrmlXcm.send_as_sovereign') === '8fe0974e74c786d3f8bb01dc13650a419fe9b97da675546b666d5fe67e5722d0'
    }

    /**
     *  Send an XCM message as parachain sovereign.
     */
    get asV805(): {dest: v805.MultiLocation, message: v805.Xcm} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send an XCM message as parachain sovereign.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('OrmlXcm.send_as_sovereign') === 'efce908bf999551e7677d1b7185fa55d1fad334724593131b11396939d23e27e'
    }

    /**
     *  Send an XCM message as parachain sovereign.
     */
    get asV902(): {dest: v902.MultiLocation, message: v902.Xcm} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send an XCM message as parachain sovereign.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('OrmlXcm.send_as_sovereign') === '03c13606746d5ac84f2ce4830e7c82a4f8ed0634ad4a197c22018ce3fde5e602'
    }

    /**
     * Send an XCM message as parachain sovereign.
     */
    get asV906(): {dest: v906.V1MultiLocation, message: v906.V2Instruction[]} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send an XCM message as parachain sovereign.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('OrmlXcm.send_as_sovereign') === '9ec4149ae6cee6240a6e2aa06a8ef90285e68be29dd0de109b35af7922311609'
    }

    /**
     * Send an XCM message as parachain sovereign.
     */
    get asV916(): {dest: v916.VersionedMultiLocation, message: v916.VersionedXcm} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send an XCM message as parachain sovereign.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('OrmlXcm.send_as_sovereign') === '3ca4beb317aeed3e0a00ae870ffd3bef841bb6f4e766db0b286c7fc5d8eef886'
    }

    /**
     * Send an XCM message as parachain sovereign.
     */
    get asV926(): {dest: v926.VersionedMultiLocation, message: v926.VersionedXcm} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send an XCM message as parachain sovereign.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('OrmlXcm.send_as_sovereign') === '23ee62671c78b4c334d1aac87969a94e2d7514e9e9acd1949878df4525736480'
    }

    /**
     * Send an XCM message as parachain sovereign.
     */
    get asV970(): {dest: v970.VersionedMultiLocation, message: v970.VersionedXcm} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send an XCM message as parachain sovereign.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('OrmlXcm.send_as_sovereign') === '9c814457e6c06e355f17d8e2e59924a734ef38dfc7852490ba89fd5b845b6f48'
    }

    /**
     * Send an XCM message as parachain sovereign.
     */
    get asV972(): {dest: v972.VersionedMultiLocation, message: v972.VersionedXcm} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingCancelCandidateBondLessCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.cancel_candidate_bond_less')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel pending request to adjust the collator candidate self bond
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.cancel_candidate_bond_less') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Cancel pending request to adjust the collator candidate self bond
     */
    get asV930(): null {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingCancelDelegationRequestCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.cancel_delegation_request')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel request to change an existing delegation.
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.cancel_delegation_request') === '3628b3aba77dce2d54e6db67e810eccf17921a84b907aea8b90a342fd5ad6c01'
    }

    /**
     * Cancel request to change an existing delegation.
     */
    get asV930(): {candidate: Uint8Array} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingCancelLeaveCandidatesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.cancel_leave_candidates')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel open request to leave candidates
     * - only callable by collator account
     * - result upon successful call is the candidate is active in the candidate pool
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.cancel_leave_candidates') === '686eeafa55cefbea4fd57209c34b1a2e10fd7c57584a53285401aa0463a9bbf2'
    }

    /**
     * Cancel open request to leave candidates
     * - only callable by collator account
     * - result upon successful call is the candidate is active in the candidate pool
     */
    get asV930(): {candidateCount: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingCancelLeaveDelegatorsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.cancel_leave_delegators')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel a pending request to exit the set of delegators. Success clears the pending exit
     * request (thereby resetting the delay upon another `leave_delegators` call).
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.cancel_leave_delegators') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Cancel a pending request to exit the set of delegators. Success clears the pending exit
     * request (thereby resetting the delay upon another `leave_delegators` call).
     */
    get asV930(): null {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingCandidateBondMoreCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.candidate_bond_more')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Increase collator candidate self bond by `more`
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.candidate_bond_more') === '510e5796be2276dabdf492d2ba358a0c7af13907fdbdd359f76149808ca0700c'
    }

    /**
     * Increase collator candidate self bond by `more`
     */
    get asV930(): {more: bigint} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingDelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.delegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * If caller is not a delegator and not a collator, then join the set of delegators
     * If caller is a delegator, then makes delegation to change their delegation state
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.delegate') === '6bd4be6fdeb0ecc32c3e92513629b3a6d48507fbb35d96c6b064c6cd341986ab'
    }

    /**
     * If caller is not a delegator and not a collator, then join the set of delegators
     * If caller is a delegator, then makes delegation to change their delegation state
     */
    get asV930(): {candidate: Uint8Array, amount: bigint, candidateDelegationCount: number, delegationCount: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingDelegatorBondMoreCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.delegator_bond_more')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Bond more for delegators wrt a specific collator candidate.
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.delegator_bond_more') === 'debb98f2c325ef3ce6531623262b5f1c403bb6de0995265100236b858551153e'
    }

    /**
     * Bond more for delegators wrt a specific collator candidate.
     */
    get asV930(): {candidate: Uint8Array, more: bigint} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingExecuteCandidateBondLessCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.execute_candidate_bond_less')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Execute pending request to adjust the collator candidate self bond
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.execute_candidate_bond_less') === '3628b3aba77dce2d54e6db67e810eccf17921a84b907aea8b90a342fd5ad6c01'
    }

    /**
     * Execute pending request to adjust the collator candidate self bond
     */
    get asV930(): {candidate: Uint8Array} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingExecuteDelegationRequestCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.execute_delegation_request')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Execute pending request to change an existing delegation
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.execute_delegation_request') === '8ba9c8419f942f7dc005f60d76fef2d5a2b7c155c3fcd80e46a147ece5d6839b'
    }

    /**
     * Execute pending request to change an existing delegation
     */
    get asV930(): {delegator: Uint8Array, candidate: Uint8Array} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingExecuteLeaveCandidatesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.execute_leave_candidates')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Execute leave candidates request
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.execute_leave_candidates') === 'caa7100e0b104a03283f85af95c22efa9e45d339932b3eaa724333c174e5d444'
    }

    /**
     * Execute leave candidates request
     */
    get asV930(): {candidate: Uint8Array, candidateDelegationCount: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingExecuteLeaveDelegatorsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.execute_leave_delegators')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Execute the right to exit the set of delegators and revoke all ongoing delegations.
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.execute_leave_delegators') === '87f197b1000bf658ea078162cbf1156981ffbcd5433eec3f2b36bb076bff9048'
    }

    /**
     * Execute the right to exit the set of delegators and revoke all ongoing delegations.
     */
    get asV930(): {delegator: Uint8Array, delegationCount: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingGoOfflineCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.go_offline')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Temporarily leave the set of collator candidates without unbonding
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.go_offline') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Temporarily leave the set of collator candidates without unbonding
     */
    get asV930(): null {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingGoOnlineCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.go_online')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Rejoin the set of collator candidates if previously had called `go_offline`
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.go_online') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Rejoin the set of collator candidates if previously had called `go_offline`
     */
    get asV930(): null {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingHotfixMigrateCollatorsFromReserveToLocksCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.hotfix_migrate_collators_from_reserve_to_locks')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Hotfix to migrate a collator's reserve to a lock. For any given collator in the
     * provided list:
     * * this fn is idempotent
     * * is safe to call if the collator doesn't exist
     * * is safe to call if the collator has been migrated
     * * is safe to call if the collator is a collator (this is a no-op)
     * 
     * weight calculation:
     *   reads:
     *    * CollatorReserveToLockMigrations
     *    * CandidateInfo
     *   writes:
     *    * unreserve()
     *    * set_lock()
     *    * CollatorReserveToLockMigrations
     *   other: 50M flat weight + 100M weight per item
     */
    get isV954(): boolean {
        return this._chain.getCallHash('ParachainStaking.hotfix_migrate_collators_from_reserve_to_locks') === 'a832a7ce12f70e4e43cd819b84df9a249b63c0b473acf0473249c6606083fb4e'
    }

    /**
     * Hotfix to migrate a collator's reserve to a lock. For any given collator in the
     * provided list:
     * * this fn is idempotent
     * * is safe to call if the collator doesn't exist
     * * is safe to call if the collator has been migrated
     * * is safe to call if the collator is a collator (this is a no-op)
     * 
     * weight calculation:
     *   reads:
     *    * CollatorReserveToLockMigrations
     *    * CandidateInfo
     *   writes:
     *    * unreserve()
     *    * set_lock()
     *    * CollatorReserveToLockMigrations
     *   other: 50M flat weight + 100M weight per item
     */
    get asV954(): {collators: Uint8Array[]} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingHotfixMigrateDelegatorsFromReserveToLocksCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.hotfix_migrate_delegators_from_reserve_to_locks')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Hotfix to migrate a delegator's reserve to a lock. For any given delegator in the
     * provided list:
     * * this fn is idempotent
     * * is safe to call if the delegator doesn't exist
     * * is safe to call if the delegator has been migrated
     * * is safe to call if the delegator is a collator (this is a no-op)
     * 
     * weight calculation:
     *   reads:
     *    * DelegatorReserveToLockMigrations
     *    * DelegatorState
     *   writes:
     *    * unreserve()
     *    * set_lock()
     *    * DelegatorReserveToLockMigrations
     *   other: 50M flat weight + 100M weight per item
     */
    get isV954(): boolean {
        return this._chain.getCallHash('ParachainStaking.hotfix_migrate_delegators_from_reserve_to_locks') === 'a7b6e7be42cd9a827a5d97e6f67acbb921166623737132ce5c5f96964233e4cb'
    }

    /**
     * Hotfix to migrate a delegator's reserve to a lock. For any given delegator in the
     * provided list:
     * * this fn is idempotent
     * * is safe to call if the delegator doesn't exist
     * * is safe to call if the delegator has been migrated
     * * is safe to call if the delegator is a collator (this is a no-op)
     * 
     * weight calculation:
     *   reads:
     *    * DelegatorReserveToLockMigrations
     *    * DelegatorState
     *   writes:
     *    * unreserve()
     *    * set_lock()
     *    * DelegatorReserveToLockMigrations
     *   other: 50M flat weight + 100M weight per item
     */
    get asV954(): {delegators: Uint8Array[]} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingHotfixRemoveDelegationRequestsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.hotfix_remove_delegation_requests')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Hotfix patch to remove all delegation requests not removed during a candidate exit
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.hotfix_remove_delegation_requests') === 'a7b6e7be42cd9a827a5d97e6f67acbb921166623737132ce5c5f96964233e4cb'
    }

    /**
     * Hotfix patch to remove all delegation requests not removed during a candidate exit
     */
    get asV930(): {delegators: Uint8Array[]} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingHotfixRemoveDelegationRequestsExitedCandidatesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.hotfix_remove_delegation_requests_exited_candidates')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Hotfix to remove existing empty entries for candidates that have left.
     */
    get isV954(): boolean {
        return this._chain.getCallHash('ParachainStaking.hotfix_remove_delegation_requests_exited_candidates') === '4735b3424961cde4392c4aa4a49b608c3a968b79ca43d53639eb628d11ef359d'
    }

    /**
     * Hotfix to remove existing empty entries for candidates that have left.
     */
    get asV954(): {candidates: Uint8Array[]} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingHotfixUpdateCandidatePoolValueCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.hotfix_update_candidate_pool_value')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Hotfix patch to correct and update CandidatePool value for candidates that have
     * called candidate_bond_more when it did not update the CandidatePool value
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.hotfix_update_candidate_pool_value') === '4735b3424961cde4392c4aa4a49b608c3a968b79ca43d53639eb628d11ef359d'
    }

    /**
     * Hotfix patch to correct and update CandidatePool value for candidates that have
     * called candidate_bond_more when it did not update the CandidatePool value
     */
    get asV930(): {candidates: Uint8Array[]} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingHotfixUpdateDelegatorStateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.hotfix_update_delegator_state')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Hotfix patch to correct delegation state with wrong delegator_bond_more
     */
    get isV942(): boolean {
        return this._chain.getCallHash('ParachainStaking.hotfix_update_delegator_state') === '194567a362aba25fc8bb34166baf5e491ce5dd6d7fd5e4788bbf8df6a8d002f7'
    }

    /**
     * Hotfix patch to correct delegation state with wrong delegator_bond_more
     */
    get asV942(): {candidate: Uint8Array, delegator: Uint8Array, amount: bigint} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Hotfix patch to correct delegation state with wrong delegator_bond_more
     */
    get isV944(): boolean {
        return this._chain.getCallHash('ParachainStaking.hotfix_update_delegator_state') === '47642df0a4092a1623580bb8258e52d7ce940c37e649ed333bb2a86bff7ab142'
    }

    /**
     * Hotfix patch to correct delegation state with wrong delegator_bond_more
     */
    get asV944(): {candidate: Uint8Array, delegator: Uint8Array, candidateAmount: bigint, unreserveAmount: bigint, delegationCount: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingJoinCandidatesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.join_candidates')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Join the set of collator candidates
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.join_candidates') === '6832aa96f7b5bf6addd0c8cc4f9ae51f63c4c8a705cc5cc698fa8a24c1fc4476'
    }

    /**
     * Join the set of collator candidates
     */
    get asV930(): {bond: bigint, candidateCount: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingScheduleCandidateBondLessCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.schedule_candidate_bond_less')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Request by collator candidate to decrease self bond by `less`
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.schedule_candidate_bond_less') === 'cd01c75bba8be1109a7311fe5e14ce439715dc5bae824e0d2efba8754cecb877'
    }

    /**
     * Request by collator candidate to decrease self bond by `less`
     */
    get asV930(): {less: bigint} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingScheduleDelegatorBondLessCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.schedule_delegator_bond_less')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Request bond less for delegators wrt a specific collator candidate.
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.schedule_delegator_bond_less') === 'b7d3cc42ff1703f4be55374d43c628a3d3eeb0e241650a9fcded5927d9cfb782'
    }

    /**
     * Request bond less for delegators wrt a specific collator candidate.
     */
    get asV930(): {candidate: Uint8Array, less: bigint} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingScheduleLeaveCandidatesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.schedule_leave_candidates')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Request to leave the set of candidates. If successful, the account is immediately
     * removed from the candidate pool to prevent selection as a collator.
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.schedule_leave_candidates') === '686eeafa55cefbea4fd57209c34b1a2e10fd7c57584a53285401aa0463a9bbf2'
    }

    /**
     * Request to leave the set of candidates. If successful, the account is immediately
     * removed from the candidate pool to prevent selection as a collator.
     */
    get asV930(): {candidateCount: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingScheduleLeaveDelegatorsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.schedule_leave_delegators')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Request to leave the set of delegators. If successful, the caller is scheduled
     * to be allowed to exit. Success forbids future delegator actions until the request is
     * invoked or cancelled.
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.schedule_leave_delegators') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Request to leave the set of delegators. If successful, the caller is scheduled
     * to be allowed to exit. Success forbids future delegator actions until the request is
     * invoked or cancelled.
     */
    get asV930(): null {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingScheduleRevokeDelegationCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.schedule_revoke_delegation')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Request to revoke an existing delegation. If successful, the delegation is scheduled
     * to be allowed to be revoked via the `execute_delegation_request` extrinsic.
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.schedule_revoke_delegation') === '1641c8b21dbb44dcf4348fc275e26b0a6c49308dd1214c697fc424f3b29fe39e'
    }

    /**
     * Request to revoke an existing delegation. If successful, the delegation is scheduled
     * to be allowed to be revoked via the `execute_delegation_request` extrinsic.
     */
    get asV930(): {collator: Uint8Array} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingSetBlocksPerRoundCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.set_blocks_per_round')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set blocks per round
     * - if called with `new` less than length of current round, will transition immediately
     * in the next block
     * - also updates per-round inflation config
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.set_blocks_per_round') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set blocks per round
     * - if called with `new` less than length of current round, will transition immediately
     * in the next block
     * - also updates per-round inflation config
     */
    get asV930(): {new: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingSetCollatorCommissionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.set_collator_commission')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the commission for all collators
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.set_collator_commission') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the commission for all collators
     */
    get asV930(): {new: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingSetInflationCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.set_inflation')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the annual inflation rate to derive per-round inflation
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.set_inflation') === 'fafdf61154c0388cdff2eb8d210526e9ba2d925398effdbea9ed8f4cf289a16c'
    }

    /**
     * Set the annual inflation rate to derive per-round inflation
     */
    get asV930(): {schedule: v930.Type_258} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingSetParachainBondAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.set_parachain_bond_account')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the account that will hold funds set aside for parachain bond
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.set_parachain_bond_account') === 'f866dcb3e8857987a2d21e57c13216c10bb21546a718b81d5e2c0989d6e95df7'
    }

    /**
     * Set the account that will hold funds set aside for parachain bond
     */
    get asV930(): {new: Uint8Array} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingSetParachainBondReservePaymentCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.set_parachain_bond_reserve_payment')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set payment for each round
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.set_parachain_bond_reserve_payment') === '86d3c70a5efeaca7d1a72b006ed6757b84fb71871eb54ca1d98d6a8fdeb79e3a'
    }

    /**
     * Set payment for each round
     */
    get asV930(): {new: bigint} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingSetParachainBondReservePercentCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.set_parachain_bond_reserve_percent')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the percent of inflation set aside for parachain bond
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.set_parachain_bond_reserve_percent') === '09500100ee0ef7de7a517c77b545786d373383efeb1a42ac3f0ddaccc0f7486a'
    }

    /**
     * Set the percent of inflation set aside for parachain bond
     */
    get asV930(): {new: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingSetStakingExpectationsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.set_staking_expectations')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the expectations for total staked. These expectations determine the issuance for
     * the round according to logic in `fn compute_issuance`
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.set_staking_expectations') === 'd129d2f224f991bf699793fc7629e2ba1f9f2b4e2993d7dd7b3b4f6aee0d9c3a'
    }

    /**
     * Set the expectations for total staked. These expectations determine the issuance for
     * the round according to logic in `fn compute_issuance`
     */
    get asV930(): {expectations: v930.Range} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainStakingSetTotalSelectedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainStaking.set_total_selected')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the total number of collator candidates selected per round
     * - changes are not applied until the start of the next round
     */
    get isV930(): boolean {
        return this._chain.getCallHash('ParachainStaking.set_total_selected') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the total number of collator candidates selected per round
     * - changes are not applied until the start of the next round
     */
    get asV930(): {new: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainSystemAuthorizeUpgradeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainSystem.authorize_upgrade')
        this._chain = ctx._chain
        this.call = call
    }

    get isV1(): boolean {
        return this._chain.getCallHash('ParachainSystem.authorize_upgrade') === '9e5c86c297bd88fae31bc40119e44695818ddc3ab8842b90daeb12771005c70d'
    }

    get asV1(): {codeHash: Uint8Array} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainSystemEnactAuthorizedUpgradeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainSystem.enact_authorized_upgrade')
        this._chain = ctx._chain
        this.call = call
    }

    get isV1(): boolean {
        return this._chain.getCallHash('ParachainSystem.enact_authorized_upgrade') === '7bf3d4785d9be7a4872f39cbd3702a66e16f7ee01e4446fb4a05624dc0ec4c93'
    }

    get asV1(): {code: Uint8Array} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainSystemSetUpgradeBlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainSystem.set_upgrade_block')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force an already scheduled validation function upgrade to happen on a particular block.
     * 
     *  Note that coordinating this block for the upgrade has to happen independently on the
     *  relay chain and this parachain. Synchronizing the block for the upgrade is sensitive,
     *  and this bypasses all checks and and normal protocols. Very easy to brick your chain
     *  if done wrong.
     */
    get isV1(): boolean {
        return this._chain.getCallHash('ParachainSystem.set_upgrade_block') === '4552b4c9a331e27653dd826226a620c7ef63c4af553ba86f11cdfd63fb1b1028'
    }

    /**
     *  Force an already scheduled validation function upgrade to happen on a particular block.
     * 
     *  Note that coordinating this block for the upgrade has to happen independently on the
     *  relay chain and this parachain. Synchronizing the block for the upgrade is sensitive,
     *  and this bypasses all checks and and normal protocols. Very easy to brick your chain
     *  if done wrong.
     */
    get asV1(): {relayChainBlock: number} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainSystemSetValidationDataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainSystem.set_validation_data')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the current validation data.
     * 
     *  This should be invoked exactly once per block. It will panic at the finalization
     *  phase if the call was not invoked.
     * 
     *  The dispatch origin for this call must be `Inherent`
     * 
     *  As a side effect, this function upgrades the current validation function
     *  if the appropriate time has come.
     */
    get isV1(): boolean {
        return this._chain.getCallHash('ParachainSystem.set_validation_data') === '22ec3fbecbfd95518ed01cc8bea79e7382fdee331e8c2bc72c401a6985444f34'
    }

    /**
     *  Set the current validation data.
     * 
     *  This should be invoked exactly once per block. It will panic at the finalization
     *  phase if the call was not invoked.
     * 
     *  The dispatch origin for this call must be `Inherent`
     * 
     *  As a side effect, this function upgrades the current validation function
     *  if the appropriate time has come.
     */
    get asV1(): {data: v1.ParachainInherentData} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the current validation data.
     * 
     * This should be invoked exactly once per block. It will panic at the finalization
     * phase if the call was not invoked.
     * 
     * The dispatch origin for this call must be `Inherent`
     * 
     * As a side effect, this function upgrades the current validation function
     * if the appropriate time has come.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ParachainSystem.set_validation_data') === 'df843f97e4c625e033541d5f205c5889f3131bdb4549570310e924d96769c1cd'
    }

    /**
     * Set the current validation data.
     * 
     * This should be invoked exactly once per block. It will panic at the finalization
     * phase if the call was not invoked.
     * 
     * The dispatch origin for this call must be `Inherent`
     * 
     * As a side effect, this function upgrades the current validation function
     * if the appropriate time has come.
     */
    get asV906(): {data: v906.ParachainInherentData} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainSystemSudoSendUpwardMessageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainSystem.sudo_send_upward_message')
        this._chain = ctx._chain
        this.call = call
    }

    get isV1(): boolean {
        return this._chain.getCallHash('ParachainSystem.sudo_send_upward_message') === '34457b6daded32ddc4ec3a5a21e34b9af8dcd7d190a5a7833fa8a7ed53b31206'
    }

    get asV1(): {message: Uint8Array} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class PhragmenElectionCleanDefunctVotersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PhragmenElection.clean_defunct_voters')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
     *  deposit of the removed voters are returned.
     * 
     *  This is an root function to be used only for cleaning the state.
     * 
     *  The dispatch origin of this call must be root.
     * 
     *  # <weight>
     *  The total number of voters and those that are defunct must be provided as witness data.
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('PhragmenElection.clean_defunct_voters') === '8279e35309d0c9a5d36cd12cce19e58fef95829d4096e23fe93a055a47afd8a0'
    }

    /**
     *  Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
     *  deposit of the removed voters are returned.
     * 
     *  This is an root function to be used only for cleaning the state.
     * 
     *  The dispatch origin of this call must be root.
     * 
     *  # <weight>
     *  The total number of voters and those that are defunct must be provided as witness data.
     *  # </weight>
     */
    get asV803(): {numVoters: number, numDefunct: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class PhragmenElectionRemoveMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PhragmenElection.remove_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a particular member from the set. This is effective immediately and the bond of
     *  the outgoing member is slashed.
     * 
     *  If a runner-up is available, then the best runner-up will be removed and replaces the
     *  outgoing member. Otherwise, a new phragmen election is started.
     * 
     *  The dispatch origin of this call must be root.
     * 
     *  Note that this does not affect the designated block number of the next election.
     * 
     *  # <weight>
     *  If we have a replacement, we use a small weight. Else, since this is a root call and
     *  will go into phragmen, we assume full block for now.
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('PhragmenElection.remove_member') === '8f953115e82b1180527569f88641e39ddd7c750a04a3e0ab23cb9466f32e4a9b'
    }

    /**
     *  Remove a particular member from the set. This is effective immediately and the bond of
     *  the outgoing member is slashed.
     * 
     *  If a runner-up is available, then the best runner-up will be removed and replaces the
     *  outgoing member. Otherwise, a new phragmen election is started.
     * 
     *  The dispatch origin of this call must be root.
     * 
     *  Note that this does not affect the designated block number of the next election.
     * 
     *  # <weight>
     *  If we have a replacement, we use a small weight. Else, since this is a root call and
     *  will go into phragmen, we assume full block for now.
     *  # </weight>
     */
    get asV803(): {who: v803.LookupSource, hasReplacement: boolean} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove a particular member from the set. This is effective immediately and the bond of
     * the outgoing member is slashed.
     * 
     * If a runner-up is available, then the best runner-up will be removed and replaces the
     * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
     * started, else, nothing happens.
     * 
     * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
     * it is returned.
     * 
     * The dispatch origin of this call must be root.
     * 
     * Note that this does not affect the designated block number of the next election.
     * 
     * # <weight>
     * If we have a replacement, we use a small weight. Else, since this is a root call and
     * will go into phragmen, we assume full block for now.
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('PhragmenElection.remove_member') === '4658a02672325035753fdb0154d8e923704ece127f1aa5e667a5fe274adc6678'
    }

    /**
     * Remove a particular member from the set. This is effective immediately and the bond of
     * the outgoing member is slashed.
     * 
     * If a runner-up is available, then the best runner-up will be removed and replaces the
     * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
     * started, else, nothing happens.
     * 
     * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
     * it is returned.
     * 
     * The dispatch origin of this call must be root.
     * 
     * Note that this does not affect the designated block number of the next election.
     * 
     * # <weight>
     * If we have a replacement, we use a small weight. Else, since this is a root call and
     * will go into phragmen, we assume full block for now.
     * # </weight>
     */
    get asV958(): {who: v958.MultiAddress, slashBond: boolean, rerunElection: boolean} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }
}

export class PhragmenElectionRemoveVoterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PhragmenElection.remove_voter')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove `origin` as a voter.
     * 
     *  This removes the lock and returns the deposit.
     * 
     *  The dispatch origin of this call must be signed and be a voter.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('PhragmenElection.remove_voter') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Remove `origin` as a voter.
     * 
     *  This removes the lock and returns the deposit.
     * 
     *  The dispatch origin of this call must be signed and be a voter.
     */
    get asV803(): null {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class PhragmenElectionRenounceCandidacyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PhragmenElection.renounce_candidacy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Renounce one's intention to be a candidate for the next election round. 3 potential
     *  outcomes exist:
     * 
     *  - `origin` is a candidate and not elected in any set. In this case, the deposit is
     *    unreserved, returned and origin is removed as a candidate.
     *  - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
     *    origin is removed as a runner-up.
     *  - `origin` is a current member. In this case, the deposit is unreserved and origin is
     *    removed as a member, consequently not being a candidate for the next round anymore.
     *    Similar to [`remove_members`], if replacement runners exists, they are immediately
     *    used. If the prime is renouncing, then no prime will exist until the next round.
     * 
     *  The dispatch origin of this call must be signed, and have one of the above roles.
     * 
     *  # <weight>
     *  The type of renouncing must be provided as witness data.
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('PhragmenElection.renounce_candidacy') === '891a3ff219ab8817cfffbcd0ed48578a0fd96440dc2292a0cde84a40439f7fbe'
    }

    /**
     *  Renounce one's intention to be a candidate for the next election round. 3 potential
     *  outcomes exist:
     * 
     *  - `origin` is a candidate and not elected in any set. In this case, the deposit is
     *    unreserved, returned and origin is removed as a candidate.
     *  - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
     *    origin is removed as a runner-up.
     *  - `origin` is a current member. In this case, the deposit is unreserved and origin is
     *    removed as a member, consequently not being a candidate for the next round anymore.
     *    Similar to [`remove_members`], if replacement runners exists, they are immediately
     *    used. If the prime is renouncing, then no prime will exist until the next round.
     * 
     *  The dispatch origin of this call must be signed, and have one of the above roles.
     * 
     *  # <weight>
     *  The type of renouncing must be provided as witness data.
     *  # </weight>
     */
    get asV803(): {renouncing: v803.Renouncing} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class PhragmenElectionSubmitCandidacyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PhragmenElection.submit_candidacy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Submit oneself for candidacy. A fixed amount of deposit is recorded.
     * 
     *  All candidates are wiped at the end of the term. They either become a member/runner-up,
     *  or leave the system while their deposit is slashed.
     * 
     *  The dispatch origin of this call must be signed.
     * 
     *  ### Warning
     * 
     *  Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
     *  to get their deposit back. Losing the spot in an election will always lead to a slash.
     * 
     *  # <weight>
     *  The number of current candidates must be provided as witness data.
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('PhragmenElection.submit_candidacy') === 'f9d2bc9f755e33c27d34db4c3b063daa9e2490111d35f89ea1995d74e59b1819'
    }

    /**
     *  Submit oneself for candidacy. A fixed amount of deposit is recorded.
     * 
     *  All candidates are wiped at the end of the term. They either become a member/runner-up,
     *  or leave the system while their deposit is slashed.
     * 
     *  The dispatch origin of this call must be signed.
     * 
     *  ### Warning
     * 
     *  Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
     *  to get their deposit back. Losing the spot in an election will always lead to a slash.
     * 
     *  # <weight>
     *  The number of current candidates must be provided as witness data.
     *  # </weight>
     */
    get asV803(): {candidateCount: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class PhragmenElectionVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PhragmenElection.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Vote for a set of candidates for the upcoming round of election. This can be called to
     *  set the initial votes, or update already existing votes.
     * 
     *  Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
     *  reserved. The deposit is based on the number of votes and can be updated over time.
     * 
     *  The `votes` should:
     *    - not be empty.
     *    - be less than the number of possible candidates. Note that all current members and
     *      runners-up are also automatically candidates for the next round.
     * 
     *  If `value` is more than `who`'s total balance, then the maximum of the two is used.
     * 
     *  The dispatch origin of this call must be signed.
     * 
     *  ### Warning
     * 
     *  It is the responsibility of the caller to **NOT** place all of their balance into the
     *  lock and keep some for further operations.
     * 
     *  # <weight>
     *  We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less.
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('PhragmenElection.vote') === '75939c25de1c96145b5d2d4bc8627a3fc22299f0e1f1f6f0709e54e884796bda'
    }

    /**
     *  Vote for a set of candidates for the upcoming round of election. This can be called to
     *  set the initial votes, or update already existing votes.
     * 
     *  Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
     *  reserved. The deposit is based on the number of votes and can be updated over time.
     * 
     *  The `votes` should:
     *    - not be empty.
     *    - be less than the number of possible candidates. Note that all current members and
     *      runners-up are also automatically candidates for the next round.
     * 
     *  If `value` is more than `who`'s total balance, then the maximum of the two is used.
     * 
     *  The dispatch origin of this call must be signed.
     * 
     *  ### Warning
     * 
     *  It is the responsibility of the caller to **NOT** place all of their balance into the
     *  lock and keep some for further operations.
     * 
     *  # <weight>
     *  We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less.
     *  # </weight>
     */
    get asV803(): {votes: Uint8Array[], value: bigint} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmExecuteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.execute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Execute an XCM message from a local, signed, origin.
     * 
     *  An event is deposited indicating whether `msg` could be executed completely or only
     *  partially.
     * 
     *  No more than `max_weight` will be used in its attempted execution. If this is less than the
     *  maximum amount of weight that the message could take to be executed, then no execution
     *  attempt will be made.
     * 
     *  NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     *  to completion; only that *some* of it was executed.
     */
    get isV1(): boolean {
        return this._chain.getCallHash('PolkadotXcm.execute') === 'df2dfbde05a8ace8b2a2ddf274c7229a888f9eb53c9e8576e045c819642e9aea'
    }

    /**
     *  Execute an XCM message from a local, signed, origin.
     * 
     *  An event is deposited indicating whether `msg` could be executed completely or only
     *  partially.
     * 
     *  No more than `max_weight` will be used in its attempted execution. If this is less than the
     *  maximum amount of weight that the message could take to be executed, then no execution
     *  attempt will be made.
     * 
     *  NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     *  to completion; only that *some* of it was executed.
     */
    get asV1(): {message: v1.Xcm, maxWeight: bigint} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Execute an XCM message from a local, signed, origin.
     * 
     *  An event is deposited indicating whether `msg` could be executed completely or only
     *  partially.
     * 
     *  No more than `max_weight` will be used in its attempted execution. If this is less than the
     *  maximum amount of weight that the message could take to be executed, then no execution
     *  attempt will be made.
     * 
     *  NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     *  to completion; only that *some* of it was executed.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('PolkadotXcm.execute') === '1ffde01afb18b1a97929d4a10da3c986b82c27846dbac20bc988ae3c255b1cba'
    }

    /**
     *  Execute an XCM message from a local, signed, origin.
     * 
     *  An event is deposited indicating whether `msg` could be executed completely or only
     *  partially.
     * 
     *  No more than `max_weight` will be used in its attempted execution. If this is less than the
     *  maximum amount of weight that the message could take to be executed, then no execution
     *  attempt will be made.
     * 
     *  NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     *  to completion; only that *some* of it was executed.
     */
    get asV902(): {message: v902.VersionedXcm, maxWeight: bigint} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('PolkadotXcm.execute') === '41f7d0295efed5db73229cbd1e9f1fdc0e7f9e159af3b17a10880e74bcdb3ad4'
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get asV906(): {message: v906.Type_257, maxWeight: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('PolkadotXcm.execute') === 'c6251691ab3319ecee95442d381c308f9ada155e423798c908cbd6b063aa26b4'
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get asV926(): {message: v926.Type_270, maxWeight: bigint} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('PolkadotXcm.execute') === '411d5e9bce7727b0b767af3f3f77a5cbe27fe9dcd7cdfca4c3ad0d0c05ac13e1'
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get asV970(): {message: v970.Type_358, maxWeight: bigint} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('PolkadotXcm.execute') === 'a1da862b5d9db8fd6f3072da00ea4e66052f97b5dcfb87e58d49ca1fd1f1ef90'
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get asV972(): {message: v972.Type_365, maxWeight: v972.Weight} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmForceDefaultXcmVersionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.force_default_xcm_version')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     * 
     * - `origin`: Must be Root.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_default_xcm_version') === 'd4bcd64cc4c940eafd14296ec6cbfb7d27e4ca42a4c7dab4c0b89f6c8102257e'
    }

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     * 
     * - `origin`: Must be Root.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     */
    get asV906(): {maybeXcmVersion: (number | undefined)} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmForceSubscribeVersionNotifyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.force_subscribe_version_notify')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_subscribe_version_notify') === 'f3f38b2278743e50bfd76c0f778560fb38a60c931275e9df42f2b9ce08c1d6fc'
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get asV906(): {location: v906.VersionedMultiLocation} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_subscribe_version_notify') === '56aed4b742721d521279794a608d71ae9db256750e90b7beb3d50a9d01aff0f9'
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get asV970(): {location: v970.VersionedMultiLocation} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_subscribe_version_notify') === '0448b7eed1a6d9cd0a489ea792df94cc3ce5a37e203f19b1a5a0c4516a8d696c'
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get asV972(): {location: v972.VersionedMultiLocation} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmForceUnsubscribeVersionNotifyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.force_unsubscribe_version_notify')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_unsubscribe_version_notify') === 'f3f38b2278743e50bfd76c0f778560fb38a60c931275e9df42f2b9ce08c1d6fc'
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get asV906(): {location: v906.VersionedMultiLocation} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_unsubscribe_version_notify') === '56aed4b742721d521279794a608d71ae9db256750e90b7beb3d50a9d01aff0f9'
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get asV970(): {location: v970.VersionedMultiLocation} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_unsubscribe_version_notify') === '0448b7eed1a6d9cd0a489ea792df94cc3ce5a37e203f19b1a5a0c4516a8d696c'
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get asV972(): {location: v972.VersionedMultiLocation} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmForceXcmVersionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.force_xcm_version')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be Root.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_xcm_version') === '3bdd3ba3db54facd962462ff1c2c0ede1b428cf9119b36a4e96fa86916145f75'
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be Root.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get asV906(): {location: v906.V1MultiLocation, xcmVersion: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be Root.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_xcm_version') === '855b9a66c3d6c203c5e887917dc681372ed5d32210a8c6cc86c7d5f227944d9c'
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be Root.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get asV970(): {location: v970.V1MultiLocation, xcmVersion: number} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be Root.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('PolkadotXcm.force_xcm_version') === '998b5a56e7662d76955b41c2526c2219fe8304fec6501afa115db1bd705e7ff6'
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be Root.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get asV972(): {location: v972.V3MultiLocation, xcmVersion: number} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmLimitedReserveTransferAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.limited_reserve_transfer_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     * a notification XCM.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('PolkadotXcm.limited_reserve_transfer_assets') === '3c203a3f95b9fe53b8c376802c4fe60fa6077815af7432dcd2a3e458169a5d2a'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     * a notification XCM.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asV908(): {dest: v908.VersionedMultiLocation, beneficiary: v908.VersionedMultiLocation, assets: v908.VersionedMultiAssets, feeAssetItem: number, weightLimit: v908.V2WeightLimit} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('PolkadotXcm.limited_reserve_transfer_assets') === '1818300d2dec2685942619973f1ec81b7ecf2b979534f1965b98b7b6c9d833ea'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asV970(): {dest: v970.VersionedMultiLocation, beneficiary: v970.VersionedMultiLocation, assets: v970.VersionedMultiAssets, feeAssetItem: number, weightLimit: v970.V2WeightLimit} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('PolkadotXcm.limited_reserve_transfer_assets') === 'c5f45c1775bd92c7b425f46c92a6891334f7df5ae2518cd2c0a106447da3bbd9'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asV972(): {dest: v972.VersionedMultiLocation, beneficiary: v972.VersionedMultiLocation, assets: v972.VersionedMultiAssets, feeAssetItem: number, weightLimit: v972.V3WeightLimit} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmLimitedTeleportAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.limited_teleport_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *   `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('PolkadotXcm.limited_teleport_assets') === '3c203a3f95b9fe53b8c376802c4fe60fa6077815af7432dcd2a3e458169a5d2a'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *   `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asV908(): {dest: v908.VersionedMultiLocation, beneficiary: v908.VersionedMultiLocation, assets: v908.VersionedMultiAssets, feeAssetItem: number, weightLimit: v908.V2WeightLimit} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('PolkadotXcm.limited_teleport_assets') === '1818300d2dec2685942619973f1ec81b7ecf2b979534f1965b98b7b6c9d833ea'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asV970(): {dest: v970.VersionedMultiLocation, beneficiary: v970.VersionedMultiLocation, assets: v970.VersionedMultiAssets, feeAssetItem: number, weightLimit: v970.V2WeightLimit} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('PolkadotXcm.limited_teleport_assets') === 'c5f45c1775bd92c7b425f46c92a6891334f7df5ae2518cd2c0a106447da3bbd9'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asV972(): {dest: v972.VersionedMultiLocation, beneficiary: v972.VersionedMultiLocation, assets: v972.VersionedMultiAssets, feeAssetItem: number, weightLimit: v972.V3WeightLimit} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmReserveTransferAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.reserve_transfer_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     *  a notification XCM.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *    `dest` side.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `ReserveAssetDeposit { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get isV1(): boolean {
        return this._chain.getCallHash('PolkadotXcm.reserve_transfer_assets') === '3c069703413ed53ed30061e5da3bc55ab8fa9032fc014ba18afc7afe32930ebd'
    }

    /**
     *  Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     *  a notification XCM.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *    `dest` side.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `ReserveAssetDeposit { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get asV1(): {dest: v1.MultiLocation, beneficiary: v1.MultiLocation, assets: v1.MultiAsset[], destWeight: bigint} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     *  a notification XCM.
     * 
     *  Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *    `dest` side.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `ReserveAssetDeposited { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('PolkadotXcm.reserve_transfer_assets') === 'c4558a18f0400069c14aaa3575bad0bb84b99ac94f206e8ab02890276f174ff4'
    }

    /**
     *  Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     *  a notification XCM.
     * 
     *  Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *    `dest` side.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `ReserveAssetDeposited { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get asV902(): {dest: v902.VersionedMultiLocation, beneficiary: v902.VersionedMultiLocation, assets: v902.VersionedMultiAssets, feeAssetItem: number, destWeight: bigint} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     * a notification XCM.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('PolkadotXcm.reserve_transfer_assets') === '123b8170fa49ede01f38623e457f4e4d417c90cff5b93ced45a9eb8fe8e6ca2e'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     * a notification XCM.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get asV906(): {dest: v906.VersionedMultiLocation, beneficiary: v906.VersionedMultiLocation, assets: v906.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('PolkadotXcm.reserve_transfer_assets') === 'b79cf2a68b1db82f94409ee603047fcd82f4343b83df6736c115e3338c04cecc'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get asV970(): {dest: v970.VersionedMultiLocation, beneficiary: v970.VersionedMultiLocation, assets: v970.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('PolkadotXcm.reserve_transfer_assets') === 'ebd99cece75c1b0fc48830527bc513cf672b8d0c6c0c505498bba5c8c5e1617c'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get asV972(): {dest: v972.VersionedMultiLocation, beneficiary: v972.VersionedMultiLocation, assets: v972.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmSendCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.send')
        this._chain = ctx._chain
        this.call = call
    }

    get isV1(): boolean {
        return this._chain.getCallHash('PolkadotXcm.send') === '8fe0974e74c786d3f8bb01dc13650a419fe9b97da675546b666d5fe67e5722d0'
    }

    get asV1(): {dest: v1.MultiLocation, message: v1.Xcm} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    get isV902(): boolean {
        return this._chain.getCallHash('PolkadotXcm.send') === 'b9446b649ff7dbe4e0f16a4dbefc5f448b11996984d1113c46c0e449cd846f9f'
    }

    get asV902(): {dest: v902.VersionedMultiLocation, message: v902.VersionedXcm} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    get isV906(): boolean {
        return this._chain.getCallHash('PolkadotXcm.send') === '9ec4149ae6cee6240a6e2aa06a8ef90285e68be29dd0de109b35af7922311609'
    }

    get asV906(): {dest: v906.VersionedMultiLocation, message: v906.VersionedXcm} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    get isV926(): boolean {
        return this._chain.getCallHash('PolkadotXcm.send') === '3ca4beb317aeed3e0a00ae870ffd3bef841bb6f4e766db0b286c7fc5d8eef886'
    }

    get asV926(): {dest: v926.VersionedMultiLocation, message: v926.VersionedXcm} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('PolkadotXcm.send') === '23ee62671c78b4c334d1aac87969a94e2d7514e9e9acd1949878df4525736480'
    }

    get asV970(): {dest: v970.VersionedMultiLocation, message: v970.VersionedXcm} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    get isV972(): boolean {
        return this._chain.getCallHash('PolkadotXcm.send') === '9c814457e6c06e355f17d8e2e59924a734ef38dfc7852490ba89fd5b845b6f48'
    }

    get asV972(): {dest: v972.VersionedMultiLocation, message: v972.VersionedXcm} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class PolkadotXcmTeleportAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PolkadotXcm.teleport_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Teleport some assets from the local chain to some destination chain.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *    `dest` side.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get isV1(): boolean {
        return this._chain.getCallHash('PolkadotXcm.teleport_assets') === '3c069703413ed53ed30061e5da3bc55ab8fa9032fc014ba18afc7afe32930ebd'
    }

    /**
     *  Teleport some assets from the local chain to some destination chain.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *    `dest` side.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get asV1(): {dest: v1.MultiLocation, beneficiary: v1.MultiLocation, assets: v1.MultiAsset[], destWeight: bigint} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Teleport some assets from the local chain to some destination chain.
     * 
     *  Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *    `dest` side. May not be empty.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('PolkadotXcm.teleport_assets') === 'c4558a18f0400069c14aaa3575bad0bb84b99ac94f206e8ab02890276f174ff4'
    }

    /**
     *  Teleport some assets from the local chain to some destination chain.
     * 
     *  Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *    `dest` side. May not be empty.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get asV902(): {dest: v902.VersionedMultiLocation, beneficiary: v902.VersionedMultiLocation, assets: v902.VersionedMultiAssets, feeAssetItem: number, destWeight: bigint} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *   `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('PolkadotXcm.teleport_assets') === '123b8170fa49ede01f38623e457f4e4d417c90cff5b93ced45a9eb8fe8e6ca2e'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *   `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get asV906(): {dest: v906.VersionedMultiLocation, beneficiary: v906.VersionedMultiLocation, assets: v906.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('PolkadotXcm.teleport_assets') === 'b79cf2a68b1db82f94409ee603047fcd82f4343b83df6736c115e3338c04cecc'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get asV970(): {dest: v970.VersionedMultiLocation, beneficiary: v970.VersionedMultiLocation, assets: v970.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('PolkadotXcm.teleport_assets') === 'ebd99cece75c1b0fc48830527bc513cf672b8d0c6c0c505498bba5c8c5e1617c'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get asV972(): {dest: v972.VersionedMultiLocation, beneficiary: v972.VersionedMultiLocation, assets: v972.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class PreimageNotePreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Preimage.note_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Register a preimage on-chain.
     * 
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Preimage.note_preimage') === 'fb6f9f7fd683160ab20dcde42ca8f757bc13845dc544f497e534fcf19c270a46'
    }

    /**
     * Register a preimage on-chain.
     * 
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     */
    get asV926(): {bytes: Uint8Array} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }
}

export class PreimageRequestPreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Preimage.request_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     * 
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Preimage.request_preimage') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     * 
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     */
    get asV926(): {hash: Uint8Array} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }
}

export class PreimageUnnotePreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Preimage.unnote_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Clear an unrequested preimage from the runtime storage.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Preimage.unnote_preimage') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     * Clear an unrequested preimage from the runtime storage.
     */
    get asV926(): {hash: Uint8Array} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }
}

export class PreimageUnrequestPreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Preimage.unrequest_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Clear a previously made request for a preimage.
     * 
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Preimage.unrequest_preimage') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     * Clear a previously made request for a preimage.
     * 
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     */
    get asV926(): {hash: Uint8Array} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyAddProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.add_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Proxy.add_proxy') === '3d828769ff25d49a46b447eb69a2c7dc11bea111b5c4012433b962f40623ada2'
    }

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV908(): {delegate: Uint8Array, proxyType: v908.ProxyType, delay: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Proxy.add_proxy') === 'd152be1ddf901503c9eceb62a291629801f5818023f193780196f40d842edecb'
    }

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV926(): {delegate: Uint8Array, proxyType: v926.ProxyType, delay: number} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Proxy.add_proxy') === 'ad96e2da5e4bca9b60ac84b14eda5da432efc67de7464a24a8a0649fea986e4e'
    }

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     */
    get asV968(): {delegate: v968.MultiAddress, proxyType: v968.ProxyType, delay: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyAnnounceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.announce')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     * 
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     * 
     * No more than `MaxPending` announcements may be made at any one time.
     * 
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     * 
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Proxy.announce') === '886fe5248256b2372151aa5c936f9027a64929a3501efe231a22f1ee868cff3e'
    }

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     * 
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     * 
     * No more than `MaxPending` announcements may be made at any one time.
     * 
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     * 
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV908(): {real: Uint8Array, callHash: Uint8Array} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     * 
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     * 
     * No more than `MaxPending` announcements may be made at any one time.
     * 
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     * 
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Proxy.announce') === 'c23728433a6cb173c2a65cbc9181ec4751f3cbdd297a0bc057fe7e1dbcb72cfe'
    }

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     * 
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     * 
     * No more than `MaxPending` announcements may be made at any one time.
     * 
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     * 
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    get asV968(): {real: v968.MultiAddress, callHash: Uint8Array} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyAnonymousCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.anonymous')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     * Requires a `Signed` origin.
     * 
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     * 
     * Fails if there are insufficient funds to pay for deposit.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     * TODO: Might be over counting 1 read
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Proxy.anonymous') === '7e633d805023a01a80485d0ba2be7efd35ec6752534c2d36fbafc0fe53ca4df1'
    }

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     * Requires a `Signed` origin.
     * 
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     * 
     * Fails if there are insufficient funds to pay for deposit.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     * TODO: Might be over counting 1 read
     */
    get asV908(): {proxyType: v908.ProxyType, delay: number, index: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     * Requires a `Signed` origin.
     * 
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     * 
     * Fails if there are insufficient funds to pay for deposit.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     * TODO: Might be over counting 1 read
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Proxy.anonymous') === 'a99c1549bcafa767af749875605607d14f846c5b730f675c6f552b1663327780'
    }

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     * Requires a `Signed` origin.
     * 
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     * 
     * Fails if there are insufficient funds to pay for deposit.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     * TODO: Might be over counting 1 read
     */
    get asV926(): {proxyType: v926.ProxyType, delay: number, index: number} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyCreatePureCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.create_pure')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     * Requires a `Signed` origin.
     * 
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     * 
     * Fails if there are insufficient funds to pay for deposit.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Proxy.create_pure') === 'a99c1549bcafa767af749875605607d14f846c5b730f675c6f552b1663327780'
    }

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     * Requires a `Signed` origin.
     * 
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     * 
     * Fails if there are insufficient funds to pay for deposit.
     */
    get asV968(): {proxyType: v968.ProxyType, delay: number, index: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyKillAnonymousCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.kill_anonymous')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Removes a previously spawned anonymous proxy.
     * 
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     * 
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `anonymous` with corresponding parameters.
     * 
     * - `spawner`: The account that originally called `anonymous` to create this account.
     * - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `anonymous`.
     * - `height`: The height of the chain when the call to `anonymous` was processed.
     * - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.
     * 
     * Fails with `NoPermission` in case the caller is not a previously created anonymous
     * account whose `anonymous` call has corresponding parameters.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Proxy.kill_anonymous') === 'd7dcf3fd8893fe8fc55d3b0a9ed52c084d05de906b2e773d84af24aca264512b'
    }

    /**
     * Removes a previously spawned anonymous proxy.
     * 
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     * 
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `anonymous` with corresponding parameters.
     * 
     * - `spawner`: The account that originally called `anonymous` to create this account.
     * - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `anonymous`.
     * - `height`: The height of the chain when the call to `anonymous` was processed.
     * - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.
     * 
     * Fails with `NoPermission` in case the caller is not a previously created anonymous
     * account whose `anonymous` call has corresponding parameters.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV908(): {spawner: Uint8Array, proxyType: v908.ProxyType, index: number, height: number, extIndex: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Removes a previously spawned anonymous proxy.
     * 
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     * 
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `anonymous` with corresponding parameters.
     * 
     * - `spawner`: The account that originally called `anonymous` to create this account.
     * - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `anonymous`.
     * - `height`: The height of the chain when the call to `anonymous` was processed.
     * - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.
     * 
     * Fails with `NoPermission` in case the caller is not a previously created anonymous
     * account whose `anonymous` call has corresponding parameters.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Proxy.kill_anonymous') === 'c976d70352f028afb70c98d62e906641bd3b3905deff896cfa228ca9d1e2f26b'
    }

    /**
     * Removes a previously spawned anonymous proxy.
     * 
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     * 
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `anonymous` with corresponding parameters.
     * 
     * - `spawner`: The account that originally called `anonymous` to create this account.
     * - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `anonymous`.
     * - `height`: The height of the chain when the call to `anonymous` was processed.
     * - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.
     * 
     * Fails with `NoPermission` in case the caller is not a previously created anonymous
     * account whose `anonymous` call has corresponding parameters.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV926(): {spawner: Uint8Array, proxyType: v926.ProxyType, index: number, height: number, extIndex: number} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyKillPureCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.kill_pure')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Removes a previously spawned pure proxy.
     * 
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     * 
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     * 
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     * 
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Proxy.kill_pure') === '272175f6504a57acbe6bee7d843d07dc041e7337fdf1bce37b24529bd0355a8c'
    }

    /**
     * Removes a previously spawned pure proxy.
     * 
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     * 
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     * 
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     * 
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     */
    get asV968(): {spawner: v968.MultiAddress, proxyType: v968.ProxyType, index: number, height: number, extIndex: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '041a3265363f794f66f7051970388d6413ae873702f611c80212c676ec406550'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV908(): {real: Uint8Array, forceProxyType: (v908.ProxyType | undefined), call: v908.Call} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV910(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'd5a4c8026e4180dd23147ef3a076c2fb39021ef357ffca4b94591b59b369c2f8'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV910(): {real: Uint8Array, forceProxyType: (v910.ProxyType | undefined), call: v910.Call} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV912(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'ea0ac382e421f7ce727fc5ba64c569c60f6643f2d69eded19df7086c30e8038b'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV912(): {real: Uint8Array, forceProxyType: (v912.ProxyType | undefined), call: v912.Call} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV914(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '77c2221a9ba334b84f71f500902cc7f47f01c9f9988d14abf0aac324ad709308'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV914(): {real: Uint8Array, forceProxyType: (v914.ProxyType | undefined), call: v914.Call} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV915(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'db1c3b4b31217980754bebe81f7e1a43d99961753288d17d3b32578af61acb72'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV915(): {real: Uint8Array, forceProxyType: (v915.ProxyType | undefined), call: v915.Call} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '22c5e1e6305a7226a3efded33fe07a514a217d3e1bda5fc0ba705af649d774c3'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV916(): {real: Uint8Array, forceProxyType: (v916.ProxyType | undefined), call: v916.Call} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'f8b68d66c13b4cb3b330b6087b94f4218da16b66a756eb732be46d87f5612099'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV918(): {real: Uint8Array, forceProxyType: (v918.ProxyType | undefined), call: v918.Call} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '3b587e596568ccc2872819087adc7b01f267ba6187b3aa426a743b250fde640d'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV920(): {real: Uint8Array, forceProxyType: (v920.ProxyType | undefined), call: v920.Call} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '95f603ebf086b136c5a56936961eec57d4ba132d6645569cb094f10207bb74c2'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV922(): {real: Uint8Array, forceProxyType: (v922.ProxyType | undefined), call: v922.Call} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'c0e64d433d46854bb634a6a4855768f7e7f893f30e0d462b88abf5ef1ee54d57'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV923(): {real: Uint8Array, forceProxyType: (v923.ProxyType | undefined), call: v923.Call} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '6e2ca84406d0e1c06c1a19ac03f34b31dac3d263d533298177bd43ec92ce3f6d'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV926(): {real: Uint8Array, forceProxyType: (v926.ProxyType | undefined), call: v926.Call} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '0704c2c4ea231decba37b3624728a4b7e9d9c10e7c2e27134ae3bd2835fb809a'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV927(): {real: Uint8Array, forceProxyType: (v927.ProxyType | undefined), call: v927.Call} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '3c876bc51936cf2699d245fdfcf77c93771c254d28052eaaae54994d25e1539c'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV930(): {real: Uint8Array, forceProxyType: (v930.ProxyType | undefined), call: v930.Call} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '2e7941c6b1635f45add19ede088b35928baccb3cc11f65db90907690b3a8a308'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV932(): {real: Uint8Array, forceProxyType: (v932.ProxyType | undefined), call: v932.Call} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '73dde2f40129e5d7c5f867778ec667ed67be2cf7475d91edaa97cae6ea743c5b'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV940(): {real: Uint8Array, forceProxyType: (v940.ProxyType | undefined), call: v940.Call} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'd7eb102f96fd6006ccc711edfe495348a7b4b60db1148c1f79ac488e7c8b1156'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV942(): {real: Uint8Array, forceProxyType: (v942.ProxyType | undefined), call: v942.Call} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'fdf6830e2d20d3d79932e667f9443008b24a8e7dc638e221f58c7111bc81ddc8'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV944(): {real: Uint8Array, forceProxyType: (v944.ProxyType | undefined), call: v944.Call} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '577d4bd311b78e794adb1dfa488932c999de9e35c205a81bd6f66ce6a24da51a'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV946(): {real: Uint8Array, forceProxyType: (v946.ProxyType | undefined), call: v946.Call} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'b15fda32945904007d3c5249c49f3341b9f6094a6f1f8b177b3d9b545e642e64'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV948(): {real: Uint8Array, forceProxyType: (v948.ProxyType | undefined), call: v948.Call} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '3272b68220244733447cb3ecfe7a295f2f22cf8ae4f7ea0d74db12afc61210dc'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV952(): {real: Uint8Array, forceProxyType: (v952.ProxyType | undefined), call: v952.Call} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '087957a605eb5b01c394c044e75a6b912104d2635d206ee902653cdc759ae0ad'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV954(): {real: Uint8Array, forceProxyType: (v954.ProxyType | undefined), call: v954.Call} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '0385b2e0d3f9e444210a207b563b187ad101c290723029babcec1a8b0b240cf6'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV956(): {real: Uint8Array, forceProxyType: (v956.ProxyType | undefined), call: v956.Call} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '06e86691a8d6150183ddcff3ea3e7710a9e551e7a56c51b2177cba688f08e96b'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV958(): {real: Uint8Array, forceProxyType: (v958.ProxyType | undefined), call: v958.Call} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '73d8748343e681a2ba9eb47d80d15bcce14f0585fb7a12ce92bb85d4ea8f3103'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV962(): {real: Uint8Array, forceProxyType: (v962.ProxyType | undefined), call: v962.Call} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'eca3d270667c5ea1bf57d02690892944709ac66ed720749b2015a2b3c775b569'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV964(): {real: Uint8Array, forceProxyType: (v964.ProxyType | undefined), call: v964.Call} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '57bade415a0fad556ea4d9d181645313b869cf1718604137d7c98346a4b78719'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV967(): {real: Uint8Array, forceProxyType: (v967.ProxyType | undefined), call: v967.Call} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '1364ef6de935e5252816827f5bcc8e62e267d9a1ff8af8ea2be3eb3a8f7bcf59'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV968(): {real: v968.MultiAddress, forceProxyType: (v968.ProxyType | undefined), call: v968.Call} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'c3fb7b8f5d6fcbd01cbf489666ce220793c95ef326abd56d5fdf7ccce844af23'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV970(): {real: v970.MultiAddress, forceProxyType: (v970.ProxyType | undefined), call: v970.Call} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '7634e0f415f0b01653beab090f5f42ad653cf9506dd1ad3454c0c5b15e26a223'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV972(): {real: v972.MultiAddress, forceProxyType: (v972.ProxyType | undefined), call: v972.Call} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyProxyAnnouncedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.proxy_announced')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'c25b1ebdbdec3db68de1aa2116d1f14e0f7571eca4d684b6477d77c47b05ff1e'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV908(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v908.ProxyType | undefined), call: v908.Call} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV910(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'bfc18eb2c5ac373350549c687998e623648163b227a00ab6eb5037c26f83227b'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV910(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v910.ProxyType | undefined), call: v910.Call} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV912(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'fecff00cc90209b449908b9b468ea7f1d061050a0892bb0d53661cbcb400af9e'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV912(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v912.ProxyType | undefined), call: v912.Call} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV914(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'ac141507ccaef26d8775baab2a37b77d80c3e0e86ef4bc6d5e2cff60c9ff2e1b'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV914(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v914.ProxyType | undefined), call: v914.Call} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV915(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '896bc1e8a224c93e35f8912ca46162f84dcdb93c23215b661961728493f7ebbb'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV915(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v915.ProxyType | undefined), call: v915.Call} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '8a6b4dbec2c08269f4578e810eac121aef00899f4b9350006fd048f2b214b1d7'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV916(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v916.ProxyType | undefined), call: v916.Call} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'a58731e3590428c10ec9d5aab416a49bb9de33af4541bd789d05e015f08d96e5'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV918(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v918.ProxyType | undefined), call: v918.Call} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'a8efe655d0fcd8f30079efa82dc2b92ca960464b58c0d6f94d957b33112eb501'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV920(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v920.ProxyType | undefined), call: v920.Call} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '081208de2dda58e72fb8cc04e1393de689d7bb3112c2a79409ae07761acb5238'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV922(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v922.ProxyType | undefined), call: v922.Call} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '48485ea89f8079de8a3e17ee9a3551804f95784cc99be73f4fa2c552b10755e4'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV923(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v923.ProxyType | undefined), call: v923.Call} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '9fced8669618941cc67a80c46ad89f953d8025d408ecc521999911c1c855caaf'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV926(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v926.ProxyType | undefined), call: v926.Call} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '6a398198666cf08755857e74118b4e99b6a549f79862f727693962042d9d02d6'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV927(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v927.ProxyType | undefined), call: v927.Call} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'aec7b5c1b57bb88dbcba7322903737b72977bf1cdef86d6a87d4958d614d1437'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV930(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v930.ProxyType | undefined), call: v930.Call} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '9b154759e95650acd4d8fa5530c9ef5ee5c4f74c52ba8c4c6e6ace4f4bde684b'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV932(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v932.ProxyType | undefined), call: v932.Call} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'e658f18e1670fe686676561a8c861a15551cdb3dda0e2f964c3f1903def955b3'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV940(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v940.ProxyType | undefined), call: v940.Call} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '23a543d0f15388543b928a199393db7d26dcdb5c51d4ed6ede2a06c396f37cd5'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV942(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v942.ProxyType | undefined), call: v942.Call} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '892f4602de3a37230f1bd2957021b4949af617d52f576d424f1dfdc51ad095ac'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV944(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v944.ProxyType | undefined), call: v944.Call} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '90bef5bad99f382523a197eb27819c806bbc57cfdd84b4d17d08bbb4767e86e9'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV946(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v946.ProxyType | undefined), call: v946.Call} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '75ef28015ceb3ce476da4f305e16090da97e1f935cccce59c10c94e00646d94d'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV948(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v948.ProxyType | undefined), call: v948.Call} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '22a3870a0978d67193775bb8b4fcb0b8c5b46fdb500f762aeb89a29053d356d6'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV952(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v952.ProxyType | undefined), call: v952.Call} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'f3657be02918f57e89c7368a4cc39312aa32df89331f377272a07c3cdd39dc1b'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV954(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v954.ProxyType | undefined), call: v954.Call} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '9528dfe3ad6588a8924acc03b27ad7be228f66b15c0b50b6c0bcc9e4e404c96f'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV956(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v956.ProxyType | undefined), call: v956.Call} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'a939bb117b6b9255afe3b6067d3b1f1332e318f91cd66b7914e5c7d064d1fd4d'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV958(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v958.ProxyType | undefined), call: v958.Call} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '84465bff8374b70ef7224c8da449a4ca36b9d668f66f194ed6a30f1a62531528'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV962(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v962.ProxyType | undefined), call: v962.Call} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '6106cd804e5a7a83d951014649794ab18701861877cc0d41698df5d3c867b83e'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV964(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v964.ProxyType | undefined), call: v964.Call} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '21a78365942853926304e45112933b030fa93c554de1b79076bddd859afb4f85'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV967(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v967.ProxyType | undefined), call: v967.Call} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '652cc9c8fb35e82413e47eb49de7b3b245888f194531d77b6523d1a6c491030e'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV968(): {delegate: v968.MultiAddress, real: v968.MultiAddress, forceProxyType: (v968.ProxyType | undefined), call: v968.Call} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '4c49d6d568a0ed2d5d80e6d5700e1a3e5b5ce7d4b18e844844f0b11cf2ae8c7c'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV970(): {delegate: v970.MultiAddress, real: v970.MultiAddress, forceProxyType: (v970.ProxyType | undefined), call: v970.Call} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '706bb0b81a36e4a40c31c695c3303f2c5854e5846783b9a28d0e510e286e51a8'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV972(): {delegate: v972.MultiAddress, real: v972.MultiAddress, forceProxyType: (v972.ProxyType | undefined), call: v972.Call} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyRejectAnnouncementCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.reject_announcement')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the given announcement of a delegate.
     * 
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Proxy.reject_announcement') === '717e6dbb2911f49e34a3b48c48c86b40495423ab31d5b45f0062629c73057f2b'
    }

    /**
     * Remove the given announcement of a delegate.
     * 
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV908(): {delegate: Uint8Array, callHash: Uint8Array} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove the given announcement of a delegate.
     * 
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Proxy.reject_announcement') === 'ca29e00f637c9222a2ff4695b4a08b3fea357c5c63cef480a76e3ac535f905a6'
    }

    /**
     * Remove the given announcement of a delegate.
     * 
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     */
    get asV968(): {delegate: v968.MultiAddress, callHash: Uint8Array} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyRemoveAnnouncementCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.remove_announcement')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a given announcement.
     * 
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Proxy.remove_announcement') === '886fe5248256b2372151aa5c936f9027a64929a3501efe231a22f1ee868cff3e'
    }

    /**
     * Remove a given announcement.
     * 
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV908(): {real: Uint8Array, callHash: Uint8Array} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove a given announcement.
     * 
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Proxy.remove_announcement') === 'c23728433a6cb173c2a65cbc9181ec4751f3cbdd297a0bc057fe7e1dbcb72cfe'
    }

    /**
     * Remove a given announcement.
     * 
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     */
    get asV968(): {real: v968.MultiAddress, callHash: Uint8Array} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyRemoveProxiesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.remove_proxies')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unregister all proxy accounts for the sender.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * WARNING: This may be called on accounts created by `anonymous`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Proxy.remove_proxies') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Unregister all proxy accounts for the sender.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * WARNING: This may be called on accounts created by `anonymous`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV908(): null {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyRemoveProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.remove_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unregister a proxy account for the sender.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Proxy.remove_proxy') === '3d828769ff25d49a46b447eb69a2c7dc11bea111b5c4012433b962f40623ada2'
    }

    /**
     * Unregister a proxy account for the sender.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV908(): {delegate: Uint8Array, proxyType: v908.ProxyType, delay: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Unregister a proxy account for the sender.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Proxy.remove_proxy') === 'd152be1ddf901503c9eceb62a291629801f5818023f193780196f40d842edecb'
    }

    /**
     * Unregister a proxy account for the sender.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV926(): {delegate: Uint8Array, proxyType: v926.ProxyType, delay: number} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Unregister a proxy account for the sender.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Proxy.remove_proxy') === 'ad96e2da5e4bca9b60ac84b14eda5da432efc67de7464a24a8a0649fea986e4e'
    }

    /**
     * Unregister a proxy account for the sender.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     */
    get asV968(): {delegate: v968.MultiAddress, proxyType: v968.ProxyType, delay: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpAddProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.add_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add proxy for parachain account
     *  - `delegate`: The delegate proxy account
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Salp.add_proxy') === '9ec5cb45a2094dc84b05b8efa493b4ab9653b4d8bfb16aaaf0f8c24f399cf366'
    }

    /**
     *  Add proxy for parachain account
     *  - `delegate`: The delegate proxy account
     */
    get asV900(): {delegate: Uint8Array} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpBatchRefundCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.batch_refund')
        this._chain = ctx._chain
        this.call = call
    }

    get isV901(): boolean {
        return this._chain.getCallHash('Salp.batch_refund') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    get asV901(): {index: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpBatchUnlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.batch_unlock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unlock the reserved vsToken/vsBond after fund success
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Salp.batch_unlock') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    /**
     *  Unlock the reserved vsToken/vsBond after fund success
     */
    get asV900(): {index: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpBuybackCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.buyback')
        this._chain = ctx._chain
        this.call = call
    }

    get isV952(): boolean {
        return this._chain.getCallHash('Salp.buyback') === 'd13cb91c3f61510beece366e7f7c2d0705f01d70f9bc28721d2437cd210a3372'
    }

    get asV952(): {value: bigint} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpConfirmContributeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.confirm_contribute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Confirm contribute
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Salp.confirm_contribute') === '73c766d78b79c8248e174a3f58f676410ac512b2a752afcc6f6f8df665b2be91'
    }

    /**
     *  Confirm contribute
     */
    get asV900(): {who: Uint8Array, index: number, isSuccess: boolean, messageId: Uint8Array} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpConfirmContributionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.confirm_contribution')
        this._chain = ctx._chain
        this.call = call
    }

    get isV972(): boolean {
        return this._chain.getCallHash('Salp.confirm_contribution') === 'bef8f7543dfaf827f16faeecf1ae77b01b3a27a17ca90af1a821e1cb820998fa'
    }

    get asV972(): {queryId: bigint, response: v972.V3Response} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpContinueFundCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.continue_fund')
        this._chain = ctx._chain
        this.call = call
    }

    get isV923(): boolean {
        return this._chain.getCallHash('Salp.continue_fund') === 'b450a76b5af092d262530626159d2368719cee5f7933c7d52e286318149b8be3'
    }

    get asV923(): {index: number, firstSlot: number, lastSlot: number} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpContributeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.contribute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Contribute to a crowd sale. This will transfer some balance over to fund a parachain
     *  slot. It will be withdrawable in two instances: the parachain becomes retired; or the
     *  slot is unable to be purchased and the timeout expires.
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Salp.contribute') === '11f816fbc09589b324bb9b6ccb1cbb9da0214658029dd8c4203a64c1573c4aed'
    }

    /**
     *  Contribute to a crowd sale. This will transfer some balance over to fund a parachain
     *  slot. It will be withdrawable in two instances: the parachain becomes retired; or the
     *  slot is unable to be purchased and the timeout expires.
     */
    get asV900(): {index: number, value: bigint} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpCreateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.create')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Create a new crowdloaning campaign for a parachain slot deposit for the current auction.
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Salp.create') === '3d763a8605093e9d98fb2f13dd22b643108a2405070a66a288bbc1ce11a2801e'
    }

    /**
     *  Create a new crowdloaning campaign for a parachain slot deposit for the current auction.
     */
    get asV900(): {index: number, cap: bigint, firstSlot: number, lastSlot: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpDissolveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.dissolve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a fund after the retirement period has ended and all funds have been returned.
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Salp.dissolve') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    /**
     *  Remove a fund after the retirement period has ended and all funds have been returned.
     */
    get asV900(): {index: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpDissolveRefundedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.dissolve_refunded')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a fund after the retirement period has ended and all funds have been returned.
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Salp.dissolve_refunded') === 'b450a76b5af092d262530626159d2368719cee5f7933c7d52e286318149b8be3'
    }

    /**
     * Remove a fund after the retirement period has ended and all funds have been returned.
     */
    get asV923(): {index: number, firstSlot: number, lastSlot: number} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpEditCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.edit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Edit the configuration for an in-progress crowdloan.
     * 
     *  Can only be called by Root origin.
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Salp.edit') === '0bdcdb54f292494db6bbf1645ed72bd9facea99c0190a2f846785e5e6f406ce2'
    }

    /**
     *  Edit the configuration for an in-progress crowdloan.
     * 
     *  Can only be called by Root origin.
     */
    get asV900(): {index: number, cap: bigint, firstSlot: number, lastSlot: number, fundStatus: (v900.FundStatus | undefined)} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Edit the configuration for an in-progress crowdloan.
     * 
     * Can only be called by Root origin.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Salp.edit') === '21ae6a8abf304ad7c4047428ff71c333ca9480ff89de29a4bd07d5ae161d12ca'
    }

    /**
     * Edit the configuration for an in-progress crowdloan.
     * 
     * Can only be called by Root origin.
     */
    get asV916(): {index: number, cap: bigint, raised: bigint, firstSlot: number, lastSlot: number, fundStatus: (v916.FundStatus | undefined)} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Edit the configuration for an in-progress crowdloan.
     * 
     * Can only be called by Root origin.
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Salp.edit') === '7d6d1e79dab2847166ccb7cad1aefa7cd2f415411ede65d506f2a59562822e6e'
    }

    /**
     * Edit the configuration for an in-progress crowdloan.
     * 
     * Can only be called by Root origin.
     */
    get asV923(): {index: number, cap: bigint, raised: bigint, firstSlot: number, lastSlot: number, fundStatus: (v923.FundStatus | undefined)} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpFundEndCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.fund_end')
        this._chain = ctx._chain
        this.call = call
    }

    get isV900(): boolean {
        return this._chain.getCallHash('Salp.fund_end') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    get asV900(): {index: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpFundFailCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.fund_fail')
        this._chain = ctx._chain
        this.call = call
    }

    get isV900(): boolean {
        return this._chain.getCallHash('Salp.fund_fail') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    get asV900(): {index: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpFundRetireCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.fund_retire')
        this._chain = ctx._chain
        this.call = call
    }

    get isV900(): boolean {
        return this._chain.getCallHash('Salp.fund_retire') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    get asV900(): {index: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpFundSuccessCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.fund_success')
        this._chain = ctx._chain
        this.call = call
    }

    get isV900(): boolean {
        return this._chain.getCallHash('Salp.fund_success') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    get asV900(): {index: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpMintCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.mint')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  transfer to parachain salp account
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Salp.mint') === 'a3bdd43eed59e7b65720eef9b2dfe72389ca71ac9dbe7fe2874438aae4f18886'
    }

    /**
     *  transfer to parachain salp account
     */
    get asV900(): {amount: bigint} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpRedeemCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.redeem')
        this._chain = ctx._chain
        this.call = call
    }

    get isV900(): boolean {
        return this._chain.getCallHash('Salp.redeem') === '11f816fbc09589b324bb9b6ccb1cbb9da0214658029dd8c4203a64c1573c4aed'
    }

    get asV900(): {index: number, value: bigint} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpRefundCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.refund')
        this._chain = ctx._chain
        this.call = call
    }

    get isV900(): boolean {
        return this._chain.getCallHash('Salp.refund') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    get asV900(): {index: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    get isV923(): boolean {
        return this._chain.getCallHash('Salp.refund') === '7e91eaa2f059737e535e761b673e0d5cef3d255dd6feba5725aa4aa60a155468'
    }

    get asV923(): {index: number, firstSlot: number, lastSlot: number, value: bigint} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpRemoveProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.remove_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add proxy for parachain account
     *  - `delegate`: The delegate proxy account
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Salp.remove_proxy') === '9ec5cb45a2094dc84b05b8efa493b4ab9653b4d8bfb16aaaf0f8c24f399cf366'
    }

    /**
     *  Add proxy for parachain account
     *  - `delegate`: The delegate proxy account
     */
    get asV900(): {delegate: Uint8Array} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpSetMultisigConfirmAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.set_multisig_confirm_account')
        this._chain = ctx._chain
        this.call = call
    }

    get isV915(): boolean {
        return this._chain.getCallHash('Salp.set_multisig_confirm_account') === '7fb7672b764b0a4f0c4910fddefec0709628843df7ad0073a97eede13c53ca92'
    }

    get asV915(): {account: Uint8Array} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpTransferStatemineAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.transfer_statemine_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * transfer asset to statemine
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Salp.transfer_statemine_assets') === 'e0a0ea7380eec0e3fe925479d7da80f6e23af8aa320678f7ec4817daf7be9257'
    }

    /**
     * transfer asset to statemine
     */
    get asV920(): {amount: bigint, assetId: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * transfer asset to statemine
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Salp.transfer_statemine_assets') === 'dee1b31b085b54da51e27f6f1a7333fc994698ed15608fba83f10caa139fd66b'
    }

    /**
     * transfer asset to statemine
     */
    get asV926(): {amount: bigint, assetId: number, dest: (Uint8Array | undefined)} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpUnlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.unlock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unlock the reserved vsToken/vsBond after fund success
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Salp.unlock') === '02cd16eba62d1217d4cb6a31d6568e8ad8fdc99a88200e787453e7eba24cad9e'
    }

    /**
     *  Unlock the reserved vsToken/vsBond after fund success
     */
    get asV900(): {who: Uint8Array, index: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpUnlockByVsbondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.unlock_by_vsbond')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Salp.unlock_by_vsbond') === '03a1564fabf165e68683b0a1ed7b20c56bfef44e5f0e5bdee44a862700056969'
    }

    get asV962(): {who: Uint8Array, vsbond: v962.CurrencyId} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpUnlockVstokenCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.unlock_vstoken')
        this._chain = ctx._chain
        this.call = call
    }

    get isV964(): boolean {
        return this._chain.getCallHash('Salp.unlock_vstoken') === 'b8a0d2208835f6ada60dd21cd93533d703777b3779109a7c6a2f26bad68c2f3b'
    }

    get asV964(): {who: Uint8Array} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpWithdrawCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Salp.withdraw')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Withdraw full balance of the parachain.
     *  - `index`: The parachain to whose crowdloan the contribution was made.
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Salp.withdraw') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    /**
     *  Withdraw full balance of the parachain.
     *  - `index`: The parachain to whose crowdloan the contribution was made.
     */
    get asV900(): {index: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteBatchMigrateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.batch_migrate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unlock the reserved vsToken/vsBond after fund success
     */
    get isV908(): boolean {
        return this._chain.getCallHash('SalpLite.batch_migrate') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    /**
     * Unlock the reserved vsToken/vsBond after fund success
     */
    get asV908(): {index: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteContinueFundCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.continue_fund')
        this._chain = ctx._chain
        this.call = call
    }

    get isV915(): boolean {
        return this._chain.getCallHash('SalpLite.continue_fund') === 'b450a76b5af092d262530626159d2368719cee5f7933c7d52e286318149b8be3'
    }

    get asV915(): {index: number, firstSlot: number, lastSlot: number} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteCreateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.create')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a new crowdloaning campaign for a parachain slot deposit for the current auction.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('SalpLite.create') === '3d763a8605093e9d98fb2f13dd22b643108a2405070a66a288bbc1ce11a2801e'
    }

    /**
     * Create a new crowdloaning campaign for a parachain slot deposit for the current auction.
     */
    get asV908(): {index: number, cap: bigint, firstSlot: number, lastSlot: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteDissolveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.dissolve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a fund after the retirement period has ended and all funds have been returned.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('SalpLite.dissolve') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    /**
     * Remove a fund after the retirement period has ended and all funds have been returned.
     */
    get asV908(): {index: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteDissolveRefundedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.dissolve_refunded')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a fund after the retirement period has ended and all funds have been returned.
     */
    get isV915(): boolean {
        return this._chain.getCallHash('SalpLite.dissolve_refunded') === 'b450a76b5af092d262530626159d2368719cee5f7933c7d52e286318149b8be3'
    }

    /**
     * Remove a fund after the retirement period has ended and all funds have been returned.
     */
    get asV915(): {index: number, firstSlot: number, lastSlot: number} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteEditCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.edit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Edit the configuration for an in-progress crowdloan.
     * 
     * Can only be called by Root origin.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('SalpLite.edit') === '0bdcdb54f292494db6bbf1645ed72bd9facea99c0190a2f846785e5e6f406ce2'
    }

    /**
     * Edit the configuration for an in-progress crowdloan.
     * 
     * Can only be called by Root origin.
     */
    get asV908(): {index: number, cap: bigint, firstSlot: number, lastSlot: number, fundStatus: (v908.FundStatus | undefined)} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Edit the configuration for an in-progress crowdloan.
     * 
     * Can only be called by Root origin.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('SalpLite.edit') === '3890e0f0c68c096442e36e5e2d19bdede876e59740c538213c617c666887a982'
    }

    /**
     * Edit the configuration for an in-progress crowdloan.
     * 
     * Can only be called by Root origin.
     */
    get asV916(): {index: number, cap: bigint, raised: bigint, firstSlot: number, lastSlot: number, fundStatus: (v916.Type_365 | undefined)} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteFundEndCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.fund_end')
        this._chain = ctx._chain
        this.call = call
    }

    get isV908(): boolean {
        return this._chain.getCallHash('SalpLite.fund_end') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    get asV908(): {index: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteFundFailCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.fund_fail')
        this._chain = ctx._chain
        this.call = call
    }

    get isV908(): boolean {
        return this._chain.getCallHash('SalpLite.fund_fail') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    get asV908(): {index: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteFundRetireCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.fund_retire')
        this._chain = ctx._chain
        this.call = call
    }

    get isV908(): boolean {
        return this._chain.getCallHash('SalpLite.fund_retire') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    get asV908(): {index: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteFundSuccessCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.fund_success')
        this._chain = ctx._chain
        this.call = call
    }

    get isV908(): boolean {
        return this._chain.getCallHash('SalpLite.fund_success') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    get asV908(): {index: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteIssueCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.issue')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Contribute to a crowd sale. This will transfer some balance over to fund a parachain
     * slot. It will be withdrawable in two instances: the parachain becomes retired; or the
     * slot is unable to be purchased and the timeout expires.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('SalpLite.issue') === '5147ce8d58d80149504821af18bc244b9b11a15d1b53912fd8deafcb49059603'
    }

    /**
     * Contribute to a crowd sale. This will transfer some balance over to fund a parachain
     * slot. It will be withdrawable in two instances: the parachain becomes retired; or the
     * slot is unable to be purchased and the timeout expires.
     */
    get asV908(): {who: Uint8Array, index: number, value: bigint, messageId: Uint8Array} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteRedeemCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.redeem')
        this._chain = ctx._chain
        this.call = call
    }

    get isV908(): boolean {
        return this._chain.getCallHash('SalpLite.redeem') === '11f816fbc09589b324bb9b6ccb1cbb9da0214658029dd8c4203a64c1573c4aed'
    }

    get asV908(): {index: number, value: bigint} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteRefundCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.refund')
        this._chain = ctx._chain
        this.call = call
    }

    get isV908(): boolean {
        return this._chain.getCallHash('SalpLite.refund') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    get asV908(): {index: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    get isV915(): boolean {
        return this._chain.getCallHash('SalpLite.refund') === '7e91eaa2f059737e535e761b673e0d5cef3d255dd6feba5725aa4aa60a155468'
    }

    get asV915(): {index: number, firstSlot: number, lastSlot: number, value: bigint} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteSetMultisigConfirmAccountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.set_multisig_confirm_account')
        this._chain = ctx._chain
        this.call = call
    }

    get isV915(): boolean {
        return this._chain.getCallHash('SalpLite.set_multisig_confirm_account') === '7fb7672b764b0a4f0c4910fddefec0709628843df7ad0073a97eede13c53ca92'
    }

    get asV915(): {account: Uint8Array} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }
}

export class SalpLiteWithdrawCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SalpLite.withdraw')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Withdraw full balance of the parachain.
     * - `index`: The parachain to whose crowdloan the contribution was made.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('SalpLite.withdraw') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    /**
     * Withdraw full balance of the parachain.
     * - `index`: The parachain to whose crowdloan the contribution was made.
     */
    get asV908(): {index: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerCancelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.cancel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel an anonymously scheduled task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.15 + 2.869 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 100 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Scheduler.cancel') === '4186e24556a58b04e04d6d697a530eedf78f255da1ba9d84df6511dd6d6465f7'
    }

    /**
     *  Cancel an anonymously scheduled task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.15 + 2.869 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 100 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV1(): {when: number, index: number} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerCancelNamedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.cancel_named')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel a named scheduled task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 24.91 + 2.907 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 100 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Scheduler.cancel_named') === 'a0b847240e1232c10a62578340a2af6708e760669b06344b70c15e6370b514cf'
    }

    /**
     *  Cancel a named scheduled task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 24.91 + 2.907 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 100 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV1(): {id: Uint8Array} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Cancel a named scheduled task.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Scheduler.cancel_named') === '2a01c4c05d6bf45e0dc267bd7f6e27df3b3e4b23af7982734357c4de87ef690c'
    }

    /**
     * Cancel a named scheduled task.
     */
    get asV968(): {id: Uint8Array} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerScheduleCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.schedule')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '9107601d4bb249e8c8af5bede80a47e9a38c875a0167fa78043eef0f99a6296f'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV1(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1.Type_51} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV801(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '222227174e377f9532e38d514af813e90da0ebf9a56a3bd1511b4316af735079'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV801(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v801.Type_48} {
        assert(this.isV801)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '60c1b128c911c9fcdfa88a05ddbcfb99e27839af4762b2edab604b5cecc83b9d'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV802(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v802.Type_48} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '4b97de423840085d922be95f18d885994d3e475f9be7e6f43ef35b02c556ad38'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV803(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v803.Type_51} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'b28b73893c94618e9be094e54c7f597645ef25b6f0916fd1c2bada78741b46c2'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV804(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v804.Type_51} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV805(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '819155086101548606a2892bca939bdba0175417d91179b39683412113db7736'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV805(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v805.Type_118} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'd8aa082e918e22b2fc81826c325a0400be76e42f6e51dddaa97f35cc1a18839e'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV900(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v900.Type_118} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV901(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'f4bd4e0f77287eafed5eaff1b4a4822facab9a61719f6a7f011f9ae1fb15ec41'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV901(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v901.Type_118} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV902(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '15c46d4d6b14b4e2d96bcb00bd2d0e4a98c1890ad3643fd2dff1354e32c75591'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV902(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v902.Type_118} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '6e3d9e48f7ec43d323b4e3d6e770504c083670ab9749c4875c87fd9956992314'
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get asV906(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v906.Call} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '78f22207b89a4b588565053cbf3dedeff16c3cf86e424bd17d24e70c3a190c9f'
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get asV908(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v908.Call} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get isV910(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '1c2c8c7b45ff24d618f0b1fd6b3be89af9f1afba1bec0a328343380a1fcdb540'
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get asV910(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v910.Call} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get isV912(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'b76caeea1d6aebac864bd97b312e460b995640766b9ab7c49ac82590d48d36e6'
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get asV912(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v912.Call} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get isV914(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '97c22f7c2ea38854ae2898ae449bd2ad23aeae24df6647ac89f71b424fc14ec6'
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get asV914(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v914.Call} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get isV915(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '1952c4e802c989abe8f6ad43a4618c60676d10ba2a8230bdaf24a54da7af5d67'
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get asV915(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v915.Call} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'ce8a2302500fae3d99c587711c246b959a1d5ebff4e104df6098cfd7cd159831'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV916(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v916.Call} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '45e5aefa948000dc79d9e2d233f49048dfe80143c541e236f10c70a2b0bf675c'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV918(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v918.Call} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '05c8aa6bca4c808f1461946770ae1bc4cf43c639c738ec2b6ea20e89be9b61ae'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV920(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v920.Call} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '9b640ce0ed1c1405128bf9a73f46a99fc3f24ed5f8f2ec1260319444fdac787f'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV922(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v922.Call} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'c07d398edd02f62541073cc9e2917e8e5651546e251558b7e756efda8cebbb12'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV923(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v923.Call} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '56c60ef2a476ab3c35f940cc4c6fef144632a8fd0be2091bf3290f260fbbd307'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV926(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v926.MaybeHashed} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '9af8e7b91fc9e72e7e63a14974069b929a3cd30fcc187a068840454bbca6eaaf'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV927(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v927.MaybeHashed} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '9ef314aac03a41d080e0e13a3e93ff6623bd4066133c364feb4130baf9db5c93'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV930(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v930.MaybeHashed} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'c9e0f5d4db008f956219a4a75d56683c70aab708838de64f95a9b012610029b0'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV932(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v932.MaybeHashed} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '91ec185b9ccf8d6696944c386d796c6b5cd2cfce5f0d9742a2842e1f953045e8'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV940(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v940.MaybeHashed} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '0308210b4abd6e5c55f3d9b9c00c445da291da25e8b067765ad5a325909211d7'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV942(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v942.MaybeHashed} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '8474291558e27d27e8357c5927a47491560181b092b444ff470930b6d3f3ff74'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV944(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v944.MaybeHashed} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'ad1668ac1f9500dc6ff01c20c2908c7c6cf0e1ff0cf128102de0999e56e913fc'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV946(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v946.MaybeHashed} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '4b8ccd551053a4dc23e7da6661db726ee8824b781672120fac61a7bce9a7da84'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV948(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v948.MaybeHashed} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '75797e745afb9ade9a5388a39b94c731f13817b0f9171b13b7af975e8ba627b5'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV952(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v952.MaybeHashed} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '868541ca73cb660d047017e8d41c794f49a85ba2d900c881e17b0adb71ec2816'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV954(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v954.MaybeHashed} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '4fc5ffb5cb88001ebc01fda29c65088f7c16211ce8b82b9c8350c46a1529c8be'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV956(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v956.MaybeHashed} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '6377bdb53601ca4a28b1a22e7818ae86c5b463fbf0381181d1e74f9897495f2b'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV958(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v958.MaybeHashed} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'bff6153a8ffd3c8619ceb993d0a2fcc5ce04ae0069d00b24b4ce231350cc6855'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV962(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v962.MaybeHashed} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'c51051eccc9953e34440a5740b95f4ba74bbe7a2859bdc849f4d1051f7b336d1'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV964(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v964.MaybeHashed} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'af5343e104d3af3b14fcbaa061cd7933a6ba3beeb62e676a380938091192296b'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV967(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v967.MaybeHashed} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '25e6461dce4a0a369e44f0e8b6d16d7c65dd0281f874c09b11dae487c463d87e'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV968(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v968.Call} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '579f948fa40a420570cabe0f54e074a043d5e09e23149e509563e8770e855c85'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV970(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v970.Call} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'e3ce90ec3d3e5096806e97e4e421eac01b49753f2854b370485ede7650099640'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV972(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v972.Call} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerScheduleAfterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.schedule_after')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '0418c5147b738e6d12c5349311e431fa715d8a3edb6e1012b8cae68d78073160'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV1(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1.Type_51} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV801(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'dedcd7e23b6d55f5bbb6e919f6a3da7e5a568427dd270f3dc8734448fa94cf32'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV801(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v801.Type_48} {
        assert(this.isV801)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '83808606f5a7607434935265f549349fb809d24b0fb207fa67c8a147dd372e42'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV802(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v802.Type_48} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '38a51d1d9980b506f58b0869bbb9be30fac8375bbfeea7c4b291772dba245599'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV803(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v803.Type_51} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '90cc58b0af0f561408d84f5771ce9b780f0b59f85abe24aeb686d5843dcd76a1'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV804(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v804.Type_51} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV805(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'c756193d30376901704da3bd11b6deca68d509b7ec32e4cbe50238354bd50a75'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV805(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v805.Type_118} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '3565fa681cd82c670fcf7d6da80947ee562f2c1783403b30f2727c15cc1e1450'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV900(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v900.Type_118} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV901(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'cf52a68b4224273a154f7926d5c75e762d782f78f34c07dafbcb0e1a5ae3e8e9'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV901(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v901.Type_118} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV902(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'a6ceda107e181c47472188bdcfe97b1ee4889d7c4b092ace191f2243f852ffc6'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV902(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v902.Type_118} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '0d484196d8e0813c3c32e42c43f7d8e9bb2d34a9d73d8f3f54bf530919ab1753'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV906(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v906.Call} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '9a4d7537b6e3bf9d667154b70c1a9f0f639a63a6d88bd2fd6cbfe7c301c6aafc'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV908(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v908.Call} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV910(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '3192526b44fc86ffe3b59d045d32d6a388d4f0cf922ec8bce1c1c9b077a5ea4d'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV910(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v910.Call} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV912(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'f8aa3c2b4cea6f942a8a3ddea48273df83571973e6b2709be13287f007a61cd1'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV912(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v912.Call} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV914(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '400ab7645cb9530615b3f5d5b7b85371fa7ef80f80da40d249df30040b56cba7'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV914(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v914.Call} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV915(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'e470967cb69791901d6bf7bf0d2b6933c08b2c2939a95d9f7f7e5d9bf7c52b43'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV915(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v915.Call} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'ce66a6e8c23bbd7cc10991fd5b87ed60f538c0f5abab96be54971e3830f97590'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV916(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v916.Call} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'eb5e45955ebf486dc1ed1edacf677dfeb7b05a5bd91810acb1d9efb10cc63606'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV918(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v918.Call} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'ea00ea609297daaf758de1934ca7d49affcbbfca7e7d26738f82f004bf757c0a'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV920(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v920.Call} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'ca54d5e07ae74b518835f3abbd3212fd68e72088693657e1a4185198d4fdd008'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV922(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v922.Call} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '932c46c4e07bb55e76834424f658a714f188f25c306322730cb9e6bdb58fe84a'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV923(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v923.Call} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '4076a6f7d698b2d1f02fe8324ba970fa43ec4428bb6a8a1233fcd97275ea020e'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV926(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v926.MaybeHashed} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '29b07a26dfffe09dc72bb84b2184f976b121799e5d7397c999cd945afc119e08'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV927(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v927.MaybeHashed} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'a587446878238b707c37fdd4dda2910066a712107fa7f1a289ef433c8fdaad23'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV930(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v930.MaybeHashed} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'b3c052ff8d5bc3df4d0ea43d43b04a8fc80c607de177cdf500029256bdcdc3bd'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV932(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v932.MaybeHashed} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '2f2d740f9e7c7c457ae4ae0c14e1ebb43f3749f66d748df791076fc200e7db2f'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV940(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v940.MaybeHashed} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '80fddb05cb768fc8f5c2435dab0a9841649ffab9489eab5ddd35211208141b56'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV942(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v942.MaybeHashed} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '8c7b753fb91dd4252871f8dd9cb98775c487b64899ec57e805977f43c4f54248'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV944(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v944.MaybeHashed} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '70c6abeedc23600d920f5dc5f4f2850aa08c331cdb35f78ada1b2dcc334bb5cf'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV946(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v946.MaybeHashed} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '4e642974951015e55789f2a8dab40d81975699f8acc235d067783f2f1158790d'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV948(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v948.MaybeHashed} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '3dfdaa777ffaf59bd2f253cbd6fbe390a8df29de66dc8699b6ad08c197c78104'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV952(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v952.MaybeHashed} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '5ab16e0ecf6561f4514c5da636cf7ad461362de8ee06a8b7a8f0f81417c9f254'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV954(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v954.MaybeHashed} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '5356e462eed1950124c2378555246593d18c23dcc6e17a539dcca6afd8f52514'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV956(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v956.MaybeHashed} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '056ec4d076b27352730007e2367696263f0731fe7cb8a61bf0ddc9df34b91206'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV958(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v958.MaybeHashed} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '4c48e4a2ebec22e090bda4c362113ff442cb5887443c494b66febc2870f05531'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV962(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v962.MaybeHashed} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '9b01507cab2373a2c22031b3e722bdd1b6baf412f6fd6f995493e5d6c591c95b'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV964(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v964.MaybeHashed} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '5c32b96b9f838f0d6af7aa52b151d57833bbac35d56505e91486a2dadaa1d338'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV967(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v967.MaybeHashed} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'e85d66c2c2b6265e7914bae5c254d7879111523388b8fce4a64e5af4bb4556bf'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV968(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v968.Call} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'c8603651f1d0339061785148b421f024d74e7c4e7b909092cf9c526649e1d163'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV970(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v970.Call} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'feaae8d852f15152139eda01bb586e1c6ec6b2b99aaeb6ec8e298c52a67b8d19'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV972(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v972.Call} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerScheduleNamedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.schedule_named')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'a4559d2c8ad9683c33ba27e30ab6fa192f03c82265156553eda7c1b0811194f7'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV1(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1.Type_51} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV801(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '22610753bdace9bcf6ffc6524b07ed8edb402e1885896d9211d3d02ce7499d74'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV801(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v801.Type_48} {
        assert(this.isV801)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '4d4af55ed18995feae081035e6436028312235e75812a9a2e6568356391f636f'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV802(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v802.Type_48} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'e21ee075db79c359a5623c498747d995b61082823ed45350a98cc39193c2b59a'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV803(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v803.Type_51} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'e44cfdb912c68b785305ec48c2e581bc5e97122a9595d05f26a97d59c39f8bb8'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV804(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v804.Type_51} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV805(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '4f9a85ada3fcf807969aeb5c0521b7d35675a27863c317820e4ea9cdfb05aa29'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV805(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v805.Type_118} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'c5e0a0a31fd50dfb1dc43e44fa1c9e50ae70387dce329206ebac363536d3912c'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV900(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v900.Type_118} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV901(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'deaae4af5b594c735ab6f030a1493dfd4cb7c36bd582a6fc050da406f3684a42'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV901(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v901.Type_118} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV902(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'c28c6ff63e6696afac55e13e69263d512e1518203c017dd428e1fd139395d68a'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV902(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v902.Type_118} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '1a6144bae9cf9c9830517b32ca845a270cf16373d8ac99903935dab9175be499'
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get asV906(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v906.Call} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '84b97c7034d7b3df0c7f969dbbfeb97e196f0712f622309ff3a016d3bf439d11'
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get asV908(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v908.Call} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get isV910(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '5c0596b9e34b72cb37330ebab4f8383dc3116a6942665c7df99ccb601759daf3'
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get asV910(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v910.Call} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get isV912(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '0765833331f57c0a464a7701e605214ad7a4952b609f9798e19d317dc48ce3dc'
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get asV912(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v912.Call} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get isV914(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '418ac4650edbfd2f89e6166ffbede050a7f4272a9802db0316c8e318f713f469'
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get asV914(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v914.Call} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get isV915(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '30c9e84c38c635b79c38e91652a458a4faa35ce6c22448de3136c00bd897758f'
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get asV915(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v915.Call} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '1852f5b0e5586467c8d8d77f35026d4982decf3f29ec0d3dbb1ca31e16c01351'
    }

    /**
     * Schedule a named task.
     */
    get asV916(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v916.Call} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '221118df9fc1239fe12ad753dcfab14c0bc7b7ec0e6a1fe1a45ee89fee4b9e5b'
    }

    /**
     * Schedule a named task.
     */
    get asV918(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v918.Call} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'f27e8492ede2b9363b49d82889eb25f4c4cb1798c136a97a26f7aa0cfa918369'
    }

    /**
     * Schedule a named task.
     */
    get asV920(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v920.Call} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '2aa186705bb44853d6354a32420fef9dd9befd7d66c52396f1f7e8003ff1a8c6'
    }

    /**
     * Schedule a named task.
     */
    get asV922(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v922.Call} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '74d3a828ad6c65b1a004482430171fe917e23bb0dbb787ae5525fa4080d51177'
    }

    /**
     * Schedule a named task.
     */
    get asV923(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v923.Call} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '20614fda0a9736b1361a97fe5cce7396acd8ea699afba722eb21c53a229f8e40'
    }

    /**
     * Schedule a named task.
     */
    get asV926(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v926.MaybeHashed} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '739ded2e8fe749bc6d0d1183be5673b345e257d0c494d2d0ad9c460980f694b8'
    }

    /**
     * Schedule a named task.
     */
    get asV927(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v927.MaybeHashed} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '02ca48e07eabee9b2060f7e2d4a0770cfdf9070f08966819a31d89e424689ceb'
    }

    /**
     * Schedule a named task.
     */
    get asV930(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v930.MaybeHashed} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'f707bf59f76ad827a84bb97973bbba99ca98695fb3cef1091d2fb1bd16ace5ea'
    }

    /**
     * Schedule a named task.
     */
    get asV932(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v932.MaybeHashed} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'f074812d0deb446e3cc20e7df16d669ed75c6a4fbeb93d5353b6d415325d0bb4'
    }

    /**
     * Schedule a named task.
     */
    get asV940(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v940.MaybeHashed} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '067e5be21a90f2640a3f02cf93bf59fda23b5d00e503db52d136538de8fb057f'
    }

    /**
     * Schedule a named task.
     */
    get asV942(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v942.MaybeHashed} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '08b1c8d3cb40f4709b1f0beec1b026d79e9bfbac3a4ed97da0267bd135d65311'
    }

    /**
     * Schedule a named task.
     */
    get asV944(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v944.MaybeHashed} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '69a1318fc9451c10af3224f063e687cc3472eb59e165ef0e7085bcf8680cd24c'
    }

    /**
     * Schedule a named task.
     */
    get asV946(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v946.MaybeHashed} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '2016aa5d56a2c002b2063c6683cb4aec7135df43cde38711fff9ba6a812ffbd0'
    }

    /**
     * Schedule a named task.
     */
    get asV948(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v948.MaybeHashed} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '1a5968f4eb3a769e1445e0f0745fb1621dbdc2ea7f4f661e644172cf89341dbc'
    }

    /**
     * Schedule a named task.
     */
    get asV952(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v952.MaybeHashed} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '6d51b371d6d93de0c38f886d29444ecee4faeada9a7640e7b651b0b8c2995732'
    }

    /**
     * Schedule a named task.
     */
    get asV954(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v954.MaybeHashed} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'c43f4dcc5cdc1ba2266c548f7b44f05ecf8d1cdbee433d69e7b054459f79e8f2'
    }

    /**
     * Schedule a named task.
     */
    get asV956(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v956.MaybeHashed} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'f3ae030f8e141ed124903b07e2717ebcbdf7ed0219cfa6b7496768957b2032f7'
    }

    /**
     * Schedule a named task.
     */
    get asV958(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v958.MaybeHashed} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '991c72e8285faa1c08df8b8c27d0003c3f17f46a2137a2575761fd7b1c2469c7'
    }

    /**
     * Schedule a named task.
     */
    get asV962(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v962.MaybeHashed} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '90aa20ced83abce13441eeddd31c49594515dbe510f80c949c9779e7f18db2bb'
    }

    /**
     * Schedule a named task.
     */
    get asV964(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v964.MaybeHashed} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'd2fd1cb3f201f4709b72bcc7b335dc4557873df03abc5c1936bd90ecd5f0044f'
    }

    /**
     * Schedule a named task.
     */
    get asV967(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v967.MaybeHashed} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'b69ea481a3dc07c665181d5f601bb4c72e018b8446d91942b402b3218f446c55'
    }

    /**
     * Schedule a named task.
     */
    get asV968(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v968.Call} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '3f73b9f5cb3f8148b2b52dfb0d943c73fc2214ca035146e2e19c2177d44b7081'
    }

    /**
     * Schedule a named task.
     */
    get asV970(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v970.Call} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '74d49639b6111434fc43d01ad5876d715e3e41592a4763cb9ff187f8e85460c6'
    }

    /**
     * Schedule a named task.
     */
    get asV972(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v972.Call} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerScheduleNamedAfterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.schedule_named_after')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'c503ea89a699aed9aa1da89cd438a2b6554404f9d48b0c5581a72fe25d5f255c'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV1(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v1.Type_51} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV801(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '007b2edd22240efd869005ad25d3f2a39eaacf6052c9bf7540941a80ba228055'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV801(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v801.Type_48} {
        assert(this.isV801)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'fe1bf43831a9f556cfe80f7016333cf8f56e7ada7f1ec06263a5855a12325d4b'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV802(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v802.Type_48} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'f3ace7d025cbf42a2cdab27f2c6ade5696a7cd46c69cfb5964d52429a80270d0'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV803(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v803.Type_51} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'fb6a7fd36d77b58f933d96d89726bf26284a0d7bad6c899571567d77d616aadf'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get asV804(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v804.Type_51} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get isV805(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '9c010f65cad2a68e18a01c360f8cd725e446d200e70bd4a66a90d17962f2b85d'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get asV805(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v805.Type_118} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'bae1889f97f079ed1f3e2ebbaf52dcf555921d375f6c6087294e0631f48a93cd'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get asV900(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v900.Type_118} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get isV901(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '69dd2624bf40cdfe994f6580a799e5f201113a0d3b269b425d513811a3ffa87f'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get asV901(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v901.Type_118} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get isV902(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'fab1e34644df68f628cf75e3101a9fc126aceeaf568e1e0c6dd80a1275b44be2'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get asV902(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v902.Type_118} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '9ad65b3e6ac4a04bcab210dcc0144ddf91d5ddec6c716a713940d7585ef463aa'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV906(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v906.Call} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '1aeaca341f9f8a8fdad3f09b90e54cbc757c084c9679efa9ed3fd1239ffdeed2'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV908(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v908.Call} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV910(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '71906d5b149fb984fd43dc09530a7e8d859e625360d209f161bc5e746160a720'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV910(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v910.Call} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV912(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'b885e6955a09872ca442655e61aa60952242d621a83b96ff888f79162f65fccb'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV912(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v912.Call} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV914(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '9341e455a2d38f52aaae942840f4d1378163cc5461bdf73431518fa817d6c435'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV914(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v914.Call} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV915(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '5bb5154e5ca122ebb53923b69e325071434e5ca45baa51c814bb06c24251d78e'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV915(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v915.Call} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '204409c2a53c29e49ada3705d78b24c52510b56199859e66b410649b5a46b54b'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV916(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v916.Call} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'f7de6f9be1f84b482b70df1eb88d7b4c6ce64251e526daca9e19f4b7071da296'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV918(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v918.Call} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'de22c95d7fa94890b53934930a4f381bca3d224b726f0a3d2ca657dba8b00571'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV920(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v920.Call} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '21173e43849df2d757b33071e8042c74d0639d154f24b8ee4a1976dd1145bbfc'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV922(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v922.Call} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '473bfc961c4b30b366c579dc4daa7490daf7689052c03799f97de39e26f62381'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV923(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v923.Call} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'a42262b500de2d747d1ef94c6127bf9422b14fd523c7ad0e913de2d67647e5fe'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV926(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v926.MaybeHashed} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '704e5adcab772b95830f75e9d679ec8450cedb112cf133b2b2be9e15f4b5c9c8'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV927(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v927.MaybeHashed} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'cdf746ebb8952813d336903cbf16962d58c80bc4408ad5e4bb331f482546f8f8'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV930(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v930.MaybeHashed} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '34c2954140e355049483ea7a6fac2e2bcc6e42ccda0bf13e1ff67ce7f91c9a07'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV932(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v932.MaybeHashed} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '709910549bcddf3a368923998f0b01164211e9553ad5b767f5593e76bf49b875'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV940(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v940.MaybeHashed} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'b9de2f45c524f62bca46767004e962028776418dda10e7d963cb272c25f2add8'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV942(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v942.MaybeHashed} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '0b8daedb5d1d0c0b59ca02861ddd857252caa44fbba39e81d3518baf8a0b5140'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV944(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v944.MaybeHashed} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'b2511527bb0df327c0d3e922d1f0779922d6d9a4bde102f49c4df4385a5f2490'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV946(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v946.MaybeHashed} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '193e0aeb1260a4e91debf994d63223906fab948645f2fb603daa67dbea9f55f8'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV948(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v948.MaybeHashed} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '642bbc4d670e471b402e401c803b58ad760b49062492b5ba13dd8555ac2e3cf0'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV952(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v952.MaybeHashed} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '4110982d2e9129e854352d184e84f6bd03f5714847a0d69a0c6a7d36bc98a49d'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV954(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v954.MaybeHashed} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '31357f25bb04c10dca9d716985a2f689757f00f69abe5d6a798dd76ddf4612b5'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV956(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v956.MaybeHashed} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '87163b67451f6d6e3f990d4c1e03040c8302fdfef475dfc7dbb872fd79dfe511'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV958(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v958.MaybeHashed} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '7f167da3278632c07e59bbb258608fe09cd1943d8e4b0d04a12978cef82433e3'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV962(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v962.MaybeHashed} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '69e48dc097e3c9e307b95093c7bb6bae991da4a977103b4fd68f10b4c51506b4'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV964(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v964.MaybeHashed} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '359fbfe9747e538673b1535c8472b864296b96bc9d5254b3fdf39c8be6d3eeba'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV967(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v967.MaybeHashed} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '99609ee3432bfe89434710b739c79f34dfacfe2fe896ebe5bdcb053adcc7c5b0'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV968(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v968.Call} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'c2c8043b35f4d2df4315bd52cfcd09d6782546a9951ce0c290ddc8e955a337f4'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV970(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v970.Call} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '619ebfc4d7b95fa7b34223d82d91041ea3b2ccd9513258acf0e7da78acd4758c'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV972(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v972.Call} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SessionPurgeKeysCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Session.purge_keys')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Removes any session key(s) of the function caller.
     *  This doesn't take effect until the next session.
     * 
     *  The dispatch origin of this function must be signed.
     * 
     *  # <weight>
     *  - Complexity: `O(1)` in number of key types.
     *    Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.
     *  - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`
     *  - DbWrites: `NextKeys`, `origin account`
     *  - DbWrites per key id: `KeyOwnder`
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Session.purge_keys') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Removes any session key(s) of the function caller.
     *  This doesn't take effect until the next session.
     * 
     *  The dispatch origin of this function must be signed.
     * 
     *  # <weight>
     *  - Complexity: `O(1)` in number of key types.
     *    Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.
     *  - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`
     *  - DbWrites: `NextKeys`, `origin account`
     *  - DbWrites per key id: `KeyOwnder`
     *  # </weight>
     */
    get asV1(): null {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SessionSetKeysCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Session.set_keys')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the session key(s) of the function caller to `keys`.
     *  Allows an account to set its session key prior to becoming a validator.
     *  This doesn't take effect until the next session.
     * 
     *  The dispatch origin of this function must be signed.
     * 
     *  # <weight>
     *  - Complexity: `O(1)`
     *    Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.
     *  - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
     *  - DbWrites: `origin account`, `NextKeys`
     *  - DbReads per key id: `KeyOwner`
     *  - DbWrites per key id: `KeyOwner`
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Session.set_keys') === '1c752dec4c8591fc47a682e319ea76d3d039cb9a7524e367b1e7a7a9fcf32dd7'
    }

    /**
     *  Sets the session key(s) of the function caller to `keys`.
     *  Allows an account to set its session key prior to becoming a validator.
     *  This doesn't take effect until the next session.
     * 
     *  The dispatch origin of this function must be signed.
     * 
     *  # <weight>
     *  - Complexity: `O(1)`
     *    Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.
     *  - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
     *  - DbWrites: `origin account`, `NextKeys`
     *  - DbReads per key id: `KeyOwner`
     *  - DbWrites per key id: `KeyOwner`
     *  # </weight>
     */
    get asV1(): {keys: Uint8Array, proof: Uint8Array} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     * 
     * The dispatch origin of this function must be signed.
     * 
     * # <weight>
     * - Complexity: `O(1)`. Actual cost depends on the number of length of
     *   `T::Keys::key_ids()` which is fixed.
     * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
     * - DbWrites: `origin account`, `NextKeys`
     * - DbReads per key id: `KeyOwner`
     * - DbWrites per key id: `KeyOwner`
     * # </weight>
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Session.set_keys') === 'c0b44bc08ddc0ad90c1bd05300acef09fd979fcb434b3b92b011e7817fd56c2f'
    }

    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     * 
     * The dispatch origin of this function must be signed.
     * 
     * # <weight>
     * - Complexity: `O(1)`. Actual cost depends on the number of length of
     *   `T::Keys::key_ids()` which is fixed.
     * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
     * - DbWrites: `origin account`, `NextKeys`
     * - DbReads per key id: `KeyOwner`
     * - DbWrites per key id: `KeyOwner`
     * # </weight>
     */
    get asV906(): {keys: v906.SessionKeys, proof: Uint8Array} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpAddDelegatorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.add_delegator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.add_delegator') === 'dd1abf155a56cccf9ea60f9b89c3fa44adf3a341f42f315b5c0ad8aff853247d'
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get asV940(): {currencyId: v940.CurrencyId, index: number, who: v940.V1MultiLocation} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.add_delegator') === '3560fdc561adea07a4bdaf30ad11c9c82c21a2a6160291c285132429b558d43b'
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get asV956(): {currencyId: v956.CurrencyId, index: number, who: v956.V1MultiLocation} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.add_delegator') === '5245d8f4dc9acdb68fb854213b1b6e89a6788b3f37bab1a7756f67074ed5462a'
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get asV962(): {currencyId: v962.CurrencyId, index: number, who: v962.V1MultiLocation} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.add_delegator') === '1f07327a5d126b765ddb58e956c3945a7c2d2aa2a73ad6c9b5c8ebbee05ba4a6'
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get asV970(): {currencyId: v970.CurrencyId, index: number, who: v970.V1MultiLocation} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.add_delegator') === 'b114db1115f904479247aa70f70fe559af680e210bc4d6fb0f04a67b9b2cafb6'
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get asV972(): {currencyId: v972.CurrencyId, index: number, who: v972.V3MultiLocation} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpAddSupplementFeeAccountToWhitelistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.add_supplement_fee_account_to_whitelist')
        this._chain = ctx._chain
        this.call = call
    }

    get isV946(): boolean {
        return this._chain.getCallHash('Slp.add_supplement_fee_account_to_whitelist') === '9d021e63f24596510d85764848b1d886266574ab6e15db483fc8c5275e1b851b'
    }

    get asV946(): {currencyId: v946.CurrencyId, who: v946.V1MultiLocation} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Slp.add_supplement_fee_account_to_whitelist') === 'a7ba15ac327ecdd5973b4b5f69588f7e5efcd1c575f7417d1bff79d220c5a9e8'
    }

    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Slp.add_supplement_fee_account_to_whitelist') === '8bce49f5614ac91e8dd1d99bc3b0ec4599a2e166b774ace6466afe55e03dd498'
    }

    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('Slp.add_supplement_fee_account_to_whitelist') === '219009164c74bd725d0ddeda33eb4c157a3b4dc7ddd0393a818976c6e8cdcff5'
    }

    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    get isV972(): boolean {
        return this._chain.getCallHash('Slp.add_supplement_fee_account_to_whitelist') === 'ec87264805a12c1c8157c39e6de627fc752dbd2f0958e747fe5c3f9a4a19532b'
    }

    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpAddValidatorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.add_validator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update storage Validators<T>.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.add_validator') === '9d021e63f24596510d85764848b1d886266574ab6e15db483fc8c5275e1b851b'
    }

    /**
     * Update storage Validators<T>.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage Validators<T>.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.add_validator') === 'a7ba15ac327ecdd5973b4b5f69588f7e5efcd1c575f7417d1bff79d220c5a9e8'
    }

    /**
     * Update storage Validators<T>.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage Validators<T>.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.add_validator') === '8bce49f5614ac91e8dd1d99bc3b0ec4599a2e166b774ace6466afe55e03dd498'
    }

    /**
     * Update storage Validators<T>.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage Validators<T>.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.add_validator') === '219009164c74bd725d0ddeda33eb4c157a3b4dc7ddd0393a818976c6e8cdcff5'
    }

    /**
     * Update storage Validators<T>.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage Validators<T>.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.add_validator') === 'ec87264805a12c1c8157c39e6de627fc752dbd2f0958e747fe5c3f9a4a19532b'
    }

    /**
     * Update storage Validators<T>.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpBondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.bond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * First time bonding some amount to a delegator.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.bond') === 'd85a66b02c55b5025622329c2e1300b7c3829fb11be22746a96be23cc135b94e'
    }

    /**
     * First time bonding some amount to a delegator.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation, amount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * First time bonding some amount to a delegator.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.bond') === '4dda974101a57c7c745dcce684e735753f3b9b69d03e2cfd331c33964f0feb11'
    }

    /**
     * First time bonding some amount to a delegator.
     */
    get asV946(): {currencyId: v946.CurrencyId, who: v946.V1MultiLocation, amount: bigint, validator: (v946.V1MultiLocation | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * First time bonding some amount to a delegator.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.bond') === '706a2adb4eafe5bfa63d502610f55a4733090319524374bf9b10b19d71383a0e'
    }

    /**
     * First time bonding some amount to a delegator.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation, amount: bigint, validator: (v956.V1MultiLocation | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * First time bonding some amount to a delegator.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.bond') === 'f95a1cfcb37e1cb95529abcb98cded6a3ac3dff71420e431c8c931260d42079f'
    }

    /**
     * First time bonding some amount to a delegator.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation, amount: bigint, validator: (v962.V1MultiLocation | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * First time bonding some amount to a delegator.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.bond') === '485b9f746ad078f1664eeb09b16ebe56d0e8ac7b3d4a951cfb8e06ff5a4b9530'
    }

    /**
     * First time bonding some amount to a delegator.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation, amount: bigint, validator: (v970.V1MultiLocation | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * First time bonding some amount to a delegator.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.bond') === 'f07d9ab41f99d1c0b6355d16343d66effae732c3c73a902c600b0cdb77d61613'
    }

    /**
     * First time bonding some amount to a delegator.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation, amount: bigint, validator: (v972.V3MultiLocation | undefined)} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpBondExtraCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.bond_extra')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Bond extra amount to a delegator.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.bond_extra') === 'd85a66b02c55b5025622329c2e1300b7c3829fb11be22746a96be23cc135b94e'
    }

    /**
     * Bond extra amount to a delegator.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation, amount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Bond extra amount to a delegator.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.bond_extra') === 'c5461acffe61b70ce2bf3890afdec9283ec0dcb8c747c8f734c1aaf5fff37d2a'
    }

    /**
     * Bond extra amount to a delegator.
     */
    get asV946(): {currencyId: v946.CurrencyId, who: v946.V1MultiLocation, validator: (v946.V1MultiLocation | undefined), amount: bigint} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Bond extra amount to a delegator.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.bond_extra') === 'b59dea852702fb0cb9af8096febba2039c961d5aeb18606cb49f899e3588d7c5'
    }

    /**
     * Bond extra amount to a delegator.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation, validator: (v956.V1MultiLocation | undefined), amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Bond extra amount to a delegator.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.bond_extra') === 'c7a74604ee456544693a727fae681ae773b03bb335169ba3c47c06f4e725924e'
    }

    /**
     * Bond extra amount to a delegator.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation, validator: (v962.V1MultiLocation | undefined), amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Bond extra amount to a delegator.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.bond_extra') === '8408eb162eb665b063bea3d1917c92eeeb57fe4d8bc02b8c16558425c1137e30'
    }

    /**
     * Bond extra amount to a delegator.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation, validator: (v970.V1MultiLocation | undefined), amount: bigint} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Bond extra amount to a delegator.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.bond_extra') === '4ba41b276257fe560429ea23dbceb09986af703f496bbeaec083b9bbaeecf46e'
    }

    /**
     * Bond extra amount to a delegator.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation, validator: (v972.V3MultiLocation | undefined), amount: bigint} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpChargeHostFeeAndTuneVtokenExchangeRateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.charge_host_fee_and_tune_vtoken_exchange_rate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.charge_host_fee_and_tune_vtoken_exchange_rate') === '66670eedb7ebf0a2bb6bef9b3587392f7f21d81fe1e0b270dec94468b4fd6bc0'
    }

    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    get asV940(): {currencyId: v940.CurrencyId, value: bigint, who: v940.V1MultiLocation} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.charge_host_fee_and_tune_vtoken_exchange_rate') === '3eeb2c50f5e9b618617c1ee336143dfea0875eb58e37f7b03c072901d60131fe'
    }

    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    get asV946(): {currencyId: v946.CurrencyId, value: bigint, who: (v946.V1MultiLocation | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.charge_host_fee_and_tune_vtoken_exchange_rate') === 'ed25d651a9270340606e4faae09bc901b76428fff12e1c84ecd1b6593dcb1808'
    }

    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    get asV956(): {currencyId: v956.CurrencyId, value: bigint, who: (v956.V1MultiLocation | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.charge_host_fee_and_tune_vtoken_exchange_rate') === '95025119f9109e55dda3c17a125860d7f15017f000186e20b43375b1442a7738'
    }

    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    get asV962(): {currencyId: v962.CurrencyId, value: bigint, who: (v962.V1MultiLocation | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.charge_host_fee_and_tune_vtoken_exchange_rate') === 'f6657701856ebd1f81af7c8cb11530dd531582eb99893b4ba8a19f6a5b97e039'
    }

    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    get asV970(): {currencyId: v970.CurrencyId, value: bigint, who: (v970.V1MultiLocation | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.charge_host_fee_and_tune_vtoken_exchange_rate') === '647169f9827c57b7f48c65b3856bf701451488691b5cb4a79800f5601d51ba8e'
    }

    /**
     * Charge staking host fee, tune vtoken/token exchange rate, and update delegator ledger
     * for single delegator.
     */
    get asV972(): {currencyId: v972.CurrencyId, value: bigint, who: (v972.V3MultiLocation | undefined)} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpChillCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.chill')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.chill') === '9d021e63f24596510d85764848b1d886266574ab6e15db483fc8c5275e1b851b'
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.chill') === 'a7ba15ac327ecdd5973b4b5f69588f7e5efcd1c575f7417d1bff79d220c5a9e8'
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.chill') === '8bce49f5614ac91e8dd1d99bc3b0ec4599a2e166b774ace6466afe55e03dd498'
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.chill') === '219009164c74bd725d0ddeda33eb4c157a3b4dc7ddd0393a818976c6e8cdcff5'
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.chill') === 'ec87264805a12c1c8157c39e6de627fc752dbd2f0958e747fe5c3f9a4a19532b'
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpConfirmDelegatorLedgerCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.confirm_delegator_ledger')
        this._chain = ctx._chain
        this.call = call
    }

    get isV972(): boolean {
        return this._chain.getCallHash('Slp.confirm_delegator_ledger') === 'bef8f7543dfaf827f16faeecf1ae77b01b3a27a17ca90af1a821e1cb820998fa'
    }

    get asV972(): {queryId: bigint, response: v972.V3Response} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpConfirmDelegatorLedgerQueryResponseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.confirm_delegator_ledger_query_response')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * ********************************************************************
     * *************Outer Confirming Xcm queries functions ****************
     * ********************************************************************
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.confirm_delegator_ledger_query_response') === '1a8e4d3489f20dda0c51a666357b762fb1dae589b30f46ea9d7f7fcb1de41f33'
    }

    /**
     * ********************************************************************
     * *************Outer Confirming Xcm queries functions ****************
     * ********************************************************************
     */
    get asV940(): {currencyId: v940.CurrencyId, queryId: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * ********************************************************************
     * *************Outer Confirming Xcm queries functions ****************
     * ********************************************************************
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.confirm_delegator_ledger_query_response') === 'a0c7ec304acf92a4e108e43eeca09ca78f960565f77ccdf9a73d202bb464b7f7'
    }

    /**
     * ********************************************************************
     * *************Outer Confirming Xcm queries functions ****************
     * ********************************************************************
     */
    get asV956(): {currencyId: v956.CurrencyId, queryId: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * ********************************************************************
     * *************Outer Confirming Xcm queries functions ****************
     * ********************************************************************
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.confirm_delegator_ledger_query_response') === '7f9bfc6f737f0ade9830dfdafadbddf5caf05f303c987cd4d6d12336ac5bf765'
    }

    /**
     * ********************************************************************
     * *************Outer Confirming Xcm queries functions ****************
     * ********************************************************************
     */
    get asV962(): {currencyId: v962.CurrencyId, queryId: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpConfirmValidatorsByDelegatorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.confirm_validators_by_delegator')
        this._chain = ctx._chain
        this.call = call
    }

    get isV972(): boolean {
        return this._chain.getCallHash('Slp.confirm_validators_by_delegator') === 'bef8f7543dfaf827f16faeecf1ae77b01b3a27a17ca90af1a821e1cb820998fa'
    }

    get asV972(): {queryId: bigint, response: v972.V3Response} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpConfirmValidatorsByDelegatorQueryResponseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.confirm_validators_by_delegator_query_response')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('Slp.confirm_validators_by_delegator_query_response') === '1a8e4d3489f20dda0c51a666357b762fb1dae589b30f46ea9d7f7fcb1de41f33'
    }

    get asV940(): {currencyId: v940.CurrencyId, queryId: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Slp.confirm_validators_by_delegator_query_response') === 'a0c7ec304acf92a4e108e43eeca09ca78f960565f77ccdf9a73d202bb464b7f7'
    }

    get asV956(): {currencyId: v956.CurrencyId, queryId: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Slp.confirm_validators_by_delegator_query_response') === '7f9bfc6f737f0ade9830dfdafadbddf5caf05f303c987cd4d6d12336ac5bf765'
    }

    get asV962(): {currencyId: v962.CurrencyId, queryId: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpConvertAssetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.convert_asset')
        this._chain = ctx._chain
        this.call = call
    }

    get isV970(): boolean {
        return this._chain.getCallHash('Slp.convert_asset') === '58713f5279924f71d705c267e0e6dc8bce5c73c2d99238cd0f7539c743cc8eda'
    }

    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation, amount: bigint, ifFromCurrency: boolean} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    get isV972(): boolean {
        return this._chain.getCallHash('Slp.convert_asset') === '4a39155e28adc74b6a4aaa6b6a2647cd3300b29fc50812c5c5f48c470612cdde'
    }

    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation, amount: bigint, ifFromCurrency: boolean} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpDecreaseTokenPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.decrease_token_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('Slp.decrease_token_pool') === 'fb74ac0b509ccc4ba0a0a8c76b1d93b47e94e26a4e8bd00cccfd6e942dec94dc'
    }

    get asV940(): {currencyId: v940.CurrencyId, amount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Slp.decrease_token_pool') === '9973de28184b93659d1619cd352bac6b1317cebd81b60926fcec338344025263'
    }

    get asV956(): {currencyId: v956.CurrencyId, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Slp.decrease_token_pool') === 'c635eaaf52ffe6f13bfd2bf1acd062484cf4314b6a2baec7ae9aee7341109498'
    }

    get asV962(): {currencyId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpDelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.delegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Delegate to some validator set.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.delegate') === '77fda9ae789f04fb1232291758723fe4d70550d88f787f31641c4d2e10bfceb4'
    }

    /**
     * Delegate to some validator set.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation, targets: v940.V1MultiLocation[]} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Delegate to some validator set.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.delegate') === '93afdb0906249d8a3dcfc5f2673c4be905779e31b7b355f50c36e8f4bf51158e'
    }

    /**
     * Delegate to some validator set.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation, targets: v956.V1MultiLocation[]} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Delegate to some validator set.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.delegate') === 'f118c6b2822664c8cee2e782be337201078cb65dacb0e3fe90ca2a011f358e06'
    }

    /**
     * Delegate to some validator set.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation, targets: v962.V1MultiLocation[]} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Delegate to some validator set.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.delegate') === 'e73e44ea73ecc631339970f175a934d68ff3ab9ff65b7f66fc7d7aff026b8cbe'
    }

    /**
     * Delegate to some validator set.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation, targets: v970.V1MultiLocation[]} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Delegate to some validator set.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.delegate') === 'eaffe467c13dd67c77396813bddbd1ca6015af425423b79fa29f7053a9f1d56d'
    }

    /**
     * Delegate to some validator set.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation, targets: v972.V3MultiLocation[]} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpFailDelegatorLedgerQueryResponseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.fail_delegator_ledger_query_response')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('Slp.fail_delegator_ledger_query_response') === '1a8e4d3489f20dda0c51a666357b762fb1dae589b30f46ea9d7f7fcb1de41f33'
    }

    get asV940(): {currencyId: v940.CurrencyId, queryId: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Slp.fail_delegator_ledger_query_response') === 'a0c7ec304acf92a4e108e43eeca09ca78f960565f77ccdf9a73d202bb464b7f7'
    }

    get asV956(): {currencyId: v956.CurrencyId, queryId: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Slp.fail_delegator_ledger_query_response') === '7f9bfc6f737f0ade9830dfdafadbddf5caf05f303c987cd4d6d12336ac5bf765'
    }

    get asV962(): {currencyId: v962.CurrencyId, queryId: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpFailValidatorsByDelegatorQueryResponseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.fail_validators_by_delegator_query_response')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('Slp.fail_validators_by_delegator_query_response') === '1a8e4d3489f20dda0c51a666357b762fb1dae589b30f46ea9d7f7fcb1de41f33'
    }

    get asV940(): {currencyId: v940.CurrencyId, queryId: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Slp.fail_validators_by_delegator_query_response') === 'a0c7ec304acf92a4e108e43eeca09ca78f960565f77ccdf9a73d202bb464b7f7'
    }

    get asV956(): {currencyId: v956.CurrencyId, queryId: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Slp.fail_validators_by_delegator_query_response') === '7f9bfc6f737f0ade9830dfdafadbddf5caf05f303c987cd4d6d12336ac5bf765'
    }

    get asV962(): {currencyId: v962.CurrencyId, queryId: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpIncreaseTokenPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.increase_token_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('Slp.increase_token_pool') === 'fb74ac0b509ccc4ba0a0a8c76b1d93b47e94e26a4e8bd00cccfd6e942dec94dc'
    }

    get asV940(): {currencyId: v940.CurrencyId, amount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Slp.increase_token_pool') === '9973de28184b93659d1619cd352bac6b1317cebd81b60926fcec338344025263'
    }

    get asV956(): {currencyId: v956.CurrencyId, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Slp.increase_token_pool') === 'c635eaaf52ffe6f13bfd2bf1acd062484cf4314b6a2baec7ae9aee7341109498'
    }

    get asV962(): {currencyId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpInitializeDelegatorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.initialize_delegator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * ****************************x/
     * ****** Outer Calls *****x/
     * ****************************x/
     * 
     * Delegator initialization work. Generate a new delegator and return its ID.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.initialize_delegator') === '5cb19321013a7eb509c005d6d39283ab9fae33ba97862a6a354fae8216ee5379'
    }

    /**
     * ****************************x/
     * ****** Outer Calls *****x/
     * ****************************x/
     * 
     * Delegator initialization work. Generate a new delegator and return its ID.
     */
    get asV940(): {currencyId: v940.CurrencyId} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * ****************************x/
     * ****** Outer Calls *****x/
     * ****************************x/
     * 
     * Delegator initialization work. Generate a new delegator and return its ID.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.initialize_delegator') === '7d8a3e7d779f11164e04f6a37a9fa89298621358fdfcab3b535b4b783a6c8037'
    }

    /**
     * ****************************x/
     * ****** Outer Calls *****x/
     * ****************************x/
     * 
     * Delegator initialization work. Generate a new delegator and return its ID.
     */
    get asV956(): {currencyId: v956.CurrencyId} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * ****************************x/
     * ****** Outer Calls *****x/
     * ****************************x/
     * 
     * Delegator initialization work. Generate a new delegator and return its ID.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.initialize_delegator') === '7d5a1778c6badfb14aeaf5b4958d7f3137099e4bfaab04f620efd4a20d1ed9d8'
    }

    /**
     * ****************************x/
     * ****** Outer Calls *****x/
     * ****************************x/
     * 
     * Delegator initialization work. Generate a new delegator and return its ID.
     */
    get asV962(): {currencyId: v962.CurrencyId, delegatorLocation: (v962.V1MultiLocation | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * ****************************x/
     * ****** Outer Calls *****x/
     * ****************************x/
     * 
     * Delegator initialization work. Generate a new delegator and return its ID.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.initialize_delegator') === 'f0e4e5689a8a36de9dae9af7942c7fd7bcad7e02ee83d0732665ba4ded75664e'
    }

    /**
     * ****************************x/
     * ****** Outer Calls *****x/
     * ****************************x/
     * 
     * Delegator initialization work. Generate a new delegator and return its ID.
     */
    get asV970(): {currencyId: v970.CurrencyId, delegatorLocation: (v970.V1MultiLocation | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * ****************************x/
     * ****** Outer Calls *****x/
     * ****************************x/
     * 
     * Delegator initialization work. Generate a new delegator and return its ID.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.initialize_delegator') === '01e1d1ee17553b9f2884f61e5dd42d63c0f2a963a927a9e70c43f2d8239fa35a'
    }

    /**
     * ****************************x/
     * ****** Outer Calls *****x/
     * ****************************x/
     * 
     * Delegator initialization work. Generate a new delegator and return its ID.
     */
    get asV972(): {currencyId: v972.CurrencyId, delegatorLocation: (v972.V3MultiLocation | undefined)} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpLiquidizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.liquidize')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Withdraw the due payout into free balance.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.liquidize') === '34fd538236ef44fc87e004ceec09ea7b0723423df3e682ad2acf97f7b9341d16'
    }

    /**
     * Withdraw the due payout into free balance.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation, when: (v940.TimeUnit | undefined)} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Withdraw the due payout into free balance.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.liquidize') === 'edc2cf6d13726791efdf9178eb35288b085319af80e3e7b83ec5f00c749606e7'
    }

    /**
     * Withdraw the due payout into free balance.
     */
    get asV946(): {currencyId: v946.CurrencyId, who: v946.V1MultiLocation, when: (v946.TimeUnit | undefined), validator: (v946.V1MultiLocation | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Withdraw the due payout into free balance.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.liquidize') === '4f4af81c080969b38e45edee198bc2b69ecb2889cf407cd47b04df8eb2f1687c'
    }

    /**
     * Withdraw the due payout into free balance.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation, when: (v956.TimeUnit | undefined), validator: (v956.V1MultiLocation | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Withdraw the due payout into free balance.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.liquidize') === 'b0a1a558b38efac1d0e351e1a15dd52b88b9a85e9257e0e84889634977f4a300'
    }

    /**
     * Withdraw the due payout into free balance.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation, when: (v962.TimeUnit | undefined), validator: (v962.V1MultiLocation | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Withdraw the due payout into free balance.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.liquidize') === '1b663ff0b03cd6f784a9feb3094cf1d3a470ce079056c9d78d79e2a840435c88'
    }

    /**
     * Withdraw the due payout into free balance.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation, when: (v970.TimeUnit | undefined), validator: (v970.V1MultiLocation | undefined), amount: (bigint | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Withdraw the due payout into free balance.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.liquidize') === 'a37575b4c022365ca5dd1ff071de8b3d43c80fb814c1a08d60a398dbf6caf3c0'
    }

    /**
     * Withdraw the due payout into free balance.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation, when: (v972.TimeUnit | undefined), validator: (v972.V3MultiLocation | undefined), amount: (bigint | undefined)} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpPayoutCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.payout')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.payout') === '63002a0494cb9e516c8cd3189409f559964611f3af0402246c796f110961f37c'
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation, validator: v940.V1MultiLocation, when: (v940.TimeUnit | undefined)} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.payout') === '5905427cb6b9e8854022e617b0fc8d28fe5b35635ca651a8d170f6712143bdd9'
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get asV946(): {currencyId: v946.CurrencyId, who: v946.V1MultiLocation, validator: v946.V1MultiLocation, when: (v946.TimeUnit | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.payout') === 'b42d416449e64b3cf8c2a4c36cc103a726402da0235d0e3482e7c3d4dcbb14c1'
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation, validator: v956.V1MultiLocation, when: (v956.TimeUnit | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.payout') === '24f91f1a9a4d6c8a4aa79234a587050ca5b32fe1c7b5bff89912e70456e1450a'
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation, validator: v962.V1MultiLocation, when: (v962.TimeUnit | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.payout') === '2ef3b0b71688a4a63b2eb6826a93ddb51fbaa33448ea6406416b7d2a588cb68f'
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation, validator: v970.V1MultiLocation, when: (v970.TimeUnit | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.payout') === '0fe1ae6904ff985eca13156063a43cbfcb0753b9ab4a3c09c47b4b89f135ddeb'
    }

    /**
     * Initiate payout for a certain delegator.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation, validator: v972.V3MultiLocation, when: (v972.TimeUnit | undefined)} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpRebondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.rebond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Rebond some unlocking amount to a delegator.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.rebond') === 'd85a66b02c55b5025622329c2e1300b7c3829fb11be22746a96be23cc135b94e'
    }

    /**
     * Rebond some unlocking amount to a delegator.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation, amount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Rebond some unlocking amount to a delegator.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.rebond') === '927d20a81579efc06b30e66f75014e2544dbb74f5a01a240867d0a7d45bf490a'
    }

    /**
     * Rebond some unlocking amount to a delegator.
     */
    get asV946(): {currencyId: v946.CurrencyId, who: v946.V1MultiLocation, validator: (v946.V1MultiLocation | undefined), amount: (bigint | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Rebond some unlocking amount to a delegator.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.rebond') === 'b739673a5243ed88b627aad0fd6262ec276a0b0925d6cfaf53f63ae2e9ef8a62'
    }

    /**
     * Rebond some unlocking amount to a delegator.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation, validator: (v956.V1MultiLocation | undefined), amount: (bigint | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Rebond some unlocking amount to a delegator.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.rebond') === '82302be5142a41c78bfb5c681f3a78a8b5cd79b12af16d290a97e31cab8dc3ab'
    }

    /**
     * Rebond some unlocking amount to a delegator.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation, validator: (v962.V1MultiLocation | undefined), amount: (bigint | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Rebond some unlocking amount to a delegator.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.rebond') === '68a20f323a94ee56bc40be3682c930bef67dfc3bc4af5b06e77beb90ad9b7674'
    }

    /**
     * Rebond some unlocking amount to a delegator.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation, validator: (v970.V1MultiLocation | undefined), amount: (bigint | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Rebond some unlocking amount to a delegator.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.rebond') === 'baa6b6061dbb97bca46cd0e2bd3901795f184ab59de2abd87d2e82ee9c3cbb13'
    }

    /**
     * Rebond some unlocking amount to a delegator.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation, validator: (v972.V3MultiLocation | undefined), amount: (bigint | undefined)} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpRedelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.redelegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.redelegate') === '77fda9ae789f04fb1232291758723fe4d70550d88f787f31641c4d2e10bfceb4'
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation, targets: v940.V1MultiLocation[]} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.redelegate') === 'dd332589d4cdd269e2677d62b74470e0a37bebe27426921c8d112fcc7261c15b'
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get asV946(): {currencyId: v946.CurrencyId, who: v946.V1MultiLocation, targets: (v946.V1MultiLocation[] | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.redelegate') === '9d61bc33e7a35538ececc23e4a57c186d1e08198c7a7e13d214a0a726674a92e'
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation, targets: (v956.V1MultiLocation[] | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.redelegate') === '55844652ce945e184ecf5c0a971af92d37077e5ea834957f94bf196c920e67ba'
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation, targets: (v962.V1MultiLocation[] | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.redelegate') === '9d428121c935425ca64472312c73e15a858182188a3afc335139ae009eb2d028'
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation, targets: (v970.V1MultiLocation[] | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.redelegate') === 'f447da6386e3d5760b518c790daed585eceefb0c119e77ca3386566774adc5ee'
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation, targets: (v972.V3MultiLocation[] | undefined)} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpRefundCurrencyDueUnbondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.refund_currency_due_unbond')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('Slp.refund_currency_due_unbond') === '5cb19321013a7eb509c005d6d39283ab9fae33ba97862a6a354fae8216ee5379'
    }

    get asV940(): {currencyId: v940.CurrencyId} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Slp.refund_currency_due_unbond') === '7d8a3e7d779f11164e04f6a37a9fa89298621358fdfcab3b535b4b783a6c8037'
    }

    get asV956(): {currencyId: v956.CurrencyId} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Slp.refund_currency_due_unbond') === '0a9d3c015dc155696ea30a98c73282f04dad76fa0e64157d75dc0b4c7d3bfec6'
    }

    get asV962(): {currencyId: v962.CurrencyId} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpRemoveDelegatorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.remove_delegator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.remove_delegator') === '9d021e63f24596510d85764848b1d886266574ab6e15db483fc8c5275e1b851b'
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.remove_delegator') === 'a7ba15ac327ecdd5973b4b5f69588f7e5efcd1c575f7417d1bff79d220c5a9e8'
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.remove_delegator') === '8bce49f5614ac91e8dd1d99bc3b0ec4599a2e166b774ace6466afe55e03dd498'
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.remove_delegator') === '219009164c74bd725d0ddeda33eb4c157a3b4dc7ddd0393a818976c6e8cdcff5'
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.remove_delegator') === 'ec87264805a12c1c8157c39e6de627fc752dbd2f0958e747fe5c3f9a4a19532b'
    }

    /**
     * Update storage DelegatorsIndex2Multilocation<T> 和 DelegatorsMultilocation2Index<T>.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpRemoveSupplementFeeAccountFromWhitelistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.remove_supplement_fee_account_from_whitelist')
        this._chain = ctx._chain
        this.call = call
    }

    get isV946(): boolean {
        return this._chain.getCallHash('Slp.remove_supplement_fee_account_from_whitelist') === '9d021e63f24596510d85764848b1d886266574ab6e15db483fc8c5275e1b851b'
    }

    get asV946(): {currencyId: v946.CurrencyId, who: v946.V1MultiLocation} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Slp.remove_supplement_fee_account_from_whitelist') === 'a7ba15ac327ecdd5973b4b5f69588f7e5efcd1c575f7417d1bff79d220c5a9e8'
    }

    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Slp.remove_supplement_fee_account_from_whitelist') === '8bce49f5614ac91e8dd1d99bc3b0ec4599a2e166b774ace6466afe55e03dd498'
    }

    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('Slp.remove_supplement_fee_account_from_whitelist') === '219009164c74bd725d0ddeda33eb4c157a3b4dc7ddd0393a818976c6e8cdcff5'
    }

    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    get isV972(): boolean {
        return this._chain.getCallHash('Slp.remove_supplement_fee_account_from_whitelist') === 'ec87264805a12c1c8157c39e6de627fc752dbd2f0958e747fe5c3f9a4a19532b'
    }

    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpRemoveValidatorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.remove_validator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update storage Validators<T>.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.remove_validator') === '9d021e63f24596510d85764848b1d886266574ab6e15db483fc8c5275e1b851b'
    }

    /**
     * Update storage Validators<T>.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage Validators<T>.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.remove_validator') === 'a7ba15ac327ecdd5973b4b5f69588f7e5efcd1c575f7417d1bff79d220c5a9e8'
    }

    /**
     * Update storage Validators<T>.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage Validators<T>.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.remove_validator') === '8bce49f5614ac91e8dd1d99bc3b0ec4599a2e166b774ace6466afe55e03dd498'
    }

    /**
     * Update storage Validators<T>.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage Validators<T>.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.remove_validator') === '219009164c74bd725d0ddeda33eb4c157a3b4dc7ddd0393a818976c6e8cdcff5'
    }

    /**
     * Update storage Validators<T>.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage Validators<T>.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.remove_validator') === 'ec87264805a12c1c8157c39e6de627fc752dbd2f0958e747fe5c3f9a4a19532b'
    }

    /**
     * Update storage Validators<T>.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpSetCurrencyDelaysCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.set_currency_delays')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update storage Delays<T>.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.set_currency_delays') === '3ddfaf322a0cf040130c15688ddfd7649057f736c6acdde3a7000241a1408a65'
    }

    /**
     * Update storage Delays<T>.
     */
    get asV940(): {currencyId: v940.CurrencyId, maybeDelays: (v940.Delays | undefined)} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage Delays<T>.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.set_currency_delays') === 'c27c5304e1aafe913e9a766ef135280938d593f8412998bf05f551f97d037e38'
    }

    /**
     * Update storage Delays<T>.
     */
    get asV946(): {currencyId: v946.CurrencyId, maybeDelays: (v946.Delays | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage Delays<T>.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.set_currency_delays') === '50859120163e97fa8c5bf5bca2c08738ad4b1e96a3c64c3b02a93f24fb14d99a'
    }

    /**
     * Update storage Delays<T>.
     */
    get asV956(): {currencyId: v956.CurrencyId, maybeDelays: (v956.Delays | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage Delays<T>.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.set_currency_delays') === '43ca8bca5738c6d372a45a7474ab650d050df15d0829ce9c948324a15afd8ac2'
    }

    /**
     * Update storage Delays<T>.
     */
    get asV962(): {currencyId: v962.CurrencyId, maybeDelays: (v962.Delays | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage Delays<T>.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.set_currency_delays') === '5a52e41a8c2809e7b7bad23cf4b536d7410ee1d6f3c4bf0b28e35dc1b2e8a666'
    }

    /**
     * Update storage Delays<T>.
     */
    get asV970(): {currencyId: v970.CurrencyId, maybeDelays: (v970.Delays | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpSetCurrencyTuneExchangeRateLimitCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.set_currency_tune_exchange_rate_limit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set  CurrencyTuneExchangeRateLimit<T> storage.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.set_currency_tune_exchange_rate_limit') === '3cd62772ce51959b543843f04d3de7a5b68608a42f7ed20fc229d78eedaa4463'
    }

    /**
     * Set  CurrencyTuneExchangeRateLimit<T> storage.
     */
    get asV940(): {currencyId: v940.CurrencyId, maybeTuneExchangeRateLimit: ([number, number] | undefined)} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set  CurrencyTuneExchangeRateLimit<T> storage.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.set_currency_tune_exchange_rate_limit') === 'e664408c4e5dd51cb8b72cb92e3c444bc5f10e90bb6f4ac819dfc1754b906247'
    }

    /**
     * Set  CurrencyTuneExchangeRateLimit<T> storage.
     */
    get asV956(): {currencyId: v956.CurrencyId, maybeTuneExchangeRateLimit: ([number, number] | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set  CurrencyTuneExchangeRateLimit<T> storage.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.set_currency_tune_exchange_rate_limit') === '3b018a7175b520d128b7d89309665714b0c7b2e7c8007c21154125b840c598c0'
    }

    /**
     * Set  CurrencyTuneExchangeRateLimit<T> storage.
     */
    get asV962(): {currencyId: v962.CurrencyId, maybeTuneExchangeRateLimit: ([number, number] | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpSetDelegatorLedgerCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.set_delegator_ledger')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.set_delegator_ledger') === '476522eb22fd077ecbcd0bf965c90a7f3a8b0adae3d5be1f71231270b5099887'
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation, ledger: (v940.Ledger | undefined)} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.set_delegator_ledger') === '8eeeed56e7e86d1851522f14aead06b12f826f1fea1d37631650b6c967f931d6'
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get asV946(): {currencyId: v946.CurrencyId, who: v946.V1MultiLocation, ledger: (v946.Ledger | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.set_delegator_ledger') === '9ee7c19634efa0d425ba90c2798e574e30f00c8fade13e7cbca58b797a3d1a9b'
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation, ledger: (v956.Ledger | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Slp.set_delegator_ledger') === '552593e582ad498d5ff9ead5c7f9b1e557d3eb3f566483bf089efa5c311ee2d1'
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get asV958(): {currencyId: v958.CurrencyId, who: v958.V1MultiLocation, ledger: (v958.Ledger | undefined)} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.set_delegator_ledger') === 'b2a333ddcea1c306369e238aa6f1a7204c861c0606fc02f5a0ef584712e05217'
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation, ledger: (v962.Ledger | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.set_delegator_ledger') === 'bb1a78b1f0b2686020b85b504fa26f29ecfce239c5a9d702c194b39c92cadfeb'
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation, ledger: (v970.Ledger | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.set_delegator_ledger') === 'ad9cdfe87d8b11ad40266e24f17cec136c66365b421304e55cfe90ba2ad05b81'
    }

    /**
     * Update storage DelegatorLedgers<T>.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation, ledger: (v972.Ledger | undefined)} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpSetFeeSourceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.set_fee_source')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update storage FeeSources<T>.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.set_fee_source') === '130eae825abf6b4b7d2a5602dc096f651fec5216d121a02818299dfef72f15bc'
    }

    /**
     * Update storage FeeSources<T>.
     */
    get asV940(): {currencyId: v940.CurrencyId, whoAndFee: ([v940.V1MultiLocation, bigint] | undefined)} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage FeeSources<T>.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.set_fee_source') === 'b0010c03d093f2af31ae6a956f56a112ed246c05e20d6899af5215711591df67'
    }

    /**
     * Update storage FeeSources<T>.
     */
    get asV956(): {currencyId: v956.CurrencyId, whoAndFee: ([v956.V1MultiLocation, bigint] | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage FeeSources<T>.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.set_fee_source') === '84381132aaacade7681bb2d7f41949285c722629975a68102f9bc6403bc8f37f'
    }

    /**
     * Update storage FeeSources<T>.
     */
    get asV962(): {currencyId: v962.CurrencyId, whoAndFee: ([v962.V1MultiLocation, bigint] | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage FeeSources<T>.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.set_fee_source') === 'ab055bf6952aa5324e902ec2418ffe0c256568aab762cf1493d4a841a8685593'
    }

    /**
     * Update storage FeeSources<T>.
     */
    get asV970(): {currencyId: v970.CurrencyId, whoAndFee: ([v970.V1MultiLocation, bigint] | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage FeeSources<T>.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.set_fee_source') === '3eab9cf21c46a724e233ce144763f583de5973ed9e9ebcc02f7c0ce77080ae2d'
    }

    /**
     * Update storage FeeSources<T>.
     */
    get asV972(): {currencyId: v972.CurrencyId, whoAndFee: ([v972.V3MultiLocation, bigint] | undefined)} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpSetHostingFeesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.set_hosting_fees')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set HostingFees storage.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.set_hosting_fees') === 'ca1dd62285fe061b4b7ffed87e4a9813560520a15ec962fe1d4080775b10e317'
    }

    /**
     * Set HostingFees storage.
     */
    get asV940(): {currencyId: v940.CurrencyId, maybeFeeSet: ([number, v940.V1MultiLocation] | undefined)} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set HostingFees storage.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.set_hosting_fees') === 'a4a58f0826c8b70c9639f2152d41c4a516042a8c789a43f2f49d2096ebe60c37'
    }

    /**
     * Set HostingFees storage.
     */
    get asV956(): {currencyId: v956.CurrencyId, maybeFeeSet: ([number, v956.V1MultiLocation] | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set HostingFees storage.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.set_hosting_fees') === 'e74f16ff9930633fb9791817e9027b55c6f33e16834f616270ed1b8276f5488d'
    }

    /**
     * Set HostingFees storage.
     */
    get asV962(): {currencyId: v962.CurrencyId, maybeFeeSet: ([number, v962.V1MultiLocation] | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set HostingFees storage.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.set_hosting_fees') === '357a324e9015be8266b6a942b478c9416899b37566f5d37e7e714b5c09cc3e18'
    }

    /**
     * Set HostingFees storage.
     */
    get asV970(): {currencyId: v970.CurrencyId, maybeFeeSet: ([number, v970.V1MultiLocation] | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set HostingFees storage.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.set_hosting_fees') === '54ca1a8e07de3371987fe7d14490233798fb527ca82e7959cb42fcf03f4f8ca0'
    }

    /**
     * Set HostingFees storage.
     */
    get asV972(): {currencyId: v972.CurrencyId, maybeFeeSet: ([number, v972.V3MultiLocation] | undefined)} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpSetMinimumsAndMaximumsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.set_minimums_and_maximums')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update storage MinimumsAndMaximums<T>.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.set_minimums_and_maximums') === '241cc262fbd09ac17463a10fe5a98c4d8e19073728c03fa9e40708ac4e3f12b0'
    }

    /**
     * Update storage MinimumsAndMaximums<T>.
     */
    get asV940(): {currencyId: v940.CurrencyId, constraints: (v940.MinimumsMaximums | undefined)} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage MinimumsAndMaximums<T>.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.set_minimums_and_maximums') === 'db926a33928e59202de1e694b5c9a4f958c4babbae94e32e5002a98f41672387'
    }

    /**
     * Update storage MinimumsAndMaximums<T>.
     */
    get asV946(): {currencyId: v946.CurrencyId, constraints: (v946.MinimumsMaximums | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage MinimumsAndMaximums<T>.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.set_minimums_and_maximums') === '3d1f96989c36ef90e5d2bd6641060a3006c9996ec4bbd05abcc94fa0cc446d90'
    }

    /**
     * Update storage MinimumsAndMaximums<T>.
     */
    get asV956(): {currencyId: v956.CurrencyId, constraints: (v956.MinimumsMaximums | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage MinimumsAndMaximums<T>.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.set_minimums_and_maximums') === '3eda2384e2ecba9b9dab0cd69fcfe08179544808f296975eb60031cf1a94fe79'
    }

    /**
     * Update storage MinimumsAndMaximums<T>.
     */
    get asV962(): {currencyId: v962.CurrencyId, constraints: (v962.MinimumsMaximums | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpSetOngoingTimeUnitUpdateIntervalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.set_ongoing_time_unit_update_interval')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set  OngoingTimeUnitUpdateInterval<T> storage.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.set_ongoing_time_unit_update_interval') === '8785618200b9368846582bb219a462b499ba4e7c39cbad9f4288bcf5c2bb0919'
    }

    /**
     * Set  OngoingTimeUnitUpdateInterval<T> storage.
     */
    get asV946(): {currencyId: v946.CurrencyId, maybeInterval: (number | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set  OngoingTimeUnitUpdateInterval<T> storage.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.set_ongoing_time_unit_update_interval') === 'd4cd78d3de94382f8ef57bd9f0bf28276c35cd93b32b3aca1a79045681d387d9'
    }

    /**
     * Set  OngoingTimeUnitUpdateInterval<T> storage.
     */
    get asV956(): {currencyId: v956.CurrencyId, maybeInterval: (number | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set  OngoingTimeUnitUpdateInterval<T> storage.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.set_ongoing_time_unit_update_interval') === '2928cc5d7f3e06666fd5a3ed39edc0abd854d126c7621267ad6984f9ab454692'
    }

    /**
     * Set  OngoingTimeUnitUpdateInterval<T> storage.
     */
    get asV962(): {currencyId: v962.CurrencyId, maybeInterval: (number | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpSetOperateOriginCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.set_operate_origin')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update storage OperateOrigins<T>.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.set_operate_origin') === '229d8879d9e9709ec3ff16385862161d6f58a117bf52fd684355e12046a285ed'
    }

    /**
     * Update storage OperateOrigins<T>.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: (Uint8Array | undefined)} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage OperateOrigins<T>.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.set_operate_origin') === '524820e5651d958a0060349ea779faff20947823e6b12c024ee2f9e10ff5a34b'
    }

    /**
     * Update storage OperateOrigins<T>.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: (Uint8Array | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage OperateOrigins<T>.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.set_operate_origin') === '8231825c43c50cb49b7e48820cda844bdb4f3d3d9b5f0952d2663d51a8ec4cf5'
    }

    /**
     * Update storage OperateOrigins<T>.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: (Uint8Array | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpSetValidatorsByDelegatorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.set_validators_by_delegator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update storage ValidatorsByDelegator<T>.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.set_validators_by_delegator') === '284ed477542e457c01b383c5a356a3562b071be965127f33a80c8b839b249429'
    }

    /**
     * Update storage ValidatorsByDelegator<T>.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation, validators: v940.V1MultiLocation[]} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage ValidatorsByDelegator<T>.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.set_validators_by_delegator') === '891e352315abe0ffa7e6aa82b15d8227f6ed54421e90b4ab5a4544cc732cd82f'
    }

    /**
     * Update storage ValidatorsByDelegator<T>.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation, validators: v956.V1MultiLocation[]} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage ValidatorsByDelegator<T>.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.set_validators_by_delegator') === '00f6e42d5a52a2364b83bd7dc81421f6ecad77fdb5778b92f2cf735d36f7301d'
    }

    /**
     * Update storage ValidatorsByDelegator<T>.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation, validators: v962.V1MultiLocation[]} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage ValidatorsByDelegator<T>.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.set_validators_by_delegator') === '0df0fc821f61a1ca72f547b3a5247ac91b00bc503f04f36d6d0f05727e77d5e9'
    }

    /**
     * Update storage ValidatorsByDelegator<T>.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation, validators: v970.V1MultiLocation[]} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update storage ValidatorsByDelegator<T>.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.set_validators_by_delegator') === 'f75b1f9fa96fe9ae6cc6c67b1d758c089986f58ad6aed70b33aa49e0f344541b'
    }

    /**
     * Update storage ValidatorsByDelegator<T>.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation, validators: v972.V3MultiLocation[]} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpSetXcmDestWeightAndFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.set_xcm_dest_weight_and_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * ****************************x/
     * ****** Storage Setters *****x/
     * ****************************x/
     * 
     * Update storage XcmDestWeightAndFee<T>.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.set_xcm_dest_weight_and_fee') === 'a6c711476235a51de17a18c0c8a51beaaf3baa8f86c174edb3b1899c287159c6'
    }

    /**
     * ****************************x/
     * ****** Storage Setters *****x/
     * ****************************x/
     * 
     * Update storage XcmDestWeightAndFee<T>.
     */
    get asV940(): {currencyId: v940.CurrencyId, operation: v940.XcmOperation, weightAndFee: ([bigint, bigint] | undefined)} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * ****************************x/
     * ****** Storage Setters *****x/
     * ****************************x/
     * 
     * Update storage XcmDestWeightAndFee<T>.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.set_xcm_dest_weight_and_fee') === '4f8eeb516761ccda9e0c60e40a82de80dfce332689f485cffb05e4fcb22a45e8'
    }

    /**
     * ****************************x/
     * ****** Storage Setters *****x/
     * ****************************x/
     * 
     * Update storage XcmDestWeightAndFee<T>.
     */
    get asV946(): {currencyId: v946.CurrencyId, operation: v946.XcmOperation, weightAndFee: ([bigint, bigint] | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * ****************************x/
     * ****** Storage Setters *****x/
     * ****************************x/
     * 
     * Update storage XcmDestWeightAndFee<T>.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.set_xcm_dest_weight_and_fee') === 'e96c853b5eebe6612d712fffced0b346f975a77ae4351d61d69a105802884c67'
    }

    /**
     * ****************************x/
     * ****** Storage Setters *****x/
     * ****************************x/
     * 
     * Update storage XcmDestWeightAndFee<T>.
     */
    get asV956(): {currencyId: v956.CurrencyId, operation: v956.XcmOperation, weightAndFee: ([bigint, bigint] | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * ****************************x/
     * ****** Storage Setters *****x/
     * ****************************x/
     * 
     * Update storage XcmDestWeightAndFee<T>.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.set_xcm_dest_weight_and_fee') === '10243cb94a552f540ef470665b730d3f28017ec4b5396e690d81533882171d2d'
    }

    /**
     * ****************************x/
     * ****** Storage Setters *****x/
     * ****************************x/
     * 
     * Update storage XcmDestWeightAndFee<T>.
     */
    get asV962(): {currencyId: v962.CurrencyId, operation: v962.XcmOperation, weightAndFee: ([bigint, bigint] | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * ****************************x/
     * ****** Storage Setters *****x/
     * ****************************x/
     * 
     * Update storage XcmDestWeightAndFee<T>.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.set_xcm_dest_weight_and_fee') === 'ebd2d05f67a9dfa834004bd17493691e03875a795fc17f030bcd4bb5fdb0601b'
    }

    /**
     * ****************************x/
     * ****** Storage Setters *****x/
     * ****************************x/
     * 
     * Update storage XcmDestWeightAndFee<T>.
     */
    get asV970(): {currencyId: v970.CurrencyId, operation: v970.XcmOperation, weightAndFee: ([bigint, bigint] | undefined)} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * ****************************x/
     * ****** Storage Setters *****x/
     * ****************************x/
     * 
     * Update storage XcmDestWeightAndFee<T>.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.set_xcm_dest_weight_and_fee') === '1598e459d378a368e7d5fca7b08b78b79921151fa17ae03a7b8f7bd3132263dc'
    }

    /**
     * ****************************x/
     * ****** Storage Setters *****x/
     * ****************************x/
     * 
     * Update storage XcmDestWeightAndFee<T>.
     */
    get asV972(): {currencyId: v972.CurrencyId, operation: v972.XcmOperation, weightAndFee: ([v972.Weight, bigint] | undefined)} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpSupplementFeeReserveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.supplement_fee_reserve')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('Slp.supplement_fee_reserve') === '911b971f4b3a762043cac5bc7a104b3e6f3b723bb1d5e4d370bf5c5065c55302'
    }

    get asV940(): {currencyId: v940.CurrencyId, dest: v940.V1MultiLocation} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Slp.supplement_fee_reserve') === '47dbdc7754783af8d1720e26e68a446b5e6764ff9bed98fc9d06ab9cd3e8d2a7'
    }

    get asV956(): {currencyId: v956.CurrencyId, dest: v956.V1MultiLocation} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Slp.supplement_fee_reserve') === '086daf8a45f2232dc1e2bb26e03b9f1b8ba393b24f72d05784b9fa73664eeae4'
    }

    get asV962(): {currencyId: v962.CurrencyId, dest: v962.V1MultiLocation} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('Slp.supplement_fee_reserve') === '94b57c90ecfc02e92deafca040d7ae84e6a4c18c06915002607fae50f1772b8d'
    }

    get asV970(): {currencyId: v970.CurrencyId, dest: v970.V1MultiLocation} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    get isV972(): boolean {
        return this._chain.getCallHash('Slp.supplement_fee_reserve') === '6b5059ef9445aef0eb34788189a2e8006bd974fc57afcf8ce2d82624e5f3a9bc'
    }

    get asV972(): {currencyId: v972.CurrencyId, dest: v972.V3MultiLocation} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpTransferBackCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.transfer_back')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('Slp.transfer_back') === '12655dc5a074112a9038ec8c37591bf78e4ed21ad758efab27357bc2f79fc658'
    }

    get asV940(): {currencyId: v940.CurrencyId, from: v940.V1MultiLocation, to: v940.V1MultiLocation, amount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Slp.transfer_back') === '0cef9902969904fdaa17a23908f4655a96ba771cbc7586fa7180d0f54e0eca64'
    }

    get asV956(): {currencyId: v956.CurrencyId, from: v956.V1MultiLocation, to: v956.V1MultiLocation, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Slp.transfer_back') === 'd446d62d68f5e0230a346e9eafefd2ea3c3b65300a2401e834e13ec3f82ea2af'
    }

    get asV962(): {currencyId: v962.CurrencyId, from: v962.V1MultiLocation, to: v962.V1MultiLocation, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('Slp.transfer_back') === 'f5ee40980835ccae680355396d11224587ea901de760b71708e239a1c04edb65'
    }

    get asV970(): {currencyId: v970.CurrencyId, from: v970.V1MultiLocation, to: v970.V1MultiLocation, amount: bigint} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    get isV972(): boolean {
        return this._chain.getCallHash('Slp.transfer_back') === '506f9e4fa34f23ff6ad95427388a738b204392baefd5158808ea1d1e4f688b4d'
    }

    get asV972(): {currencyId: v972.CurrencyId, from: v972.V3MultiLocation, to: v972.V3MultiLocation, amount: bigint} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpTransferToCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.transfer_to')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('Slp.transfer_to') === '12655dc5a074112a9038ec8c37591bf78e4ed21ad758efab27357bc2f79fc658'
    }

    get asV940(): {currencyId: v940.CurrencyId, from: v940.V1MultiLocation, to: v940.V1MultiLocation, amount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Slp.transfer_to') === '0cef9902969904fdaa17a23908f4655a96ba771cbc7586fa7180d0f54e0eca64'
    }

    get asV956(): {currencyId: v956.CurrencyId, from: v956.V1MultiLocation, to: v956.V1MultiLocation, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Slp.transfer_to') === 'd446d62d68f5e0230a346e9eafefd2ea3c3b65300a2401e834e13ec3f82ea2af'
    }

    get asV962(): {currencyId: v962.CurrencyId, from: v962.V1MultiLocation, to: v962.V1MultiLocation, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('Slp.transfer_to') === 'f5ee40980835ccae680355396d11224587ea901de760b71708e239a1c04edb65'
    }

    get asV970(): {currencyId: v970.CurrencyId, from: v970.V1MultiLocation, to: v970.V1MultiLocation, amount: bigint} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    get isV972(): boolean {
        return this._chain.getCallHash('Slp.transfer_to') === '506f9e4fa34f23ff6ad95427388a738b204392baefd5158808ea1d1e4f688b4d'
    }

    get asV972(): {currencyId: v972.CurrencyId, from: v972.V3MultiLocation, to: v972.V3MultiLocation, amount: bigint} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpUnbondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.unbond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.unbond') === 'd85a66b02c55b5025622329c2e1300b7c3829fb11be22746a96be23cc135b94e'
    }

    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation, amount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Slp.unbond') === 'c5461acffe61b70ce2bf3890afdec9283ec0dcb8c747c8f734c1aaf5fff37d2a'
    }

    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    get asV946(): {currencyId: v946.CurrencyId, who: v946.V1MultiLocation, validator: (v946.V1MultiLocation | undefined), amount: bigint} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.unbond') === 'b59dea852702fb0cb9af8096febba2039c961d5aeb18606cb49f899e3588d7c5'
    }

    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation, validator: (v956.V1MultiLocation | undefined), amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.unbond') === 'c7a74604ee456544693a727fae681ae773b03bb335169ba3c47c06f4e725924e'
    }

    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation, validator: (v962.V1MultiLocation | undefined), amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.unbond') === '8408eb162eb665b063bea3d1917c92eeeb57fe4d8bc02b8c16558425c1137e30'
    }

    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation, validator: (v970.V1MultiLocation | undefined), amount: bigint} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.unbond') === '4ba41b276257fe560429ea23dbceb09986af703f496bbeaec083b9bbaeecf46e'
    }

    /**
     * Decrease some amount to a delegator. Leave no less than the minimum delegator
     * requirement.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation, validator: (v972.V3MultiLocation | undefined), amount: bigint} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpUnbondAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.unbond_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unbond all the active amount of a delegator.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.unbond_all') === '9d021e63f24596510d85764848b1d886266574ab6e15db483fc8c5275e1b851b'
    }

    /**
     * Unbond all the active amount of a delegator.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Unbond all the active amount of a delegator.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.unbond_all') === 'a7ba15ac327ecdd5973b4b5f69588f7e5efcd1c575f7417d1bff79d220c5a9e8'
    }

    /**
     * Unbond all the active amount of a delegator.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Unbond all the active amount of a delegator.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.unbond_all') === '8bce49f5614ac91e8dd1d99bc3b0ec4599a2e166b774ace6466afe55e03dd498'
    }

    /**
     * Unbond all the active amount of a delegator.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Unbond all the active amount of a delegator.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.unbond_all') === '219009164c74bd725d0ddeda33eb4c157a3b4dc7ddd0393a818976c6e8cdcff5'
    }

    /**
     * Unbond all the active amount of a delegator.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Unbond all the active amount of a delegator.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.unbond_all') === 'ec87264805a12c1c8157c39e6de627fc752dbd2f0958e747fe5c3f9a4a19532b'
    }

    /**
     * Unbond all the active amount of a delegator.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpUndelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.undelegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Slp.undelegate') === '77fda9ae789f04fb1232291758723fe4d70550d88f787f31641c4d2e10bfceb4'
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get asV940(): {currencyId: v940.CurrencyId, who: v940.V1MultiLocation, targets: v940.V1MultiLocation[]} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Slp.undelegate') === '93afdb0906249d8a3dcfc5f2673c4be905779e31b7b355f50c36e8f4bf51158e'
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get asV956(): {currencyId: v956.CurrencyId, who: v956.V1MultiLocation, targets: v956.V1MultiLocation[]} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Slp.undelegate') === 'f118c6b2822664c8cee2e782be337201078cb65dacb0e3fe90ca2a011f358e06'
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get asV962(): {currencyId: v962.CurrencyId, who: v962.V1MultiLocation, targets: v962.V1MultiLocation[]} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Slp.undelegate') === 'e73e44ea73ecc631339970f175a934d68ff3ab9ff65b7f66fc7d7aff026b8cbe'
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get asV970(): {currencyId: v970.CurrencyId, who: v970.V1MultiLocation, targets: v970.V1MultiLocation[]} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Slp.undelegate') === 'eaffe467c13dd67c77396813bddbd1ca6015af425423b79fa29f7053a9f1d56d'
    }

    /**
     * Re-delegate existing delegation to a new validator set.
     */
    get asV972(): {currencyId: v972.CurrencyId, who: v972.V3MultiLocation, targets: v972.V3MultiLocation[]} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class SlpUpdateOngoingTimeUnitCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slp.update_ongoing_time_unit')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('Slp.update_ongoing_time_unit') === '32dfb3e97ff29040a01c9382a79b066918ca1ab72e74e9e96a70a1258df5b4d1'
    }

    get asV940(): {currencyId: v940.CurrencyId, timeUnit: v940.TimeUnit} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV946(): boolean {
        return this._chain.getCallHash('Slp.update_ongoing_time_unit') === '4f7a58cce41fc3c37c2e458ad7a7b2827db35de5aaecc7e15031dfb96544a393'
    }

    get asV946(): {currencyId: v946.CurrencyId, timeUnit: v946.TimeUnit} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('Slp.update_ongoing_time_unit') === '8108db0f41f25ebb2bf65ff5f95c2a8397f507bb72f5c046d7a094fdf03b89b5'
    }

    get asV956(): {currencyId: v956.CurrencyId, timeUnit: v956.TimeUnit} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('Slp.update_ongoing_time_unit') === 'df7d9bdd4082a69fe0f577d72734cc89487f5affcd1b9532ac033d84a5b63620'
    }

    get asV962(): {currencyId: v962.CurrencyId, timeUnit: v962.TimeUnit} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('Slp.update_ongoing_time_unit') === '2fc35a58b5e38f5b153fea8e6f7726b9018bdd4ddfa4ef04db0bff5bb4529993'
    }

    get asV970(): {currencyId: v970.CurrencyId, timeUnit: v970.TimeUnit} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }
}

export class SudoSetKeyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Sudo.set_key')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Sudo.set_key') === 'd0eb457ece644571cebe79cbdd64ef1453c382048ffec79f9c403f7bc8f90020'
    }

    /**
     *  Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get asV1(): {new: v1.LookupSource} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SudoSudoCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Sudo.sudo')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === '86351cf05129e3868f7df7579ee974b4d024fbb261018e4035d4fbc3e346bd14'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get asV1(): {call: v1.Type_51} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get isV801(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === '184ed0fe9a95a75048add7a8356e73227a049cba1660f47ea34cf62343bdbd3f'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get asV801(): {call: v801.Type_48} {
        assert(this.isV801)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === 'f0ec7d00795379734960c674d2145e2f8a7099253717022ea10ce4021baac6f2'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get asV802(): {call: v802.Type_48} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === '48939f9a5ba1032064e0fb22df67de7b1115a5ee54c1162942b9017913a5709c'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get asV803(): {call: v803.Type_51} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === 'ab43b015178669dbb587c4ebe14d74baf09fadc9f43cbfb0a5b76cf90b29b644'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get asV804(): {call: v804.Type_51} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }
}

export class SudoSudoAsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Sudo.sudo_as')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '17cd3d7bb31d82e7bd0fef8a52eb11735a016cf4fee10fd9f6dde5e5ee07e706'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get asV1(): {who: v1.LookupSource, call: v1.Type_51} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get isV801(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === 'b4624f549f677cf058f867b2aca83dd4a807746846973dcdf943e1ce209cf29d'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get asV801(): {who: v801.LookupSource, call: v801.Type_48} {
        assert(this.isV801)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '5700487c3e58b8ca680e27d6b0b1fda51cc1bb9e408e4ffbb57b331979773b87'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get asV802(): {who: v802.LookupSource, call: v802.Type_48} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '7ca35bf6f7b071b0b13bf88fc5ade58a38c8ecbfbd0aaac22c69ba0294fad6e9'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get asV803(): {who: v803.LookupSource, call: v803.Type_51} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '025e525912582ee097b3fc10d43a7151b790ce077ec062ed1e853b0fddd36ced'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Weight of derivative `call` execution + 10,000.
     *  # </weight>
     */
    get asV804(): {who: v804.LookupSource, call: v804.Type_51} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }
}

export class SudoSudoUncheckedWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Sudo.sudo_unchecked_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     *  This function does not check the weight of the call, and instead allows the
     *  Sudo user to specify the weight of the call.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - The weight of this call is defined by the caller.
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '1a6f08160661a1f50569065bf6169e207fd7d337ddba158bd2ea946125f511ea'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     *  This function does not check the weight of the call, and instead allows the
     *  Sudo user to specify the weight of the call.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - The weight of this call is defined by the caller.
     *  # </weight>
     */
    get asV1(): {call: v1.Type_51, weight: bigint} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     *  This function does not check the weight of the call, and instead allows the
     *  Sudo user to specify the weight of the call.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - The weight of this call is defined by the caller.
     *  # </weight>
     */
    get isV801(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '0d4431453f98d545a245094d8f2b8efa5017fe6375252b50269ab07868a73237'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     *  This function does not check the weight of the call, and instead allows the
     *  Sudo user to specify the weight of the call.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - The weight of this call is defined by the caller.
     *  # </weight>
     */
    get asV801(): {call: v801.Type_48, weight: bigint} {
        assert(this.isV801)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     *  This function does not check the weight of the call, and instead allows the
     *  Sudo user to specify the weight of the call.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - The weight of this call is defined by the caller.
     *  # </weight>
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '85fd1d8aee7333a483ef8bd79554f1b220058431726c7b764710cc7299ff1676'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     *  This function does not check the weight of the call, and instead allows the
     *  Sudo user to specify the weight of the call.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - The weight of this call is defined by the caller.
     *  # </weight>
     */
    get asV802(): {call: v802.Type_48, weight: bigint} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     *  This function does not check the weight of the call, and instead allows the
     *  Sudo user to specify the weight of the call.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - The weight of this call is defined by the caller.
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '5cf8efeb82f77bc284129167167cde3aed14b7b4d12891e5b7850bc1c352138a'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     *  This function does not check the weight of the call, and instead allows the
     *  Sudo user to specify the weight of the call.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - The weight of this call is defined by the caller.
     *  # </weight>
     */
    get asV803(): {call: v803.Type_51, weight: bigint} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     *  This function does not check the weight of the call, and instead allows the
     *  Sudo user to specify the weight of the call.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - The weight of this call is defined by the caller.
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Sudo.sudo_unchecked_weight') === '981fca69d44e8ea619d6d0ca498d390fb518dc7fe94e9c8a7603fa5085929b15'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     *  This function does not check the weight of the call, and instead allows the
     *  Sudo user to specify the weight of the call.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - The weight of this call is defined by the caller.
     *  # </weight>
     */
    get asV804(): {call: v804.Type_51, weight: bigint} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemFillBlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.fill_block')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  A dispatch that will fill the block weight up to the given ratio.
     */
    get isV1(): boolean {
        return this._chain.getCallHash('System.fill_block') === '41c1841312db092642508be699e4a3f54d52efe2dcaa8101ca9518398fb70c49'
    }

    /**
     *  A dispatch that will fill the block weight up to the given ratio.
     */
    get asV1(): {ratio: number} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemKillPrefixCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.kill_prefix')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Kill all storage items with a key that starts with the given prefix.
     * 
     *  **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     *  the prefix we are removing to accurately calculate the weight of this function.
     * 
     *  # <weight>
     *  - `O(P)` where `P` amount of keys with prefix `prefix`
     *  - `P` storage deletions.
     *  - Base Weight: 0.834 * P µs
     *  - Writes: Number of subkeys + 1
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('System.kill_prefix') === 'dfbadd42bee8b18fc81cf78683511061181cffbf7a8ebfd3e5719c389b373d93'
    }

    /**
     *  Kill all storage items with a key that starts with the given prefix.
     * 
     *  **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     *  the prefix we are removing to accurately calculate the weight of this function.
     * 
     *  # <weight>
     *  - `O(P)` where `P` amount of keys with prefix `prefix`
     *  - `P` storage deletions.
     *  - Base Weight: 0.834 * P µs
     *  - Writes: Number of subkeys + 1
     *  # </weight>
     */
    get asV1(): {prefix: Uint8Array, subkeys: number} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemKillStorageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.kill_storage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Kill some items from storage.
     * 
     *  # <weight>
     *  - `O(IK)` where `I` length of `keys` and `K` length of one key
     *  - `I` storage deletions.
     *  - Base Weight: .378 * i µs
     *  - Writes: Number of items
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('System.kill_storage') === 'eac21dc14e927c003d9c634fb019d04128f71f8529d2914b10a56b85289c2c11'
    }

    /**
     *  Kill some items from storage.
     * 
     *  # <weight>
     *  - `O(IK)` where `I` length of `keys` and `K` length of one key
     *  - `I` storage deletions.
     *  - Base Weight: .378 * i µs
     *  - Writes: Number of items
     *  # </weight>
     */
    get asV1(): {keys: Uint8Array[]} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemRemarkCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.remark')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Make some on-chain remark.
     * 
     *  # <weight>
     *  - `O(1)`
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('System.remark') === 'f4e9b5b7572eeae92978087ece9b4f57cb5cab4f16baf5625bb9ec4a432bad63'
    }

    /**
     *  Make some on-chain remark.
     * 
     *  # <weight>
     *  - `O(1)`
     *  # </weight>
     */
    get asV1(): {remark: Uint8Array} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemRemarkWithEventCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.remark_with_event')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Make some on-chain remark and emit event.
     * 
     *  # <weight>
     *  - `O(b)` where b is the length of the remark.
     *  - 1 event.
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('System.remark_with_event') === 'f4e9b5b7572eeae92978087ece9b4f57cb5cab4f16baf5625bb9ec4a432bad63'
    }

    /**
     *  Make some on-chain remark and emit event.
     * 
     *  # <weight>
     *  - `O(b)` where b is the length of the remark.
     *  - 1 event.
     *  # </weight>
     */
    get asV1(): {remark: Uint8Array} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetChangesTrieConfigCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_changes_trie_config')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the new changes trie configuration.
     * 
     *  # <weight>
     *  - `O(1)`
     *  - 1 storage write or delete (codec `O(1)`).
     *  - 1 call to `deposit_log`: Uses `append` API, so O(1)
     *  - Base Weight: 7.218 µs
     *  - DB Weight:
     *      - Writes: Changes Trie, System Digest
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('System.set_changes_trie_config') === 'ced137e2f8792ce87e1f2b20f97e1de9a31001f9c44069dc6e73b9e4c061c311'
    }

    /**
     *  Set the new changes trie configuration.
     * 
     *  # <weight>
     *  - `O(1)`
     *  - 1 storage write or delete (codec `O(1)`).
     *  - 1 call to `deposit_log`: Uses `append` API, so O(1)
     *  - Base Weight: 7.218 µs
     *  - DB Weight:
     *      - Writes: Changes Trie, System Digest
     *  # </weight>
     */
    get asV1(): {changesTrieConfig: (v1.ChangesTrieConfiguration | undefined)} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetCodeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_code')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the new runtime code.
     * 
     *  # <weight>
     *  - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`
     *  - 1 storage write (codec `O(C)`).
     *  - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).
     *  - 1 event.
     *  The weight of this function is dependent on the runtime, but generally this is very expensive.
     *  We will treat this as a full block.
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('System.set_code') === '7bf3d4785d9be7a4872f39cbd3702a66e16f7ee01e4446fb4a05624dc0ec4c93'
    }

    /**
     *  Set the new runtime code.
     * 
     *  # <weight>
     *  - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`
     *  - 1 storage write (codec `O(C)`).
     *  - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).
     *  - 1 event.
     *  The weight of this function is dependent on the runtime, but generally this is very expensive.
     *  We will treat this as a full block.
     *  # </weight>
     */
    get asV1(): {code: Uint8Array} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetCodeWithoutChecksCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_code_without_checks')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the new runtime code without doing any checks of the given `code`.
     * 
     *  # <weight>
     *  - `O(C)` where `C` length of `code`
     *  - 1 storage write (codec `O(C)`).
     *  - 1 event.
     *  The weight of this function is dependent on the runtime. We will treat this as a full block.
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('System.set_code_without_checks') === '7bf3d4785d9be7a4872f39cbd3702a66e16f7ee01e4446fb4a05624dc0ec4c93'
    }

    /**
     *  Set the new runtime code without doing any checks of the given `code`.
     * 
     *  # <weight>
     *  - `O(C)` where `C` length of `code`
     *  - 1 storage write (codec `O(C)`).
     *  - 1 event.
     *  The weight of this function is dependent on the runtime. We will treat this as a full block.
     *  # </weight>
     */
    get asV1(): {code: Uint8Array} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetHeapPagesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_heap_pages')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the number of pages in the WebAssembly environment's heap.
     * 
     *  # <weight>
     *  - `O(1)`
     *  - 1 storage write.
     *  - Base Weight: 1.405 µs
     *  - 1 write to HEAP_PAGES
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('System.set_heap_pages') === '130172e47c5e517627712b4d084768b98489d920284223ea8ef9c462339b5808'
    }

    /**
     *  Set the number of pages in the WebAssembly environment's heap.
     * 
     *  # <weight>
     *  - `O(1)`
     *  - 1 storage write.
     *  - Base Weight: 1.405 µs
     *  - 1 write to HEAP_PAGES
     *  # </weight>
     */
    get asV1(): {pages: bigint} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetStorageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_storage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set some items of storage.
     * 
     *  # <weight>
     *  - `O(I)` where `I` length of `items`
     *  - `I` storage writes (`O(1)`).
     *  - Base Weight: 0.568 * i µs
     *  - Writes: Number of items
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('System.set_storage') === 'a4fb507615d69849afb1b2ee654006f9be48bb6e960a4674624d6e46e4382083'
    }

    /**
     *  Set some items of storage.
     * 
     *  # <weight>
     *  - `O(I)` where `I` length of `items`
     *  - `I` storage writes (`O(1)`).
     *  - Base Weight: 0.568 * i µs
     *  - Writes: Number of items
     *  # </weight>
     */
    get asV1(): {items: [Uint8Array, Uint8Array][]} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemMakerChargeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SystemMaker.charge')
        this._chain = ctx._chain
        this.call = call
    }

    get isV958(): boolean {
        return this._chain.getCallHash('SystemMaker.charge') === '4b07a2f7ad01ad9a9a7738fb7dca3b76067261e92bd0a6f6cae579411684dfd3'
    }

    get asV958(): {currencyId: v958.CurrencyId, value: bigint} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('SystemMaker.charge') === '04cf6294238c766321d8c4574741d0f78b501f24504605089904aac4485400f1'
    }

    get asV962(): {currencyId: v962.CurrencyId, value: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemMakerCloseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SystemMaker.close')
        this._chain = ctx._chain
        this.call = call
    }

    get isV958(): boolean {
        return this._chain.getCallHash('SystemMaker.close') === '7d8a3e7d779f11164e04f6a37a9fa89298621358fdfcab3b535b4b783a6c8037'
    }

    get asV958(): {currencyId: v958.CurrencyId} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('SystemMaker.close') === '0a9d3c015dc155696ea30a98c73282f04dad76fa0e64157d75dc0b4c7d3bfec6'
    }

    get asV962(): {currencyId: v962.CurrencyId} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemMakerPayoutCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SystemMaker.payout')
        this._chain = ctx._chain
        this.call = call
    }

    get isV958(): boolean {
        return this._chain.getCallHash('SystemMaker.payout') === '4b07a2f7ad01ad9a9a7738fb7dca3b76067261e92bd0a6f6cae579411684dfd3'
    }

    get asV958(): {currencyId: v958.CurrencyId, value: bigint} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('SystemMaker.payout') === '04cf6294238c766321d8c4574741d0f78b501f24504605089904aac4485400f1'
    }

    get asV962(): {currencyId: v962.CurrencyId, value: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemMakerSetConfigCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SystemMaker.set_config')
        this._chain = ctx._chain
        this.call = call
    }

    get isV958(): boolean {
        return this._chain.getCallHash('SystemMaker.set_config') === 'da300b127395be32621f273dbb938214f300b404147554b4d59ebdc50fe05166'
    }

    get asV958(): {currencyId: v958.CurrencyId, info: v958.Info} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('SystemMaker.set_config') === 'a703a6d06ec86f1897a89f7a3a5c1b58e6db2c3fdb9929c643f32b4d5760e4ac'
    }

    get asV962(): {currencyId: v962.CurrencyId, info: v962.Info} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemStakingDeleteTokenCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SystemStaking.delete_token')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * token config，take effect when next round begins
     */
    get isV946(): boolean {
        return this._chain.getCallHash('SystemStaking.delete_token') === '64f6b79ffb8474857cb1be3706cdc0e6acbf3e7375c5a43cd8e81b9d2cd79e43'
    }

    /**
     * token config，take effect when next round begins
     */
    get asV946(): {token: v946.CurrencyId} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * token config，take effect when next round begins
     */
    get isV956(): boolean {
        return this._chain.getCallHash('SystemStaking.delete_token') === '40f4594ef0b65d4664f6f785a585d23a5ec2b86eb9df238440ce48917caad9e3'
    }

    /**
     * token config，take effect when next round begins
     */
    get asV956(): {token: v956.CurrencyId} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * token config，take effect when next round begins
     */
    get isV962(): boolean {
        return this._chain.getCallHash('SystemStaking.delete_token') === 'ca24a795764a83be845d4091cbc7dceb56ecba7f3253c59683cc66c303fe45ff'
    }

    /**
     * token config，take effect when next round begins
     */
    get asV962(): {token: v962.CurrencyId} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemStakingPayoutCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SystemStaking.payout')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * payout to treasury
     */
    get isV946(): boolean {
        return this._chain.getCallHash('SystemStaking.payout') === '64f6b79ffb8474857cb1be3706cdc0e6acbf3e7375c5a43cd8e81b9d2cd79e43'
    }

    /**
     * payout to treasury
     */
    get asV946(): {token: v946.CurrencyId} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * payout to treasury
     */
    get isV956(): boolean {
        return this._chain.getCallHash('SystemStaking.payout') === '40f4594ef0b65d4664f6f785a585d23a5ec2b86eb9df238440ce48917caad9e3'
    }

    /**
     * payout to treasury
     */
    get asV956(): {token: v956.CurrencyId} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * payout to treasury
     */
    get isV962(): boolean {
        return this._chain.getCallHash('SystemStaking.payout') === 'ca24a795764a83be845d4091cbc7dceb56ecba7f3253c59683cc66c303fe45ff'
    }

    /**
     * payout to treasury
     */
    get asV962(): {token: v962.CurrencyId} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemStakingRefreshTokenInfoCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SystemStaking.refresh_token_info')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * refresh token info，query farming pallet, and update TokenInfo, change to new
     * config，ignore exec_delay, execute immediately
     */
    get isV946(): boolean {
        return this._chain.getCallHash('SystemStaking.refresh_token_info') === '64f6b79ffb8474857cb1be3706cdc0e6acbf3e7375c5a43cd8e81b9d2cd79e43'
    }

    /**
     * refresh token info，query farming pallet, and update TokenInfo, change to new
     * config，ignore exec_delay, execute immediately
     */
    get asV946(): {token: v946.CurrencyId} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * refresh token info，query farming pallet, and update TokenInfo, change to new
     * config，ignore exec_delay, execute immediately
     */
    get isV956(): boolean {
        return this._chain.getCallHash('SystemStaking.refresh_token_info') === '40f4594ef0b65d4664f6f785a585d23a5ec2b86eb9df238440ce48917caad9e3'
    }

    /**
     * refresh token info，query farming pallet, and update TokenInfo, change to new
     * config，ignore exec_delay, execute immediately
     */
    get asV956(): {token: v956.CurrencyId} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * refresh token info，query farming pallet, and update TokenInfo, change to new
     * config，ignore exec_delay, execute immediately
     */
    get isV962(): boolean {
        return this._chain.getCallHash('SystemStaking.refresh_token_info') === 'ca24a795764a83be845d4091cbc7dceb56ecba7f3253c59683cc66c303fe45ff'
    }

    /**
     * refresh token info，query farming pallet, and update TokenInfo, change to new
     * config，ignore exec_delay, execute immediately
     */
    get asV962(): {token: v962.CurrencyId} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemStakingTokenConfigCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'SystemStaking.token_config')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * token config，take effect when next round begins
     */
    get isV946(): boolean {
        return this._chain.getCallHash('SystemStaking.token_config') === 'f78f97657d4044a2531ab4c6e236e7eafc6701af2af51ca9d9734079dab32e8d'
    }

    /**
     * token config，take effect when next round begins
     */
    get asV946(): {token: v946.CurrencyId, execDelay: (number | undefined), systemStakableFarmingRate: (number | undefined), addOrSub: (boolean | undefined), systemStakableBase: (bigint | undefined), farmingPoolids: (number[] | undefined), lptokenRates: (number[] | undefined)} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * token config，take effect when next round begins
     */
    get isV956(): boolean {
        return this._chain.getCallHash('SystemStaking.token_config') === '870223a345cb6debffdb16ff89ce6f6d15bc354c11f1567792a8fa6825450c7b'
    }

    /**
     * token config，take effect when next round begins
     */
    get asV956(): {token: v956.CurrencyId, execDelay: (number | undefined), systemStakableFarmingRate: (number | undefined), addOrSub: (boolean | undefined), systemStakableBase: (bigint | undefined), farmingPoolids: (number[] | undefined), lptokenRates: (number[] | undefined)} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * token config，take effect when next round begins
     */
    get isV962(): boolean {
        return this._chain.getCallHash('SystemStaking.token_config') === 'd25c2ec3ba27771f89cdc6f136895729d911c8a76e2773501eee8a306b415b2a'
    }

    /**
     * token config，take effect when next round begins
     */
    get asV962(): {token: v962.CurrencyId, execDelay: (number | undefined), systemStakableFarmingRate: (number | undefined), addOrSub: (boolean | undefined), systemStakableBase: (bigint | undefined), farmingPoolids: (number[] | undefined), lptokenRates: (number[] | undefined)} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeCloseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.close')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     *  May be called by any signed account in order to finish voting and close the proposal.
     * 
     *  If called before the end of the voting period it will only close the vote if it is
     *  has enough votes to be approved or disapproved.
     * 
     *  If called after the end of the voting period abstentions are counted as rejections
     *  unless there is a prime member set and the prime member cast an approval.
     * 
     *  If the close operation completes successfully with disapproval, the transaction fee will
     *  be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     *  + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.
     *  + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     *                    `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1 + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - `P1` is the complexity of `proposal` preimage.
     *    - `P2` is proposal-count (code-bounded)
     *  - DB:
     *   - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *   - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)
     *   - any mutations done while executing `proposal` (`P1`)
     *  - up to 3 events
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.close') === '45a5978a11ceb5a8b2c51f7152abaa939cd8bd4bcdc5e1162029cedba4b598ea'
    }

    /**
     *  Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     *  May be called by any signed account in order to finish voting and close the proposal.
     * 
     *  If called before the end of the voting period it will only close the vote if it is
     *  has enough votes to be approved or disapproved.
     * 
     *  If called after the end of the voting period abstentions are counted as rejections
     *  unless there is a prime member set and the prime member cast an approval.
     * 
     *  If the close operation completes successfully with disapproval, the transaction fee will
     *  be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     *  + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.
     *  + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     *                    `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1 + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - `P1` is the complexity of `proposal` preimage.
     *    - `P2` is proposal-count (code-bounded)
     *  - DB:
     *   - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *   - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)
     *   - any mutations done while executing `proposal` (`P1`)
     *  - up to 3 events
     *  # </weight>
     */
    get asV803(): {proposalHash: Uint8Array, index: number, proposalWeightBound: bigint, lengthBound: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.close') === 'a88911953f51bddf0f0aeafa7caa7ca904d30cdb24f940ff177d2acf7088d3bd'
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get asV968(): {proposalHash: Uint8Array, index: number, proposalWeightBound: v968.Weight, lengthBound: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeCloseOldWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.close_old_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.close_old_weight') === '45a5978a11ceb5a8b2c51f7152abaa939cd8bd4bcdc5e1162029cedba4b598ea'
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get asV968(): {proposalHash: Uint8Array, index: number, proposalWeightBound: bigint, lengthBound: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeDisapproveProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.disapprove_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Disapprove a proposal, close, and remove it from the system, regardless of its current state.
     * 
     *  Must be called by the Root origin.
     * 
     *  Parameters:
     *  * `proposal_hash`: The hash of the proposal that should be disapproved.
     * 
     *  # <weight>
     *  Complexity: O(P) where P is the number of max proposals
     *  DB Weight:
     *  * Reads: Proposals
     *  * Writes: Voting, Proposals, ProposalOf
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.disapprove_proposal') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Disapprove a proposal, close, and remove it from the system, regardless of its current state.
     * 
     *  Must be called by the Root origin.
     * 
     *  Parameters:
     *  * `proposal_hash`: The hash of the proposal that should be disapproved.
     * 
     *  # <weight>
     *  Complexity: O(P) where P is the number of max proposals
     *  DB Weight:
     *  * Reads: Proposals
     *  * Writes: Voting, Proposals, ProposalOf
     *  # </weight>
     */
    get asV803(): {proposalHash: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeExecuteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.execute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '27f6a6026111ae912cb775e7c7575ac686a5246ab2023eefb2a4c6cf0b0a10f7'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV803(): {proposal: v803.Proposal, lengthBound: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '8850de99fc2383fea1e7b57ee91d7e0344547bd550b5f9edd969e20b8316cbed'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV804(): {proposal: v804.Proposal, lengthBound: number} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV805(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'd9beed75f76bee3d1d51830a36bea790fe2f299013dc1c2d47e8306dfae0e58f'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV805(): {proposal: v805.Proposal, lengthBound: number} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV900(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '1e92547ce4d17433a13b9787015b7637d7180d0320a22d6141642efe4e2bd640'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV900(): {proposal: v900.Proposal, lengthBound: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV901(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '13919797c046b3f2c226e33bdb37783265aeb9ec62066ff7213d1daa55bc685e'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV901(): {proposal: v901.Proposal, lengthBound: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV902(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '1301104cd7dc0913dee33169f560f38004241998429c7f907272b720b6500b6b'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV902(): {proposal: v902.Proposal, lengthBound: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV906(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '0226d7889075d9de23eae00a0f4f8506369c481f563020d18d7899f4789e816d'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV906(): {proposal: v906.Call, lengthBound: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'dfcbb7a3bd8c12241fe884340f5a0eb4342d6353df6b41bd2f466324564d73a3'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV908(): {proposal: v908.Call, lengthBound: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV910(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '3946658118c41c09817fb96079b8a80dc1869ad2e8dddefa60e21be947644e2f'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV910(): {proposal: v910.Call, lengthBound: number} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV912(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'f4d616078afaf8d66b7f449abc5929045286d49f0356ac165bad90ab55793ebe'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV912(): {proposal: v912.Call, lengthBound: number} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV914(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'a253f2ffdad4ce4963fabdcbdb4f0ecb699a8ffb62b86bf6d17920d79be5582b'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV914(): {proposal: v914.Call, lengthBound: number} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV915(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '46f8efcbc4205f7d5063aa4112148197705c2f21c14d96eb2cca8d9655388bc4'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV915(): {proposal: v915.Call, lengthBound: number} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV916(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'ddba31f02ddc643e11a28819f5f2b8c5ce608509a7912a8e3b8d82621308b75d'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV916(): {proposal: v916.Call, lengthBound: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV918(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '60311d415a7c99d5d81d5b48e18043ebd41a8cee6c24f6c06784c153d78ea611'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV918(): {proposal: v918.Call, lengthBound: number} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV920(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '53c6f266dc888e69d85d729e026dcac368f25ca6c90a13a8e23e19f108385302'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV920(): {proposal: v920.Call, lengthBound: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV922(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'ae81b2670e133df35551453cbac26008cb81e1f9119cf1264e4cbbce3506ae7d'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV922(): {proposal: v922.Call, lengthBound: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV923(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'f75980f024746a26a55f3be648696ec2f43474b5c1d0810dc3d9b251d7241119'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV923(): {proposal: v923.Call, lengthBound: number} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '0adbd3c3a36f0cdda59ffcdccd11eefc50205022a2f2d12a53f13efeaf9c8e6f'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV926(): {proposal: v926.Call, lengthBound: number} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV927(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '90d35c54a9da0e98b6e5df6ae13290b84eea776c8d67d6de0c90ca8ceb5631ed'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV927(): {proposal: v927.Call, lengthBound: number} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV930(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'd93772935aa643c6ae09211527d9cd19aceb46765f5215b3db12b97e3407f92f'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV930(): {proposal: v930.Call, lengthBound: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV932(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '3bda03f889c473ffdbb6a5ff8c4409b716ffd0db010e16faa77b4210cb7492f9'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV932(): {proposal: v932.Call, lengthBound: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV940(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'adc855918dedbf35bb3f8bfe251af1f10d8984aee584cb22646e5faf6fccff22'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV940(): {proposal: v940.Call, lengthBound: number} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV942(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '3e219488d64bacae47fae6b558e0365f20f157a99d206e7069ff40136e17a75d'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV942(): {proposal: v942.Call, lengthBound: number} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV944(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '604f6f6cebc0054e31e3948497a11b5483da04907b88c7528b3d59c2879a5a8e'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV944(): {proposal: v944.Call, lengthBound: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV946(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'e76d5058de1501f820707933b07203bcbb6c9c575fe12b18f86d20de8ac93e02'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV946(): {proposal: v946.Call, lengthBound: number} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV948(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '7f95a68b5f3e595dcfc07645a529e2533b4233c10b186e82f42452fb8b0758d7'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV948(): {proposal: v948.Call, lengthBound: number} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV952(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '489e981197f44668ee0fb8fceb04ade0564182a6d5a78a199152d65e9b982df7'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV952(): {proposal: v952.Call, lengthBound: number} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV954(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '205dc4e1fbd08c181adddeaa3696b2185a3ffdc91896d96e6baa9653a04d00bb'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV954(): {proposal: v954.Call, lengthBound: number} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV956(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '6a89d2479337f16d37f8cf3418203ed190560fdd8d9cc12060629be477795c43'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV956(): {proposal: v956.Call, lengthBound: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '3ca271f3d090267c335c525e9805294601c37f20201306c91e8952adb5b1d891'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV958(): {proposal: v958.Call, lengthBound: number} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV962(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '4d7eee56b958953354082203991d3eabb545f2fe76edb4fa562d97b64c44c477'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV962(): {proposal: v962.Call, lengthBound: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV964(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '09466763e4e740ecef18d01cba8b80fc3efe06028c85b873152ece91f05c2467'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV964(): {proposal: v964.Call, lengthBound: number} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV967(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '470cb5abd4b0cb96c9e2860f6e3e5d12d215d41fbe04a9c2b245639651475638'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV967(): {proposal: v967.Call, lengthBound: number} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '8524c24cd96496a043448ab62cc2e078f1fdb16edb6eda4dcf135f509e879915'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV968(): {proposal: v968.Call, lengthBound: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV970(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'be03f2909dec303e32cc1616233f3a1127b7377846880dcf2b3f7fac77590392'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV970(): {proposal: v970.Call, lengthBound: number} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV972(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'c245940a9eb46c2c23d12b8669b1052fcb616bced5919f2e33cb606a6c64e5e0'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV972(): {proposal: v972.Call, lengthBound: number} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeProposeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.propose')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '1ca5ee39de53202f0ba51d0800a1cf1a0a29ffcd6297a6c888b3801c9b8423de'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV803(): {threshold: number, proposal: v803.Proposal, lengthBound: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'aba8538d4414977fb3ff48657c028923bb6e6d9209937d0b83997cfd033a0738'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV804(): {threshold: number, proposal: v804.Proposal, lengthBound: number} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV805(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'e040b3ffd1bf4f1145407369fe90663cc07d0c16c24a3a7a1bce7db69eceedf4'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV805(): {threshold: number, proposal: v805.Proposal, lengthBound: number} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV900(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '71351f28414f6ae5546e358268f9187cf3d34bb24b19b9536c89a6f365a705a5'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV900(): {threshold: number, proposal: v900.Proposal, lengthBound: number} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV901(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '7d657a76204435cebf16856e19705f2287b31d0e3c0713d8697cd514399b9108'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV901(): {threshold: number, proposal: v901.Proposal, lengthBound: number} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV902(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '3c80bf8c2e4221ae2599942acc021ec32fb955e5786ed04751b85078078de86f'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV902(): {threshold: number, proposal: v902.Proposal, lengthBound: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV906(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'f5219ff63063b8fab2d44c6523ea0536d92381661e66b675c2cfe59ee4832818'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV906(): {threshold: number, proposal: v906.Call, lengthBound: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '67b9a985960bc7295f0af482ea8f244055af5997a162a3ec0d2a35b0b485c474'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV908(): {threshold: number, proposal: v908.Call, lengthBound: number} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV910(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '89a0b2acc6f0129f4c63ebac17f420a1cd2b8c377f34f6f50feece04393c54f3'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV910(): {threshold: number, proposal: v910.Call, lengthBound: number} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV912(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'cf76a682a8b99c713d296be9c18290f8dbd8bd839a033b51a36e824acd78c361'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV912(): {threshold: number, proposal: v912.Call, lengthBound: number} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV914(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '9b441912114922155879e4dcab07257b487007f5c83cb365ff01e9b8b333e9ac'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV914(): {threshold: number, proposal: v914.Call, lengthBound: number} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV915(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '3802b615250234e0a6fa3872a6cdc901c3bf6a0c8316e02d05cdeef4907cb36e'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV915(): {threshold: number, proposal: v915.Call, lengthBound: number} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV916(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '9161c3230fd2212002390a50fd879c80c63ab1eec7ec4787563a9e8fdca558db'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV916(): {threshold: number, proposal: v916.Call, lengthBound: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV918(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '754c77df144d1d00da22bfcfbe7710ebdcdf2146a1f08ebffd0e91d95f67783c'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV918(): {threshold: number, proposal: v918.Call, lengthBound: number} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV920(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '99bc1d8f4758e63a324dae53aedd6b338dd934d6e7058e5661b40a8761459534'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV920(): {threshold: number, proposal: v920.Call, lengthBound: number} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV922(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '82d324ae3629c31d2fe86f3e1fb83272650a4f607c024806d9288abe13083c17'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV922(): {threshold: number, proposal: v922.Call, lengthBound: number} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV923(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'b690deb2817fcb580a28a20471554c33655fc4dcf91ec23178134ccee0fb2f17'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV923(): {threshold: number, proposal: v923.Call, lengthBound: number} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '84f61a84c8356e24ab9bd68f7c1c2d26bcaa4292ff3eeb838cc7395f9314a91a'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV926(): {threshold: number, proposal: v926.Call, lengthBound: number} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV927(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'a8aa747055da9c04b5de1a5ad16e7a332ce9650e8302dd2e52ad39f3f50ae4b8'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV927(): {threshold: number, proposal: v927.Call, lengthBound: number} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV930(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '29a9778bffbb79b9ab07977a78ef24cce9cbce1567339f7ecbbd10330cf41578'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV930(): {threshold: number, proposal: v930.Call, lengthBound: number} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV932(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'd60961ea735abef7cfc834a23fab4a4d4bbcce0b2330c59caf83580901b4cdbf'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV932(): {threshold: number, proposal: v932.Call, lengthBound: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV940(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '711dc586de516e5f30eadb8681ae1dc2d55693f9c84c862fbd34742b4587404c'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV940(): {threshold: number, proposal: v940.Call, lengthBound: number} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV942(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'c3f00b703b2d2464186b23f2f1d6f981a77e572267b0ebd9b1d4a8afd8575fcf'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV942(): {threshold: number, proposal: v942.Call, lengthBound: number} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV944(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '3ef5937b1b4c3bdb4e5cc75a1514965ecb0331de393cf32c1333cfdbba45ab1b'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV944(): {threshold: number, proposal: v944.Call, lengthBound: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV946(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '2b01969fada1d70522b1cc3e10b99d04b59f531ea3f870d3b05a6580bfd16729'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV946(): {threshold: number, proposal: v946.Call, lengthBound: number} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV948(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '19c5666cc1ab51a086d59ef7021d791b2396bd2d72f277d5ba77bd4e94cd6e37'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV948(): {threshold: number, proposal: v948.Call, lengthBound: number} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV952(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '19253b17f491c46d120f34c0cee9adc0c5315351e1d70c7553b1292c28ce2c89'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV952(): {threshold: number, proposal: v952.Call, lengthBound: number} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV954(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '25b4990d6684bb47ee24d6e485bdde1e177b1f3bf33289b5907a1b3e6d8a7870'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV954(): {threshold: number, proposal: v954.Call, lengthBound: number} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV956(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '5f46bae18c543a35e21563d7ac7038d09aaef00fa5e5f0030fc249848c6674ee'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV956(): {threshold: number, proposal: v956.Call, lengthBound: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'b2429ea5b67dcb3613a44ce4eca41aab2a7d818fcb6d93bc52e54cf039057fdd'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV958(): {threshold: number, proposal: v958.Call, lengthBound: number} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV962(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '85860d42d52d56e49bf59b1e1c7235b4243e529836debf5ac042da4db040978a'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV962(): {threshold: number, proposal: v962.Call, lengthBound: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV964(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '80af865ba4783036af1e2c253d52784398579cecdaaa1d9626f65edf4d597380'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV964(): {threshold: number, proposal: v964.Call, lengthBound: number} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV967(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '25631c1487ed3953a6b6ac285dc2317f6b9f99bddb9cef1639383e5cf82d522e'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV967(): {threshold: number, proposal: v967.Call, lengthBound: number} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '172d0946e3216408981ba8703fd12bd1b40170c41cc9da8061bccbd2c4119143'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV968(): {threshold: number, proposal: v968.Call, lengthBound: number} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV970(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'b2b73888fc3098733b33b553f1487e271d9bf8105869378cb4f77091600b4d14'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV970(): {threshold: number, proposal: v970.Call, lengthBound: number} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV972(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '3045fee08872ddc64e0b5aef0e83be55f34c08fba3c390c4cf5a50bcc32a2203'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV972(): {threshold: number, proposal: v972.Call, lengthBound: number} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeSetMembersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.set_members')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the collective's membership.
     * 
     *  - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     *  - `prime`: The prime member whose vote sets the default.
     *  - `old_count`: The upper bound for the previous number of members in storage.
     *                 Used for weight estimation.
     * 
     *  Requires root origin.
     * 
     *  NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     *        the weight estimations rely on it to estimate dispatchable weight.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(MP + N)` where:
     *    - `M` old-members-count (code- and governance-bounded)
     *    - `N` new-members-count (code- and governance-bounded)
     *    - `P` proposals-count (code-bounded)
     *  - DB:
     *    - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members
     *    - 1 storage read (codec `O(P)`) for reading the proposals
     *    - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
     *    - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.set_members') === '71b7fcb1d8a62eff96a9ef006517578ce9189e6d931948a256a04ca75ff68d4a'
    }

    /**
     *  Set the collective's membership.
     * 
     *  - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     *  - `prime`: The prime member whose vote sets the default.
     *  - `old_count`: The upper bound for the previous number of members in storage.
     *                 Used for weight estimation.
     * 
     *  Requires root origin.
     * 
     *  NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     *        the weight estimations rely on it to estimate dispatchable weight.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(MP + N)` where:
     *    - `M` old-members-count (code- and governance-bounded)
     *    - `N` new-members-count (code- and governance-bounded)
     *    - `P` proposals-count (code-bounded)
     *  - DB:
     *    - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members
     *    - 1 storage read (codec `O(P)`) for reading the proposals
     *    - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
     *    - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
     *  # </weight>
     */
    get asV803(): {newMembers: Uint8Array[], prime: (Uint8Array | undefined), oldCount: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add an aye or nay vote for the sender to the given proposal.
     * 
     *  Requires the sender to be a member.
     * 
     *  Transaction fees will be waived if the member is voting on any particular proposal
     *  for the first time and the call is successful. Subsequent vote changes will charge a fee.
     *  # <weight>
     *  ## Weight
     *  - `O(M)` where `M` is members-count (code- and governance-bounded)
     *  - DB:
     *    - 1 storage read `Members` (codec `O(M)`)
     *    - 1 storage mutation `Voting` (codec `O(M)`)
     *  - 1 event
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.vote') === 'f8a1069a57f7b721f47c086d08b6838ae1a0c08f58caddb82428ba5f1407540f'
    }

    /**
     *  Add an aye or nay vote for the sender to the given proposal.
     * 
     *  Requires the sender to be a member.
     * 
     *  Transaction fees will be waived if the member is voting on any particular proposal
     *  for the first time and the call is successful. Subsequent vote changes will charge a fee.
     *  # <weight>
     *  ## Weight
     *  - `O(M)` where `M` is members-count (code- and governance-bounded)
     *  - DB:
     *    - 1 storage read `Members` (codec `O(M)`)
     *    - 1 storage mutation `Voting` (codec `O(M)`)
     *  - 1 event
     *  # </weight>
     */
    get asV803(): {proposal: Uint8Array, index: number, approve: boolean} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipAddMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.add_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add a member `who` to the set.
     * 
     *  May only be called from `T::AddOrigin`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalMembership.add_member') === 'b8a0d2208835f6ada60dd21cd93533d703777b3779109a7c6a2f26bad68c2f3b'
    }

    /**
     *  Add a member `who` to the set.
     * 
     *  May only be called from `T::AddOrigin`.
     */
    get asV803(): {who: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a member `who` to the set.
     * 
     * May only be called from `T::AddOrigin`.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('TechnicalMembership.add_member') === 'bb6d6c7e28eeb3aad04d22b6921e046cbe5b8efaf6ef127a2c0c9535239f94e7'
    }

    /**
     * Add a member `who` to the set.
     * 
     * May only be called from `T::AddOrigin`.
     */
    get asV968(): {who: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipChangeKeyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.change_key')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Swap out the sending member for some other key `new`.
     * 
     *  May only be called from `Signed` origin of a current member.
     * 
     *  Prime membership is passed from the origin account to `new`, if extant.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalMembership.change_key') === 'f866dcb3e8857987a2d21e57c13216c10bb21546a718b81d5e2c0989d6e95df7'
    }

    /**
     *  Swap out the sending member for some other key `new`.
     * 
     *  May only be called from `Signed` origin of a current member.
     * 
     *  Prime membership is passed from the origin account to `new`, if extant.
     */
    get asV803(): {new: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Swap out the sending member for some other key `new`.
     * 
     * May only be called from `Signed` origin of a current member.
     * 
     * Prime membership is passed from the origin account to `new`, if extant.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('TechnicalMembership.change_key') === 'd0eb457ece644571cebe79cbdd64ef1453c382048ffec79f9c403f7bc8f90020'
    }

    /**
     * Swap out the sending member for some other key `new`.
     * 
     * May only be called from `Signed` origin of a current member.
     * 
     * Prime membership is passed from the origin account to `new`, if extant.
     */
    get asV968(): {new: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipClearPrimeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.clear_prime')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove the prime member if it exists.
     * 
     *  May only be called from `T::PrimeOrigin`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalMembership.clear_prime') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Remove the prime member if it exists.
     * 
     *  May only be called from `T::PrimeOrigin`.
     */
    get asV803(): null {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipRemoveMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.remove_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a member `who` from the set.
     * 
     *  May only be called from `T::RemoveOrigin`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalMembership.remove_member') === 'b8a0d2208835f6ada60dd21cd93533d703777b3779109a7c6a2f26bad68c2f3b'
    }

    /**
     *  Remove a member `who` from the set.
     * 
     *  May only be called from `T::RemoveOrigin`.
     */
    get asV803(): {who: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove a member `who` from the set.
     * 
     * May only be called from `T::RemoveOrigin`.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('TechnicalMembership.remove_member') === 'bb6d6c7e28eeb3aad04d22b6921e046cbe5b8efaf6ef127a2c0c9535239f94e7'
    }

    /**
     * Remove a member `who` from the set.
     * 
     * May only be called from `T::RemoveOrigin`.
     */
    get asV968(): {who: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipResetMembersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.reset_members')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Change the membership to a new set, disregarding the existing membership. Be nice and
     *  pass `members` pre-sorted.
     * 
     *  May only be called from `T::ResetOrigin`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalMembership.reset_members') === 'd8adca14f9b9cadeaf2b2e6dd47991d05cb423ce3a00dccbb9efa35e36f5a65a'
    }

    /**
     *  Change the membership to a new set, disregarding the existing membership. Be nice and
     *  pass `members` pre-sorted.
     * 
     *  May only be called from `T::ResetOrigin`.
     */
    get asV803(): {members: Uint8Array[]} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipSetPrimeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.set_prime')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the prime member. Must be a current member.
     * 
     *  May only be called from `T::PrimeOrigin`.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalMembership.set_prime') === 'b8a0d2208835f6ada60dd21cd93533d703777b3779109a7c6a2f26bad68c2f3b'
    }

    /**
     *  Set the prime member. Must be a current member.
     * 
     *  May only be called from `T::PrimeOrigin`.
     */
    get asV803(): {who: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the prime member. Must be a current member.
     * 
     * May only be called from `T::PrimeOrigin`.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('TechnicalMembership.set_prime') === 'bb6d6c7e28eeb3aad04d22b6921e046cbe5b8efaf6ef127a2c0c9535239f94e7'
    }

    /**
     * Set the prime member. Must be a current member.
     * 
     * May only be called from `T::PrimeOrigin`.
     */
    get asV968(): {who: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipSwapMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.swap_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Swap out one member `remove` for another `add`.
     * 
     *  May only be called from `T::SwapOrigin`.
     * 
     *  Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('TechnicalMembership.swap_member') === 'f9cf5ef851567c52b54f359126b80e6fa967b49f082dd77310b8461819cd13df'
    }

    /**
     *  Swap out one member `remove` for another `add`.
     * 
     *  May only be called from `T::SwapOrigin`.
     * 
     *  Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    get asV803(): {remove: Uint8Array, add: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Swap out one member `remove` for another `add`.
     * 
     * May only be called from `T::SwapOrigin`.
     * 
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('TechnicalMembership.swap_member') === '6204d1b2fba84c1b9c33991cd1e58bf8c021ede5edfb777acbb025799df5bc4f'
    }

    /**
     * Swap out one member `remove` for another `add`.
     * 
     * May only be called from `T::SwapOrigin`.
     * 
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    get asV968(): {remove: v968.MultiAddress, add: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class TimestampSetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Timestamp.set')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the current time.
     * 
     *  This call should be invoked exactly once per block. It will panic at the finalization
     *  phase, if this call hasn't been invoked by that time.
     * 
     *  The timestamp should be greater than the previous one by the amount specified by
     *  `MinimumPeriod`.
     * 
     *  The dispatch origin for this call must be `Inherent`.
     * 
     *  # <weight>
     *  - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     *  - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)
     *  - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Timestamp.set') === '6a8b8ba2be107f0853b674eec0026cc440b314db44d0e2c59b36e353355aed14'
    }

    /**
     *  Set the current time.
     * 
     *  This call should be invoked exactly once per block. It will panic at the finalization
     *  phase, if this call hasn't been invoked by that time.
     * 
     *  The timestamp should be greater than the previous one by the amount specified by
     *  `MinimumPeriod`.
     * 
     *  The dispatch origin for this call must be `Inherent`.
     * 
     *  # <weight>
     *  - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     *  - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)
     *  - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *  # </weight>
     */
    get asV1(): {now: bigint} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class TipsCloseTipCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tips.close_tip')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Close and payout a tip.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  The tip identified by `hash` must have finished its countdown period.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
     * 
     *  # <weight>
     *  - Complexity: `O(T)` where `T` is the number of tippers.
     *    decoding `Tipper` vec of length `T`.
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     *  - DbReads: `Tips`, `Tippers`, `tip finder`
     *  - DbWrites: `Reasons`, `Tips`, `Tippers`, `tip finder`
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Tips.close_tip') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     *  Close and payout a tip.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  The tip identified by `hash` must have finished its countdown period.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
     * 
     *  # <weight>
     *  - Complexity: `O(T)` where `T` is the number of tippers.
     *    decoding `Tipper` vec of length `T`.
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     *  - DbReads: `Tips`, `Tippers`, `tip finder`
     *  - DbWrites: `Reasons`, `Tips`, `Tippers`, `tip finder`
     *  # </weight>
     */
    get asV803(): {hash: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class TipsReportAwesomeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tips.report_awesome')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Report something `reason` that deserves a tip and claim any eventual the finder's fee.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     *  `DataDepositPerByte` for each byte in `reason`.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(R)` where `R` length of `reason`.
     *    - encoding and hashing of 'reason'
     *  - DbReads: `Reasons`, `Tips`
     *  - DbWrites: `Reasons`, `Tips`
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Tips.report_awesome') === '5f39cdb6a1bab5505c2717a3d34b1ad66c35bb6aca421780ce60b4e9017fe886'
    }

    /**
     *  Report something `reason` that deserves a tip and claim any eventual the finder's fee.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     *  `DataDepositPerByte` for each byte in `reason`.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(R)` where `R` length of `reason`.
     *    - encoding and hashing of 'reason'
     *  - DbReads: `Reasons`, `Tips`
     *  - DbWrites: `Reasons`, `Tips`
     *  # </weight>
     */
    get asV803(): {reason: Uint8Array, who: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Report something `reason` that deserves a tip and claim any eventual the finder's fee.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     * `DataDepositPerByte` for each byte in `reason`.
     * 
     * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *   a UTF-8-encoded URL.
     * - `who`: The account which should be credited for the tip.
     * 
     * Emits `NewTip` if successful.
     * 
     * # <weight>
     * - Complexity: `O(R)` where `R` length of `reason`.
     *   - encoding and hashing of 'reason'
     * - DbReads: `Reasons`, `Tips`
     * - DbWrites: `Reasons`, `Tips`
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Tips.report_awesome') === 'd13121e096e86ccd1c9397d3186eaf9013033a963c1ac8e7830e2b169389e35f'
    }

    /**
     * Report something `reason` that deserves a tip and claim any eventual the finder's fee.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     * `DataDepositPerByte` for each byte in `reason`.
     * 
     * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *   a UTF-8-encoded URL.
     * - `who`: The account which should be credited for the tip.
     * 
     * Emits `NewTip` if successful.
     * 
     * # <weight>
     * - Complexity: `O(R)` where `R` length of `reason`.
     *   - encoding and hashing of 'reason'
     * - DbReads: `Reasons`, `Tips`
     * - DbWrites: `Reasons`, `Tips`
     * # </weight>
     */
    get asV968(): {reason: Uint8Array, who: v968.MultiAddress} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class TipsRetractTipCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tips.retract_tip')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
     * 
     *  If successful, the original deposit will be unreserved.
     * 
     *  The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
     *  must have been reported by the signing account through `report_awesome` (and not
     *  through `tip_new`).
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
     * 
     *  Emits `TipRetracted` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(1)`
     *    - Depends on the length of `T::Hash` which is fixed.
     *  - DbReads: `Tips`, `origin account`
     *  - DbWrites: `Reasons`, `Tips`, `origin account`
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Tips.retract_tip') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     *  Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
     * 
     *  If successful, the original deposit will be unreserved.
     * 
     *  The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
     *  must have been reported by the signing account through `report_awesome` (and not
     *  through `tip_new`).
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
     * 
     *  Emits `TipRetracted` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(1)`
     *    - Depends on the length of `T::Hash` which is fixed.
     *  - DbReads: `Tips`, `origin account`
     *  - DbWrites: `Reasons`, `Tips`, `origin account`
     *  # </weight>
     */
    get asV803(): {hash: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class TipsSlashTipCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tips.slash_tip')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove and slash an already-open tip.
     * 
     *  May only be called from `T::RejectOrigin`.
     * 
     *  As a result, the finder is slashed and the deposits are lost.
     * 
     *  Emits `TipSlashed` if successful.
     * 
     *  # <weight>
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Tips.slash_tip') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     *  Remove and slash an already-open tip.
     * 
     *  May only be called from `T::RejectOrigin`.
     * 
     *  As a result, the finder is slashed and the deposits are lost.
     * 
     *  Emits `TipSlashed` if successful.
     * 
     *  # <weight>
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     *  # </weight>
     */
    get asV803(): {hash: Uint8Array} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class TipsTipCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tips.tip')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Declare a tip value for an already-open tip.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
     *    account ID.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
     *  has started.
     * 
     *  # <weight>
     *  - Complexity: `O(T)` where `T` is the number of tippers.
     *    decoding `Tipper` vec of length `T`, insert tip and check closing,
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     * 
     *    Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
     *    is weighted as if almost full i.e of length `T-1`.
     *  - DbReads: `Tippers`, `Tips`
     *  - DbWrites: `Tips`
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Tips.tip') === 'f3795cdab18c292963e0e30ece37a15a2900030efc315a8e3f28ba886b2b9f58'
    }

    /**
     *  Declare a tip value for an already-open tip.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
     *    account ID.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
     *  has started.
     * 
     *  # <weight>
     *  - Complexity: `O(T)` where `T` is the number of tippers.
     *    decoding `Tipper` vec of length `T`, insert tip and check closing,
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     * 
     *    Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
     *    is weighted as if almost full i.e of length `T-1`.
     *  - DbReads: `Tippers`, `Tips`
     *  - DbWrites: `Tips`
     *  # </weight>
     */
    get asV803(): {hash: Uint8Array, tipValue: bigint} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class TipsTipNewCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tips.tip_new')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Give a tip for something new; no finder's fee will be taken.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
     *    - `O(T)`: decoding `Tipper` vec of length `T`
     *      `T` is charged as upper bound given by `ContainsLengthBound`.
     *      The actual cost depends on the implementation of `T::Tippers`.
     *    - `O(R)`: hashing and encoding of reason of length `R`
     *  - DbReads: `Tippers`, `Reasons`
     *  - DbWrites: `Reasons`, `Tips`
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Tips.tip_new') === '367b1dcdffb32d8c4b26e342e9b515c65f2589dec81f4a3f6f336faaa7e127ac'
    }

    /**
     *  Give a tip for something new; no finder's fee will be taken.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
     *    - `O(T)`: decoding `Tipper` vec of length `T`
     *      `T` is charged as upper bound given by `ContainsLengthBound`.
     *      The actual cost depends on the implementation of `T::Tippers`.
     *    - `O(R)`: hashing and encoding of reason of length `R`
     *  - DbReads: `Tippers`, `Reasons`
     *  - DbWrites: `Reasons`, `Tips`
     *  # </weight>
     */
    get asV803(): {reason: Uint8Array, who: Uint8Array, tipValue: bigint} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Give a tip for something new; no finder's fee will be taken.
     * 
     * The dispatch origin for this call must be _Signed_ and the signing account must be a
     * member of the `Tippers` set.
     * 
     * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *   a UTF-8-encoded URL.
     * - `who`: The account which should be credited for the tip.
     * - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *   value of active tippers will be given to the `who`.
     * 
     * Emits `NewTip` if successful.
     * 
     * # <weight>
     * - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
     *   - `O(T)`: decoding `Tipper` vec of length `T`. `T` is charged as upper bound given by
     *     `ContainsLengthBound`. The actual cost depends on the implementation of
     *     `T::Tippers`.
     *   - `O(R)`: hashing and encoding of reason of length `R`
     * - DbReads: `Tippers`, `Reasons`
     * - DbWrites: `Reasons`, `Tips`
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Tips.tip_new') === '727db3d3f0aea6322c1ad8f38ecbfbae1eac3762a3069ee379bfdbd43e46877a'
    }

    /**
     * Give a tip for something new; no finder's fee will be taken.
     * 
     * The dispatch origin for this call must be _Signed_ and the signing account must be a
     * member of the `Tippers` set.
     * 
     * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *   a UTF-8-encoded URL.
     * - `who`: The account which should be credited for the tip.
     * - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *   value of active tippers will be given to the `who`.
     * 
     * Emits `NewTip` if successful.
     * 
     * # <weight>
     * - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
     *   - `O(T)`: decoding `Tipper` vec of length `T`. `T` is charged as upper bound given by
     *     `ContainsLengthBound`. The actual cost depends on the implementation of
     *     `T::Tippers`.
     *   - `O(R)`: hashing and encoding of reason of length `R`
     * - DbReads: `Tippers`, `Reasons`
     * - DbWrites: `Reasons`, `Tips`
     * # </weight>
     */
    get asV968(): {reason: Uint8Array, who: v968.MultiAddress, tipValue: bigint} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }
}

export class TokenIssuerAddToIssueWhitelistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TokenIssuer.add_to_issue_whitelist')
        this._chain = ctx._chain
        this.call = call
    }

    get isV902(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_issue_whitelist') === '0de8da894e0b64d93567f88f45e9489c21193c748764a7a90b821297f5739b02'
    }

    get asV902(): {currencyId: v902.CurrencyId, account: Uint8Array} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    get isV906(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_issue_whitelist') === '2fd209c7bb0af0bcceaf23c7982bf9f83ed02394ddf8b3eda2437738317ac028'
    }

    get asV906(): {currencyId: v906.CurrencyId, account: Uint8Array} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    get isV916(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_issue_whitelist') === '7488b02b3a6fee25c3e8dbe42ea280e31b3bfe9564af52579984ae35fd1c63d4'
    }

    get asV916(): {currencyId: v916.CurrencyId, account: Uint8Array} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    get isV920(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_issue_whitelist') === '9656d0b6186b29257519264e6490390e658f4b09b041577ebc93dee2f3981abc'
    }

    get asV920(): {currencyId: v920.CurrencyId, account: Uint8Array} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    get isV932(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_issue_whitelist') === 'a359842d298ca32221ac03ff4ac434660e42407d40d492c016efd764a6d7b2fb'
    }

    get asV932(): {currencyId: v932.CurrencyId, account: Uint8Array} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_issue_whitelist') === '157a312190aa2027a787c590cab94bc3b6fe1b88688c22de4427da09f2faa12d'
    }

    get asV956(): {currencyId: v956.CurrencyId, account: Uint8Array} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_issue_whitelist') === '7744d5c2e503066b8cb07aca0a7406cf18808997ce244498314e13bee09c2824'
    }

    get asV962(): {currencyId: v962.CurrencyId, account: Uint8Array} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class TokenIssuerAddToTransferWhitelistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TokenIssuer.add_to_transfer_whitelist')
        this._chain = ctx._chain
        this.call = call
    }

    get isV902(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_transfer_whitelist') === '0de8da894e0b64d93567f88f45e9489c21193c748764a7a90b821297f5739b02'
    }

    get asV902(): {currencyId: v902.CurrencyId, account: Uint8Array} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    get isV906(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_transfer_whitelist') === '2fd209c7bb0af0bcceaf23c7982bf9f83ed02394ddf8b3eda2437738317ac028'
    }

    get asV906(): {currencyId: v906.CurrencyId, account: Uint8Array} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    get isV916(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_transfer_whitelist') === '7488b02b3a6fee25c3e8dbe42ea280e31b3bfe9564af52579984ae35fd1c63d4'
    }

    get asV916(): {currencyId: v916.CurrencyId, account: Uint8Array} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    get isV920(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_transfer_whitelist') === '9656d0b6186b29257519264e6490390e658f4b09b041577ebc93dee2f3981abc'
    }

    get asV920(): {currencyId: v920.CurrencyId, account: Uint8Array} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    get isV932(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_transfer_whitelist') === 'a359842d298ca32221ac03ff4ac434660e42407d40d492c016efd764a6d7b2fb'
    }

    get asV932(): {currencyId: v932.CurrencyId, account: Uint8Array} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_transfer_whitelist') === '157a312190aa2027a787c590cab94bc3b6fe1b88688c22de4427da09f2faa12d'
    }

    get asV956(): {currencyId: v956.CurrencyId, account: Uint8Array} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('TokenIssuer.add_to_transfer_whitelist') === '7744d5c2e503066b8cb07aca0a7406cf18808997ce244498314e13bee09c2824'
    }

    get asV962(): {currencyId: v962.CurrencyId, account: Uint8Array} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class TokenIssuerIssueCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TokenIssuer.issue')
        this._chain = ctx._chain
        this.call = call
    }

    get isV902(): boolean {
        return this._chain.getCallHash('TokenIssuer.issue') === 'af5a2e2a8101a4f9dafb271ca1e0a12700438bf27d06bbb10c85b6a6c651f432'
    }

    get asV902(): {dest: Uint8Array, currencyId: v902.CurrencyId, amount: bigint} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    get isV906(): boolean {
        return this._chain.getCallHash('TokenIssuer.issue') === 'b3ca57d4049421fcf885c191c8e6006c5eaaa778708deb9e941ec4aba7f05bbe'
    }

    get asV906(): {dest: Uint8Array, currencyId: v906.CurrencyId, amount: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    get isV916(): boolean {
        return this._chain.getCallHash('TokenIssuer.issue') === '9b39537b4be7a4de528f4a13e77dc249060b6209c3a18fa10705db59174890d2'
    }

    get asV916(): {dest: Uint8Array, currencyId: v916.CurrencyId, amount: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    get isV920(): boolean {
        return this._chain.getCallHash('TokenIssuer.issue') === 'cbfb63ac2e70a45edd2e5be525f56e348d6bb47ef86f650447a6e336fe28f475'
    }

    get asV920(): {dest: Uint8Array, currencyId: v920.CurrencyId, amount: bigint} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    get isV932(): boolean {
        return this._chain.getCallHash('TokenIssuer.issue') === '0fb767771a735ab868a996e9e5cd729618b541d1593e6654b69681998cccbf7d'
    }

    get asV932(): {dest: Uint8Array, currencyId: v932.CurrencyId, amount: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('TokenIssuer.issue') === 'db01e5b684474f311a15542b7fa1f4dd830e911a4de9492af896fca4cfe26df1'
    }

    get asV956(): {dest: Uint8Array, currencyId: v956.CurrencyId, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('TokenIssuer.issue') === 'e7ef22a74f756354a437c50bb5cb6497450d93508e26c2818eccd418c37d944f'
    }

    get asV962(): {dest: Uint8Array, currencyId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class TokenIssuerRemoveFromIssueWhitelistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TokenIssuer.remove_from_issue_whitelist')
        this._chain = ctx._chain
        this.call = call
    }

    get isV902(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_issue_whitelist') === '0de8da894e0b64d93567f88f45e9489c21193c748764a7a90b821297f5739b02'
    }

    get asV902(): {currencyId: v902.CurrencyId, account: Uint8Array} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    get isV906(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_issue_whitelist') === '2fd209c7bb0af0bcceaf23c7982bf9f83ed02394ddf8b3eda2437738317ac028'
    }

    get asV906(): {currencyId: v906.CurrencyId, account: Uint8Array} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    get isV916(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_issue_whitelist') === '7488b02b3a6fee25c3e8dbe42ea280e31b3bfe9564af52579984ae35fd1c63d4'
    }

    get asV916(): {currencyId: v916.CurrencyId, account: Uint8Array} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    get isV920(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_issue_whitelist') === '9656d0b6186b29257519264e6490390e658f4b09b041577ebc93dee2f3981abc'
    }

    get asV920(): {currencyId: v920.CurrencyId, account: Uint8Array} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    get isV932(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_issue_whitelist') === 'a359842d298ca32221ac03ff4ac434660e42407d40d492c016efd764a6d7b2fb'
    }

    get asV932(): {currencyId: v932.CurrencyId, account: Uint8Array} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_issue_whitelist') === '157a312190aa2027a787c590cab94bc3b6fe1b88688c22de4427da09f2faa12d'
    }

    get asV956(): {currencyId: v956.CurrencyId, account: Uint8Array} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_issue_whitelist') === '7744d5c2e503066b8cb07aca0a7406cf18808997ce244498314e13bee09c2824'
    }

    get asV962(): {currencyId: v962.CurrencyId, account: Uint8Array} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class TokenIssuerRemoveFromTransferWhitelistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TokenIssuer.remove_from_transfer_whitelist')
        this._chain = ctx._chain
        this.call = call
    }

    get isV902(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_transfer_whitelist') === '0de8da894e0b64d93567f88f45e9489c21193c748764a7a90b821297f5739b02'
    }

    get asV902(): {currencyId: v902.CurrencyId, account: Uint8Array} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    get isV906(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_transfer_whitelist') === '2fd209c7bb0af0bcceaf23c7982bf9f83ed02394ddf8b3eda2437738317ac028'
    }

    get asV906(): {currencyId: v906.CurrencyId, account: Uint8Array} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    get isV916(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_transfer_whitelist') === '7488b02b3a6fee25c3e8dbe42ea280e31b3bfe9564af52579984ae35fd1c63d4'
    }

    get asV916(): {currencyId: v916.CurrencyId, account: Uint8Array} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    get isV920(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_transfer_whitelist') === '9656d0b6186b29257519264e6490390e658f4b09b041577ebc93dee2f3981abc'
    }

    get asV920(): {currencyId: v920.CurrencyId, account: Uint8Array} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    get isV932(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_transfer_whitelist') === 'a359842d298ca32221ac03ff4ac434660e42407d40d492c016efd764a6d7b2fb'
    }

    get asV932(): {currencyId: v932.CurrencyId, account: Uint8Array} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_transfer_whitelist') === '157a312190aa2027a787c590cab94bc3b6fe1b88688c22de4427da09f2faa12d'
    }

    get asV956(): {currencyId: v956.CurrencyId, account: Uint8Array} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('TokenIssuer.remove_from_transfer_whitelist') === '7744d5c2e503066b8cb07aca0a7406cf18808997ce244498314e13bee09c2824'
    }

    get asV962(): {currencyId: v962.CurrencyId, account: Uint8Array} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class TokenIssuerTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TokenIssuer.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Destroy some balance from an account.
     * 
     *  The dispatch origin for this call must be `Root` by the
     *  transactor.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('TokenIssuer.transfer') === 'af5a2e2a8101a4f9dafb271ca1e0a12700438bf27d06bbb10c85b6a6c651f432'
    }

    /**
     *  Destroy some balance from an account.
     * 
     *  The dispatch origin for this call must be `Root` by the
     *  transactor.
     */
    get asV902(): {dest: Uint8Array, currencyId: v902.CurrencyId, amount: bigint} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Destroy some balance from an account.
     * 
     * The dispatch origin for this call must be `Root` by the
     * transactor.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('TokenIssuer.transfer') === 'b3ca57d4049421fcf885c191c8e6006c5eaaa778708deb9e941ec4aba7f05bbe'
    }

    /**
     * Destroy some balance from an account.
     * 
     * The dispatch origin for this call must be `Root` by the
     * transactor.
     */
    get asV906(): {dest: Uint8Array, currencyId: v906.CurrencyId, amount: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Destroy some balance from an account.
     * 
     * The dispatch origin for this call must be `Root` by the
     * transactor.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('TokenIssuer.transfer') === '9b39537b4be7a4de528f4a13e77dc249060b6209c3a18fa10705db59174890d2'
    }

    /**
     * Destroy some balance from an account.
     * 
     * The dispatch origin for this call must be `Root` by the
     * transactor.
     */
    get asV916(): {dest: Uint8Array, currencyId: v916.CurrencyId, amount: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Destroy some balance from an account.
     * 
     * The dispatch origin for this call must be `Root` by the
     * transactor.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('TokenIssuer.transfer') === 'cbfb63ac2e70a45edd2e5be525f56e348d6bb47ef86f650447a6e336fe28f475'
    }

    /**
     * Destroy some balance from an account.
     * 
     * The dispatch origin for this call must be `Root` by the
     * transactor.
     */
    get asV920(): {dest: Uint8Array, currencyId: v920.CurrencyId, amount: bigint} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Destroy some balance from an account.
     * 
     * The dispatch origin for this call must be `Root` by the
     * transactor.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('TokenIssuer.transfer') === '0fb767771a735ab868a996e9e5cd729618b541d1593e6654b69681998cccbf7d'
    }

    /**
     * Destroy some balance from an account.
     * 
     * The dispatch origin for this call must be `Root` by the
     * transactor.
     */
    get asV932(): {dest: Uint8Array, currencyId: v932.CurrencyId, amount: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Destroy some balance from an account.
     * 
     * The dispatch origin for this call must be `Root` by the
     * transactor.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('TokenIssuer.transfer') === 'db01e5b684474f311a15542b7fa1f4dd830e911a4de9492af896fca4cfe26df1'
    }

    /**
     * Destroy some balance from an account.
     * 
     * The dispatch origin for this call must be `Root` by the
     * transactor.
     */
    get asV956(): {dest: Uint8Array, currencyId: v956.CurrencyId, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Destroy some balance from an account.
     * 
     * The dispatch origin for this call must be `Root` by the
     * transactor.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('TokenIssuer.transfer') === 'e7ef22a74f756354a437c50bb5cb6497450d93508e26c2818eccd418c37d944f'
    }

    /**
     * Destroy some balance from an account.
     * 
     * The dispatch origin for this call must be `Root` by the
     * transactor.
     */
    get asV962(): {dest: Uint8Array, currencyId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class TokensForceTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tokens.force_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Exactly as `transfer`, except the origin must be root and the source
     *  account may be specified.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `source`: The sender of the transfer.
     *  - `dest`: The recipient of the transfer.
     *  - `currency_id`: currency type.
     *  - `amount`: free balance amount to tranfer.
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Tokens.force_transfer') === 'e802d8977b3601a2fcaaf950a39a499a9d51f83153b494127080288446a8193f'
    }

    /**
     *  Exactly as `transfer`, except the origin must be root and the source
     *  account may be specified.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `source`: The sender of the transfer.
     *  - `dest`: The recipient of the transfer.
     *  - `currency_id`: currency type.
     *  - `amount`: free balance amount to tranfer.
     */
    get asV802(): {source: v802.LookupSource, dest: v802.LookupSource, currencyId: v802.CurrencyId, amount: bigint} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Tokens.force_transfer') === 'c372689b8d7d9a97ba605cb48e476819b0925b698bc8d5c43baf7934945ca4a0'
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV906(): {source: v906.MultiAddress, dest: v906.MultiAddress, currencyId: v906.CurrencyId, amount: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Tokens.force_transfer') === 'f81260b119521fd7dda3df7cfacf8741209ea78dda5de6d96603e101766ed420'
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV916(): {source: v916.MultiAddress, dest: v916.MultiAddress, currencyId: v916.CurrencyId, amount: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Tokens.force_transfer') === 'ff3abaa34b3d714b03ca0a1832419ebc0b3ecc75398b84ed3da3ec2b69da3425'
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV920(): {source: v920.MultiAddress, dest: v920.MultiAddress, currencyId: v920.CurrencyId, amount: bigint} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Tokens.force_transfer') === '1bf290c428da9b7d1cc5f9b4b9fff63fc0027482c8675b359f405dedb40b30d2'
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV932(): {source: v932.MultiAddress, dest: v932.MultiAddress, currencyId: v932.CurrencyId, amount: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Tokens.force_transfer') === 'd7e32892eb552b45ef748a4460c06a3577564946e8f4508567039eb50e945bdf'
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV956(): {source: v956.MultiAddress, dest: v956.MultiAddress, currencyId: v956.CurrencyId, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Tokens.force_transfer') === '98043c867364c54d73f51b17690dee938a40026db32efda261bad4abfc7ede20'
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source
     * account may be specified.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The sender of the transfer.
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV962(): {source: v962.MultiAddress, dest: v962.MultiAddress, currencyId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class TokensSetBalanceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tokens.set_balance')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the balances of a given account.
     * 
     *  This will alter `FreeBalance` and `ReservedBalance` in storage. it
     *  will also decrease the total issuance of the system
     *  (`TotalIssuance`). If the new free or reserved balance is below the
     *  existential deposit, it will reap the `AccountInfo`.
     * 
     *  The dispatch origin for this call is `root`.
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Tokens.set_balance') === '119b0ae1e1538a1c7e5eaa7c7a9bc8e4fc063b5adbf493f260d338223c14fdd3'
    }

    /**
     *  Set the balances of a given account.
     * 
     *  This will alter `FreeBalance` and `ReservedBalance` in storage. it
     *  will also decrease the total issuance of the system
     *  (`TotalIssuance`). If the new free or reserved balance is below the
     *  existential deposit, it will reap the `AccountInfo`.
     * 
     *  The dispatch origin for this call is `root`.
     */
    get asV802(): {who: v802.LookupSource, currencyId: v802.CurrencyId, newFree: bigint, newReserved: bigint} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     * 
     * The dispatch origin for this call is `root`.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Tokens.set_balance') === 'e0f654fbc25f54470d2482613a3489598a9915ce2b68f73a236efe15f8a40f56'
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     * 
     * The dispatch origin for this call is `root`.
     */
    get asV906(): {who: v906.MultiAddress, currencyId: v906.CurrencyId, newFree: bigint, newReserved: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     * 
     * The dispatch origin for this call is `root`.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Tokens.set_balance') === '4f1def9d2797529209ef8e4989708b1ea4ff4e00e5aab73be59b4b1787e76a12'
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     * 
     * The dispatch origin for this call is `root`.
     */
    get asV916(): {who: v916.MultiAddress, currencyId: v916.CurrencyId, newFree: bigint, newReserved: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     * 
     * The dispatch origin for this call is `root`.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Tokens.set_balance') === 'c8541cda2d880f1461603ea44d1d8264ed7c34c2066aca865611c50d1e85bb5c'
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     * 
     * The dispatch origin for this call is `root`.
     */
    get asV920(): {who: v920.MultiAddress, currencyId: v920.CurrencyId, newFree: bigint, newReserved: bigint} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     * 
     * The dispatch origin for this call is `root`.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Tokens.set_balance') === '30f88a741327cdfcda6500dfd0360b0618fd4877b3068b2622b217dec40c205c'
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     * 
     * The dispatch origin for this call is `root`.
     */
    get asV932(): {who: v932.MultiAddress, currencyId: v932.CurrencyId, newFree: bigint, newReserved: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     * 
     * The dispatch origin for this call is `root`.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Tokens.set_balance') === '398a7d55a12e0481f63a26e662045fffe2e71195ffbf1e56ae5a667b7798560e'
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     * 
     * The dispatch origin for this call is `root`.
     */
    get asV956(): {who: v956.MultiAddress, currencyId: v956.CurrencyId, newFree: bigint, newReserved: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     * 
     * The dispatch origin for this call is `root`.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Tokens.set_balance') === '1197c7c8a7658403d061f639b88c73a1b271c3bd3e160aa637c541cab3f9ca91'
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it
     * will also decrease the total issuance of the system
     * (`TotalIssuance`). If the new free or reserved balance is below the
     * existential deposit, it will reap the `AccountInfo`.
     * 
     * The dispatch origin for this call is `root`.
     */
    get asV962(): {who: v962.MultiAddress, currencyId: v962.CurrencyId, newFree: bigint, newReserved: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class TokensTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tokens.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer some liquid free balance to another account.
     * 
     *  `transfer` will set the `FreeBalance` of the sender and receiver.
     *  It will decrease the total issuance of the system by the
     *  `TransferFee`. If the sender's account is below the existential
     *  deposit as a result of the transfer, the account will be reaped.
     * 
     *  The dispatch origin for this call must be `Signed` by the
     *  transactor.
     * 
     *  - `dest`: The recipient of the transfer.
     *  - `currency_id`: currency type.
     *  - `amount`: free balance amount to tranfer.
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Tokens.transfer') === '4c4cbab1d07da2115964fbc45ffe538519770d4ed8cefd19ca4b8a0091deb605'
    }

    /**
     *  Transfer some liquid free balance to another account.
     * 
     *  `transfer` will set the `FreeBalance` of the sender and receiver.
     *  It will decrease the total issuance of the system by the
     *  `TransferFee`. If the sender's account is below the existential
     *  deposit as a result of the transfer, the account will be reaped.
     * 
     *  The dispatch origin for this call must be `Signed` by the
     *  transactor.
     * 
     *  - `dest`: The recipient of the transfer.
     *  - `currency_id`: currency type.
     *  - `amount`: free balance amount to tranfer.
     */
    get asV802(): {dest: v802.LookupSource, currencyId: v802.CurrencyId, amount: bigint} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Tokens.transfer') === 'b9fb4d5743e79104d370b60713a3be4e66245f43aaa364cb6d61b0588d7e7a02'
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV906(): {dest: v906.MultiAddress, currencyId: v906.CurrencyId, amount: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Tokens.transfer') === 'a9948001bd2c3683445876d000abbd80e9ab09caa7edc5287f1cfad9aa0a3f16'
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV916(): {dest: v916.MultiAddress, currencyId: v916.CurrencyId, amount: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Tokens.transfer') === 'a1a170cec9dafb23176128f9246a564eec06ec01b8778cde87df8e380c5547ad'
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV920(): {dest: v920.MultiAddress, currencyId: v920.CurrencyId, amount: bigint} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Tokens.transfer') === 'a76551106730e876302af72d8d390053d6c4f5b7fc5028597728d896db6977f5'
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV932(): {dest: v932.MultiAddress, currencyId: v932.CurrencyId, amount: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Tokens.transfer') === 'b6188ad53f64db3b57f68ca0a0374dc7feaac8f5a460fcd009e7836959c34140'
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV956(): {dest: v956.MultiAddress, currencyId: v956.CurrencyId, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Tokens.transfer') === '04924dbf38b6be9c9b1c8f45f093016a733b1ae1eed8f532c3f518d69b77390a'
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the
     * `TransferFee`. If the sender's account is below the existential
     * deposit as a result of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV962(): {dest: v962.MultiAddress, currencyId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class TokensTransferAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tokens.transfer_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer all remaining balance to the given account.
     * 
     *  NOTE: This function only attempts to transfer _transferable_
     *  balances. This means that any locked, reserved, or existential
     *  deposits (when `keep_alive` is `true`), will not be transferred by
     *  this function. To ensure that this function results in a killed
     *  account, you might need to prepare the account by removing any
     *  reference counters, storage deposits, etc...
     * 
     *  The dispatch origin for this call must be `Signed` by the
     *  transactor.
     * 
     *  - `dest`: The recipient of the transfer.
     *  - `currency_id`: currency type.
     *  - `keep_alive`: A boolean to determine if the `transfer_all`
     *    operation should send all of the funds the account has, causing
     *    the sender account to be killed (false), or transfer everything
     *    except at least the existential deposit, which will guarantee to
     *    keep the sender account alive (true).
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Tokens.transfer_all') === '90dc1bacae70625c5e18a5fb0141cab964fb8b16ee35ed5b31f81f2def5ce5e4'
    }

    /**
     *  Transfer all remaining balance to the given account.
     * 
     *  NOTE: This function only attempts to transfer _transferable_
     *  balances. This means that any locked, reserved, or existential
     *  deposits (when `keep_alive` is `true`), will not be transferred by
     *  this function. To ensure that this function results in a killed
     *  account, you might need to prepare the account by removing any
     *  reference counters, storage deposits, etc...
     * 
     *  The dispatch origin for this call must be `Signed` by the
     *  transactor.
     * 
     *  - `dest`: The recipient of the transfer.
     *  - `currency_id`: currency type.
     *  - `keep_alive`: A boolean to determine if the `transfer_all`
     *    operation should send all of the funds the account has, causing
     *    the sender account to be killed (false), or transfer everything
     *    except at least the existential deposit, which will guarantee to
     *    keep the sender account alive (true).
     */
    get asV802(): {dest: v802.LookupSource, currencyId: v802.CurrencyId, keepAlive: boolean} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer all remaining balance to the given account.
     * 
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     *   operation should send all of the funds the account has, causing
     *   the sender account to be killed (false), or transfer everything
     *   except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Tokens.transfer_all') === '59cd7fd66c0e1d47245f6cbb00deb3bc711dabe743a10d4add2118ef8c91580e'
    }

    /**
     * Transfer all remaining balance to the given account.
     * 
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     *   operation should send all of the funds the account has, causing
     *   the sender account to be killed (false), or transfer everything
     *   except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get asV906(): {dest: v906.MultiAddress, currencyId: v906.CurrencyId, keepAlive: boolean} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer all remaining balance to the given account.
     * 
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     *   operation should send all of the funds the account has, causing
     *   the sender account to be killed (false), or transfer everything
     *   except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Tokens.transfer_all') === '4b9c9dc5a531897459dfe361e01cfd24a264318ff79356ec84cba007397e25ae'
    }

    /**
     * Transfer all remaining balance to the given account.
     * 
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     *   operation should send all of the funds the account has, causing
     *   the sender account to be killed (false), or transfer everything
     *   except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get asV916(): {dest: v916.MultiAddress, currencyId: v916.CurrencyId, keepAlive: boolean} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer all remaining balance to the given account.
     * 
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     *   operation should send all of the funds the account has, causing
     *   the sender account to be killed (false), or transfer everything
     *   except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Tokens.transfer_all') === '090a9cd6136345fce9f6a5265b0037f34c55fc10f1f1711b794871277a1c0ad4'
    }

    /**
     * Transfer all remaining balance to the given account.
     * 
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     *   operation should send all of the funds the account has, causing
     *   the sender account to be killed (false), or transfer everything
     *   except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get asV920(): {dest: v920.MultiAddress, currencyId: v920.CurrencyId, keepAlive: boolean} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer all remaining balance to the given account.
     * 
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     *   operation should send all of the funds the account has, causing
     *   the sender account to be killed (false), or transfer everything
     *   except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Tokens.transfer_all') === '30dd0ac7a69c8e6ca476070da7844c9770447efb1285dc19e905e98f6f7cf7e9'
    }

    /**
     * Transfer all remaining balance to the given account.
     * 
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     *   operation should send all of the funds the account has, causing
     *   the sender account to be killed (false), or transfer everything
     *   except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get asV932(): {dest: v932.MultiAddress, currencyId: v932.CurrencyId, keepAlive: boolean} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer all remaining balance to the given account.
     * 
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     *   operation should send all of the funds the account has, causing
     *   the sender account to be killed (false), or transfer everything
     *   except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Tokens.transfer_all') === 'f6b3d769b9183a651a0348f5e5d164a55e00a7fc13c33e5afbe6b1b1c8dc2d49'
    }

    /**
     * Transfer all remaining balance to the given account.
     * 
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     *   operation should send all of the funds the account has, causing
     *   the sender account to be killed (false), or transfer everything
     *   except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get asV956(): {dest: v956.MultiAddress, currencyId: v956.CurrencyId, keepAlive: boolean} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer all remaining balance to the given account.
     * 
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     *   operation should send all of the funds the account has, causing
     *   the sender account to be killed (false), or transfer everything
     *   except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Tokens.transfer_all') === 'ed9bc93c28f9746596742e8fe136b7c73d92107fc3ea1fe73766f4675a1d1f22'
    }

    /**
     * Transfer all remaining balance to the given account.
     * 
     * NOTE: This function only attempts to transfer _transferable_
     * balances. This means that any locked, reserved, or existential
     * deposits (when `keep_alive` is `true`), will not be transferred by
     * this function. To ensure that this function results in a killed
     * account, you might need to prepare the account by removing any
     * reference counters, storage deposits, etc...
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `keep_alive`: A boolean to determine if the `transfer_all`
     *   operation should send all of the funds the account has, causing
     *   the sender account to be killed (false), or transfer everything
     *   except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true).
     */
    get asV962(): {dest: v962.MultiAddress, currencyId: v962.CurrencyId, keepAlive: boolean} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class TokensTransferKeepAliveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tokens.transfer_keep_alive')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Same as the [`transfer`] call, but with a check that the transfer
     *  will not kill the origin account.
     * 
     *  99% of the time you want [`transfer`] instead.
     * 
     *  The dispatch origin for this call must be `Signed` by the
     *  transactor.
     * 
     *  - `dest`: The recipient of the transfer.
     *  - `currency_id`: currency type.
     *  - `amount`: free balance amount to tranfer.
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Tokens.transfer_keep_alive') === '4c4cbab1d07da2115964fbc45ffe538519770d4ed8cefd19ca4b8a0091deb605'
    }

    /**
     *  Same as the [`transfer`] call, but with a check that the transfer
     *  will not kill the origin account.
     * 
     *  99% of the time you want [`transfer`] instead.
     * 
     *  The dispatch origin for this call must be `Signed` by the
     *  transactor.
     * 
     *  - `dest`: The recipient of the transfer.
     *  - `currency_id`: currency type.
     *  - `amount`: free balance amount to tranfer.
     */
    get asV802(): {dest: v802.LookupSource, currencyId: v802.CurrencyId, amount: bigint} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Tokens.transfer_keep_alive') === 'b9fb4d5743e79104d370b60713a3be4e66245f43aaa364cb6d61b0588d7e7a02'
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV906(): {dest: v906.MultiAddress, currencyId: v906.CurrencyId, amount: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Tokens.transfer_keep_alive') === 'a9948001bd2c3683445876d000abbd80e9ab09caa7edc5287f1cfad9aa0a3f16'
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV916(): {dest: v916.MultiAddress, currencyId: v916.CurrencyId, amount: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Tokens.transfer_keep_alive') === 'a1a170cec9dafb23176128f9246a564eec06ec01b8778cde87df8e380c5547ad'
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV920(): {dest: v920.MultiAddress, currencyId: v920.CurrencyId, amount: bigint} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Tokens.transfer_keep_alive') === 'a76551106730e876302af72d8d390053d6c4f5b7fc5028597728d896db6977f5'
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV932(): {dest: v932.MultiAddress, currencyId: v932.CurrencyId, amount: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Tokens.transfer_keep_alive') === 'b6188ad53f64db3b57f68ca0a0374dc7feaac8f5a460fcd009e7836959c34140'
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV956(): {dest: v956.MultiAddress, currencyId: v956.CurrencyId, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Tokens.transfer_keep_alive') === '04924dbf38b6be9c9b1c8f45f093016a733b1ae1eed8f532c3f518d69b77390a'
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer
     * will not kill the origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * The dispatch origin for this call must be `Signed` by the
     * transactor.
     * 
     * - `dest`: The recipient of the transfer.
     * - `currency_id`: currency type.
     * - `amount`: free balance amount to tranfer.
     */
    get asV962(): {dest: v962.MultiAddress, currencyId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryApproveProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.approve_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
     *  and the original deposit will be returned.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - Complexity: O(1).
     *  - DbReads: `Proposals`, `Approvals`
     *  - DbWrite: `Approvals`
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Treasury.approve_proposal') === 'd31c3c178e65331a6ccd6f8dca07268f945f39b38e51421afd1c9e1f5bc0f6c8'
    }

    /**
     *  Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
     *  and the original deposit will be returned.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - Complexity: O(1).
     *  - DbReads: `Proposals`, `Approvals`
     *  - DbWrite: `Approvals`
     *  # </weight>
     */
    get asV803(): {proposalId: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryProposeSpendCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.propose_spend')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Put forward a suggestion for spending. A deposit proportional to the value
     *  is reserved and slashed if the proposal is rejected. It is returned once the
     *  proposal is awarded.
     * 
     *  # <weight>
     *  - Complexity: O(1)
     *  - DbReads: `ProposalCount`, `origin account`
     *  - DbWrites: `ProposalCount`, `Proposals`, `origin account`
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Treasury.propose_spend') === 'c9f0fb5ad91e84a77c5f948f4140d239e238788ae3191c594dc1e6592472d5a7'
    }

    /**
     *  Put forward a suggestion for spending. A deposit proportional to the value
     *  is reserved and slashed if the proposal is rejected. It is returned once the
     *  proposal is awarded.
     * 
     *  # <weight>
     *  - Complexity: O(1)
     *  - DbReads: `ProposalCount`, `origin account`
     *  - DbWrites: `ProposalCount`, `Proposals`, `origin account`
     *  # </weight>
     */
    get asV803(): {value: bigint, beneficiary: v803.LookupSource} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryRejectProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.reject_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Reject a proposed spend. The original deposit will be slashed.
     * 
     *  May only be called from `T::RejectOrigin`.
     * 
     *  # <weight>
     *  - Complexity: O(1)
     *  - DbReads: `Proposals`, `rejected proposer account`
     *  - DbWrites: `Proposals`, `rejected proposer account`
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Treasury.reject_proposal') === 'd31c3c178e65331a6ccd6f8dca07268f945f39b38e51421afd1c9e1f5bc0f6c8'
    }

    /**
     *  Reject a proposed spend. The original deposit will be slashed.
     * 
     *  May only be called from `T::RejectOrigin`.
     * 
     *  # <weight>
     *  - Complexity: O(1)
     *  - DbReads: `Proposals`, `rejected proposer account`
     *  - DbWrites: `Proposals`, `rejected proposer account`
     *  # </weight>
     */
    get asV803(): {proposalId: number} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryRemoveApprovalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.remove_approval')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     * The original deposit will no longer be returned.
     * 
     * May only be called from `T::RejectOrigin`.
     * - `proposal_id`: The index of a proposal
     * 
     * # <weight>
     * - Complexity: O(A) where `A` is the number of approvals
     * - Db reads and writes: `Approvals`
     * # </weight>
     * 
     * Errors:
     * - `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
     * i.e., the proposal has not been approved. This could also mean the proposal does not
     * exist altogether, thus there is no way it would have been approved in the first place.
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Treasury.remove_approval') === 'd31c3c178e65331a6ccd6f8dca07268f945f39b38e51421afd1c9e1f5bc0f6c8'
    }

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     * The original deposit will no longer be returned.
     * 
     * May only be called from `T::RejectOrigin`.
     * - `proposal_id`: The index of a proposal
     * 
     * # <weight>
     * - Complexity: O(A) where `A` is the number of approvals
     * - Db reads and writes: `Approvals`
     * # </weight>
     * 
     * Errors:
     * - `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
     * i.e., the proposal has not been approved. This could also mean the proposal does not
     * exist altogether, thus there is no way it would have been approved in the first place.
     */
    get asV944(): {proposalId: number} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasurySpendCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.spend')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Propose and approve a spend of treasury funds.
     * 
     * - `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     * 
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Treasury.spend') === '071bf09e74d36313b4b241a263e02056bbc233afc4a912f6614b0fa62c61ca8e'
    }

    /**
     * Propose and approve a spend of treasury funds.
     * 
     * - `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     * 
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     */
    get asV952(): {amount: bigint, beneficiary: v952.MultiAddress} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityAsDerivativeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.as_derivative')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '4caf65a96b27d466bc7c40d262649289d8b6b7d280c29f40e1aea3dfaf30e5c2'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV1(): {index: number, call: v1.Type_51} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV801(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '364f00fcda5700dc306767fc422b62e773cb17b126e3ee91cd4b34e5bc523058'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV801(): {index: number, call: v801.Type_48} {
        assert(this.isV801)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'bb8da37e0be06864a96933682db5d95ca23c111cc8f672d55c421f076f692701'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV802(): {index: number, call: v802.Type_48} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '3503bdeddbf8a2a478d8e4bc73fe9855d31f4e5c0ce0e30cfd6f3f287728c303'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV803(): {index: number, call: v803.Type_51} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '0a9f3dda99912fc6974aed70d5ad3536db81fadd3500a2f95ec19d6b5de806e0'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV804(): {index: number, call: v804.Type_51} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV805(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '6d83b4b9350f9b284575f7217e6f66b3085788fe48e718fa5645fd0a9b3cf800'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV805(): {index: number, call: v805.Type_118} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '57f752f2186b45c65aa5debf604610b4f1924c698196c87f841ceb09759d174a'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV900(): {index: number, call: v900.Type_118} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV901(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '329759864f506ac4c68a9784b7280dec76b9741d9fd53ea67712021d91a57819'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV901(): {index: number, call: v901.Type_118} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'b56631e862e0a2bb3fd41a9fbe34853b6eaa2fdc515be0e81f87ec5945416c1b'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV902(): {index: number, call: v902.Type_118} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '620f9411e003dd0684376980169248328b037fd8e1b7a66c597b1a075911a53e'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV906(): {index: number, call: v906.Call} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'a01740b1fc0596b6bd962a6a1c1cb4191dbb727d8317e4afbf6f4451055b503c'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV908(): {index: number, call: v908.Call} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV910(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '4013affca71fe50ca9d928f57279656ac2b3f93c3a57dfce6b0af4a4c8eddc69'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV910(): {index: number, call: v910.Call} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV912(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'db5813d0a0a786c9a3048af5f8c13d780d6fc6d8060d2040cccb2f01f48eaa7b'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV912(): {index: number, call: v912.Call} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV914(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '2343d8f924766ca6a3c0c15f6bf4f2fc49c6e116b7e10f2f2d359742a8b46af8'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV914(): {index: number, call: v914.Call} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV915(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '6bf8c351c9e69308a3ac2125356a58fd3c5fab110ce73c8a2b3988a7bae6caa7'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV915(): {index: number, call: v915.Call} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '5e37e03c79e3310aa4c223bd03f23492f55fb85918926762c252f62f322a2a47'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV916(): {index: number, call: v916.Call} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'db9ff782c0f1535b69bdeba2025d0523166d46671680b3f7288ce0b2583008fd'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV918(): {index: number, call: v918.Call} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'b7cafe671321ad42b5ab83edaa87d7bc35c2a2987ac8ee4d16ea060c5a52975c'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV920(): {index: number, call: v920.Call} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'e1895ecae91d468c04d07cfe5a301b1e86ffa5865b4b657194a293e294445467'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV922(): {index: number, call: v922.Call} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '989ed2d374e7780504932e377f941edb1cf6fd7dc70646de7079023da8589136'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV923(): {index: number, call: v923.Call} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '82e608b3c80e28e282bd72da304b0befd8ca3f04a3f1cf4cf636ff6e95f693c3'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV926(): {index: number, call: v926.Call} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '9da1363781ba79497c4a74e959f6e94003f6f3f814af7a4abbd58ef21aaaed4b'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV927(): {index: number, call: v927.Call} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'd36513fb08210519fd796e12d38b92a43913237d230d656cf93cfa8f08c14163'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV930(): {index: number, call: v930.Call} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '3c9d826649a82899cccb2b701ccc2921f0b561dc0da5b1283da83b3449f43c08'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV932(): {index: number, call: v932.Call} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'd33e34aa55bce474a47c82244035718fa70e4286c29755d13dbc67ef595a8b10'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV940(): {index: number, call: v940.Call} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '2c49a6c4c9c76a3e016f0d16e5d01821192ec9d829ee7e86f95f74244f6305b7'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV942(): {index: number, call: v942.Call} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '2121ce71a3d1bcaea091445c085eea021f3cfcf108285772427dccba3f7f89fd'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV944(): {index: number, call: v944.Call} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '60dda037a6acf240adf67829c48c58c62c0886ce1d0d4c692b2f15c5887990b5'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV946(): {index: number, call: v946.Call} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '75b603eed1d4b952acc98f5d62d94c19fc9ae4b79ae424456018d4df8f9f3b3b'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV948(): {index: number, call: v948.Call} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '905ac13c4f93e6faa0153ec542d05f91bade89cbd3fea1d24f59a8b3c189b9c9'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV952(): {index: number, call: v952.Call} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '7a43daf66d553813553d40dbef53e26edbb7e578837bdca002e5985cea1e6931'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV954(): {index: number, call: v954.Call} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '40fb8995565ce4a4cb6fbb61bbf54231a15b4291b39c99605b1527db3b1930d0'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV956(): {index: number, call: v956.Call} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '108924c8309550edf0d636b9ab0dfe6bb62900147e5aab141f2ccd5f2b9cae18'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV958(): {index: number, call: v958.Call} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'bf8e0b5a56331ce66114432219c83bb38c46e64a0083e7ad2dac6f3f158aec29'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV962(): {index: number, call: v962.Call} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '4b2c72007c2f1e290d01272c5f94d41a55c2aa32a9c82836fa82ebdc88f3d78b'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV964(): {index: number, call: v964.Call} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '67bf640b77659cd3a7dafe478daa0e82fdb8c1e560a4b0427a7049050a259f4e'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV967(): {index: number, call: v967.Call} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'a411c332d147fc4e2413b270b749f6f021b54abd9cde94b1ea40c45610173036'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV968(): {index: number, call: v968.Call} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '91bf8f362ceef2be451d377ca53de7c54de7cc44a84f47bc2a6d4fce6fd94184'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV970(): {index: number, call: v970.Call} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '1895995806256bbe9c0cf68294fd7352b0438b42b09808aad7db5900a65a0fe5'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV972(): {index: number, call: v972.Call} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityBatchCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.batch')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'b543af7f3c017fcb53a0134aa580c0a947644346c799341238648214770319bc'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV1(): {calls: v1.Type_51[]} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV801(): boolean {
        return this._chain.getCallHash('Utility.batch') === '5bd557d0f146ff71f34790183493656e4b22373321f07ec37b042d24d7a847e8'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV801(): {calls: v801.Type_48[]} {
        assert(this.isV801)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Utility.batch') === '4f015c28afae2f11ed63d57494ed531134d19ad0b66a334fb7b9ce8c91e04a01'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV802(): {calls: v802.Type_48[]} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Utility.batch') === '53cee66b2f5d1cc866689f40621e28217900bc0aafcf73c945101d98429bf655'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV803(): {calls: v803.Type_51[]} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Utility.batch') === '7f2b5611680c0bc649c7cc90dcf060cb1b3a7b0817a3349520348d1db39a82d4'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV804(): {calls: v804.Type_51[]} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV805(): boolean {
        return this._chain.getCallHash('Utility.batch') === '6054d56c6209682508fe40d20199023de1c19ee90e93aa0bdae846eb1e613607'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV805(): {calls: v805.Type_118[]} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Utility.batch') === '6c8c52b8df3d5599260475bf82a88c248934bd4fb3fcbb65b249390f6bb2283d'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV900(): {calls: v900.Type_118[]} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV901(): boolean {
        return this._chain.getCallHash('Utility.batch') === '8ce171cd2a9d2fb8fbe3d69fdb197a8cfac391aeda54dbd8d86889989bd8a949'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV901(): {calls: v901.Type_118[]} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('Utility.batch') === '51e0ed1857166e242a2f638679f01bbeb70922611ce33765310353771e0db714'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV902(): {calls: v902.Type_118[]} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'b39f189b9a74cf044eac680587d6bf9145001a51ba5c94c2e7809947a31c42a9'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV906(): {calls: v906.Call[]} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Utility.batch') === '0fb6a1613bb01d331af06e0834c152067b16917ccbd7b0877c627a164cec42d8'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV908(): {calls: v908.Call[]} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV910(): boolean {
        return this._chain.getCallHash('Utility.batch') === '3bab7d70ad21fe09de79514a754ea12dd28927f4ae61f23f7485d8a588c22938'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV910(): {calls: v910.Call[]} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV912(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'a45c9c798851d0a4910d53322750fd7cc17299bde199ca3a1ceebad6babc8397'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV912(): {calls: v912.Call[]} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV914(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'aed9c9535ed7d1e223f7e250816c5e4712aa3056be3e431ad1c656ea4bde1a07'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV914(): {calls: v914.Call[]} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV915(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'ddd36583e0426994413591500965ba824cdc592a2b27ec7930f0f356721d1ef5'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV915(): {calls: v915.Call[]} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Utility.batch') === '59ae854d770d575f1801ed37683e39d32fb1163246b5732b991b7b0488b5d2fb'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV916(): {calls: v916.Call[]} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Utility.batch') === '8f50ddae742a3221c4960d357fd7980624c73b71514b5e866ff53f5d832a8508'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV918(): {calls: v918.Call[]} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'bf97c1ec5bf011046ca155c9e7c453f6e283c40b403ba8bcbd2e46e2fbd0b6cc'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV920(): {calls: v920.Call[]} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'ff7e8d28b2e832ebd13895bd9d14a7687a9b9ec3f736ae1a152ac8b8030ae42f'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV922(): {calls: v922.Call[]} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'b2722feec8ae85ffd524b7123ae6a10cdd8b952249faaaa7ef9c3ad3944491a1'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV923(): {calls: v923.Call[]} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Utility.batch') === '96ab38a6ab1d5ff6034efb510095032335a2351cf095de032e53a541c901134b'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV926(): {calls: v926.Call[]} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'a3dc17e4840a3a9447f640e1d120799171e5e51ead9ee702b94fb61b92027c29'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV927(): {calls: v927.Call[]} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Utility.batch') === '00ffc6c06a58d502cb642d550574d9b20dec995264e5411c794b0c27021ddedb'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV930(): {calls: v930.Call[]} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Utility.batch') === '5f5d6874e4ad3bfea59570e719009e5704a7b449e12c6e1067056dc38e7aac8e'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV932(): {calls: v932.Call[]} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'a8ad5526295f72c868dd25a212ee1211e18f979fba302b4df998d893192c11e0'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV940(): {calls: v940.Call[]} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'aee9513ff995818254f6d2a0ea1b88e6f4777fe9d933b99328204e8e3d0ef55d'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV942(): {calls: v942.Call[]} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Utility.batch') === '4228c4c92e04f7251b2857b9e9332dc26c365ab8259d73392ef11c00146eccb8'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV944(): {calls: v944.Call[]} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Utility.batch') === '54e2bd4c8157434fd11e02d26c5d3eb5f68d17ec6c45be43a82152a08a0bb0db'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV946(): {calls: v946.Call[]} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Utility.batch') === '51eabe4e8f2ea8bc30f0a030b5fe9ade404f3ac662f854cf4dc8ad57dfb8d2c7'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV948(): {calls: v948.Call[]} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Utility.batch') === '12e3a276ae2637c3bee86647d3492ad1765cb2af903befe60a3cdf2303d40a67'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV952(): {calls: v952.Call[]} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'b3ff1fc1ab64822aebdf1b85d35e91887a884b7a6f102104b0bb2c0eb05bec43'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV954(): {calls: v954.Call[]} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Utility.batch') === '5c8af86caaa77e472a7d4a120c9d73b551557f77b68e6667132c1b1db1671103'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV956(): {calls: v956.Call[]} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Utility.batch') === '9b81da3cb5ab10bc9c5a32ce410d1feb93f7e52e1f252c7251d1bd8e843931c7'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV958(): {calls: v958.Call[]} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Utility.batch') === '29da54e815a22aed5d86f2276114bb691b7eed892db7fa2e7a20e64cbce79914'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV962(): {calls: v962.Call[]} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Utility.batch') === '57a9f2d1a080e36c25f0e14a6dde0be536b596248edaa98f5d8b8dde06271989'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV964(): {calls: v964.Call[]} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'af4a5210f89878919d77a6cd37dec9ba1d42bf8b3af3ae32dd91f5e874944de3'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV967(): {calls: v967.Call[]} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'aeef9c8de06794b2b385fec78a22987c3da23d3ac808f435a65138df55d68a54'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV968(): {calls: v968.Call[]} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'b1fceaa51fe0fa072fe9fb163f2558c55f3318a1e609203c8e16b3d9397344d3'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV970(): {calls: v970.Call[]} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Utility.batch') === '9b81376896d5764aeb77347d490b3ba696646768e5d75fbe8a2c902a78a3039d'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV972(): {calls: v972.Call[]} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityBatchAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.batch_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'b543af7f3c017fcb53a0134aa580c0a947644346c799341238648214770319bc'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV1(): {calls: v1.Type_51[]} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV801(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '5bd557d0f146ff71f34790183493656e4b22373321f07ec37b042d24d7a847e8'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV801(): {calls: v801.Type_48[]} {
        assert(this.isV801)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV802(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '4f015c28afae2f11ed63d57494ed531134d19ad0b66a334fb7b9ce8c91e04a01'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV802(): {calls: v802.Type_48[]} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV803(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '53cee66b2f5d1cc866689f40621e28217900bc0aafcf73c945101d98429bf655'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV803(): {calls: v803.Type_51[]} {
        assert(this.isV803)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV804(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '7f2b5611680c0bc649c7cc90dcf060cb1b3a7b0817a3349520348d1db39a82d4'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV804(): {calls: v804.Type_51[]} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV805(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '6054d56c6209682508fe40d20199023de1c19ee90e93aa0bdae846eb1e613607'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV805(): {calls: v805.Type_118[]} {
        assert(this.isV805)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV900(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '6c8c52b8df3d5599260475bf82a88c248934bd4fb3fcbb65b249390f6bb2283d'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV900(): {calls: v900.Type_118[]} {
        assert(this.isV900)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV901(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '8ce171cd2a9d2fb8fbe3d69fdb197a8cfac391aeda54dbd8d86889989bd8a949'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV901(): {calls: v901.Type_118[]} {
        assert(this.isV901)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV902(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '51e0ed1857166e242a2f638679f01bbeb70922611ce33765310353771e0db714'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV902(): {calls: v902.Type_118[]} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV906(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'b39f189b9a74cf044eac680587d6bf9145001a51ba5c94c2e7809947a31c42a9'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV906(): {calls: v906.Call[]} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV908(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '0fb6a1613bb01d331af06e0834c152067b16917ccbd7b0877c627a164cec42d8'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV908(): {calls: v908.Call[]} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV910(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '3bab7d70ad21fe09de79514a754ea12dd28927f4ae61f23f7485d8a588c22938'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV910(): {calls: v910.Call[]} {
        assert(this.isV910)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV912(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'a45c9c798851d0a4910d53322750fd7cc17299bde199ca3a1ceebad6babc8397'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV912(): {calls: v912.Call[]} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV914(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'aed9c9535ed7d1e223f7e250816c5e4712aa3056be3e431ad1c656ea4bde1a07'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV914(): {calls: v914.Call[]} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV915(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'ddd36583e0426994413591500965ba824cdc592a2b27ec7930f0f356721d1ef5'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV915(): {calls: v915.Call[]} {
        assert(this.isV915)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '59ae854d770d575f1801ed37683e39d32fb1163246b5732b991b7b0488b5d2fb'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV916(): {calls: v916.Call[]} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '8f50ddae742a3221c4960d357fd7980624c73b71514b5e866ff53f5d832a8508'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV918(): {calls: v918.Call[]} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'bf97c1ec5bf011046ca155c9e7c453f6e283c40b403ba8bcbd2e46e2fbd0b6cc'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV920(): {calls: v920.Call[]} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'ff7e8d28b2e832ebd13895bd9d14a7687a9b9ec3f736ae1a152ac8b8030ae42f'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV922(): {calls: v922.Call[]} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'b2722feec8ae85ffd524b7123ae6a10cdd8b952249faaaa7ef9c3ad3944491a1'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV923(): {calls: v923.Call[]} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '96ab38a6ab1d5ff6034efb510095032335a2351cf095de032e53a541c901134b'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV926(): {calls: v926.Call[]} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'a3dc17e4840a3a9447f640e1d120799171e5e51ead9ee702b94fb61b92027c29'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV927(): {calls: v927.Call[]} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '00ffc6c06a58d502cb642d550574d9b20dec995264e5411c794b0c27021ddedb'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV930(): {calls: v930.Call[]} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '5f5d6874e4ad3bfea59570e719009e5704a7b449e12c6e1067056dc38e7aac8e'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV932(): {calls: v932.Call[]} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'a8ad5526295f72c868dd25a212ee1211e18f979fba302b4df998d893192c11e0'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV940(): {calls: v940.Call[]} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'aee9513ff995818254f6d2a0ea1b88e6f4777fe9d933b99328204e8e3d0ef55d'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV942(): {calls: v942.Call[]} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '4228c4c92e04f7251b2857b9e9332dc26c365ab8259d73392ef11c00146eccb8'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV944(): {calls: v944.Call[]} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '54e2bd4c8157434fd11e02d26c5d3eb5f68d17ec6c45be43a82152a08a0bb0db'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV946(): {calls: v946.Call[]} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '51eabe4e8f2ea8bc30f0a030b5fe9ade404f3ac662f854cf4dc8ad57dfb8d2c7'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV948(): {calls: v948.Call[]} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '12e3a276ae2637c3bee86647d3492ad1765cb2af903befe60a3cdf2303d40a67'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV952(): {calls: v952.Call[]} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'b3ff1fc1ab64822aebdf1b85d35e91887a884b7a6f102104b0bb2c0eb05bec43'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV954(): {calls: v954.Call[]} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '5c8af86caaa77e472a7d4a120c9d73b551557f77b68e6667132c1b1db1671103'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV956(): {calls: v956.Call[]} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '9b81da3cb5ab10bc9c5a32ce410d1feb93f7e52e1f252c7251d1bd8e843931c7'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV958(): {calls: v958.Call[]} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '29da54e815a22aed5d86f2276114bb691b7eed892db7fa2e7a20e64cbce79914'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV962(): {calls: v962.Call[]} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '57a9f2d1a080e36c25f0e14a6dde0be536b596248edaa98f5d8b8dde06271989'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV964(): {calls: v964.Call[]} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'af4a5210f89878919d77a6cd37dec9ba1d42bf8b3af3ae32dd91f5e874944de3'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV967(): {calls: v967.Call[]} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'aeef9c8de06794b2b385fec78a22987c3da23d3ac808f435a65138df55d68a54'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV968(): {calls: v968.Call[]} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'b1fceaa51fe0fa072fe9fb163f2558c55f3318a1e609203c8e16b3d9397344d3'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV970(): {calls: v970.Call[]} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '9b81376896d5764aeb77347d490b3ba696646768e5d75fbe8a2c902a78a3039d'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV972(): {calls: v972.Call[]} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityDispatchAsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.dispatch_as')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV916(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '44c6d318ea0eec6c51d04a5399658e3e6c6a0a9c3e3a6ea4614c7ce8ca9a7aac'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV916(): {asOrigin: v916.OriginCaller, call: v916.Call} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV918(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'fe76bd2b168fc8de440e6692ff372000ce403b747d8b84d7f4fc75ae3c360444'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV918(): {asOrigin: v918.OriginCaller, call: v918.Call} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV920(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '41b7fce7d54387883a3b625c1cd4b4977567d42f7fb50839bb0932b0e2f53e79'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV920(): {asOrigin: v920.OriginCaller, call: v920.Call} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV922(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '6a63f46fbc16553b666efb567955b9f295108da6a77e4d6e3b63817248043882'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV922(): {asOrigin: v922.OriginCaller, call: v922.Call} {
        assert(this.isV922)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV923(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '4b7f0e324915b9d90b241d459515bb6bd7826c05937d9bb5c2dde3e470651a9a'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV923(): {asOrigin: v923.OriginCaller, call: v923.Call} {
        assert(this.isV923)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV926(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '6440db7ad97b9f6480b6cb4ab7483d5c5f12c6ac62f2a6733860b72a860f61d2'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV926(): {asOrigin: v926.OriginCaller, call: v926.Call} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV927(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '11ca1326c9eca608a8e05fe548a7865a7c1706896e9105596986564bbc7bdddb'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV927(): {asOrigin: v927.OriginCaller, call: v927.Call} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV930(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '4d4a5ac1834810477ea676a7d58d799a68c919dc21e7475daecb20e7a9e7a864'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV930(): {asOrigin: v930.OriginCaller, call: v930.Call} {
        assert(this.isV930)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV932(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '00a5a0c28359297bd31525585665ae1eb7a866d41ff2a35988929ceb45af6a28'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV932(): {asOrigin: v932.OriginCaller, call: v932.Call} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV940(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '25568c32ed2355ee75d3beca3fe9124bfc33442c94536e0c7ab14b3f6ce951db'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV940(): {asOrigin: v940.OriginCaller, call: v940.Call} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV942(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '5d9e5d54c2f6d1ff744daf24f66c06a95a3d724e10e2c0cdc0a5ec707bfe45c9'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV942(): {asOrigin: v942.OriginCaller, call: v942.Call} {
        assert(this.isV942)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '74cb03915413c55beefdce9bf06c7182c4e9a11079bb225c5d6ca4fa32d2a480'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV944(): {asOrigin: v944.OriginCaller, call: v944.Call} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '959d212170b6300e1710baee1fd34324addc2047fc6f1023b8739ce13587722a'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV946(): {asOrigin: v946.OriginCaller, call: v946.Call} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'd5d744fb15f8c1c61e2344353588c599d45d8e5b5384969890fd6c00e7415c08'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV948(): {asOrigin: v948.OriginCaller, call: v948.Call} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '2db3cc9f8f5a7d363e7f32b40d7477eaa512e43a810b7f0edb131c6e6dd0d35d'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV952(): {asOrigin: v952.OriginCaller, call: v952.Call} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '2cdd66b0895b12e632209f841bdc330d59b03a16ab8c6175defe34793e473f16'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV954(): {asOrigin: v954.OriginCaller, call: v954.Call} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '7ccfd5bdf3f67ec8d374aa5695a1fb03144be25e91527e38ba6c235ce9f8adf3'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV956(): {asOrigin: v956.OriginCaller, call: v956.Call} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'b0e8b9e10d0c83d018c2085899c7b1592372f97379c81a8284c55ccb7e2b2276'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV958(): {asOrigin: v958.OriginCaller, call: v958.Call} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '8dc4fcad94ced76719060f12fb9840179e890c1683eedf6c6f08a0ea9b78fbc5'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV962(): {asOrigin: v962.OriginCaller, call: v962.Call} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '7c979786d1a6b479751248939aad2cf1996e0b11c8e781885a56f91a2a47fc99'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV964(): {asOrigin: v964.OriginCaller, call: v964.Call} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '45b187a72c49002b643c24eee248a0acb0e0e5c6f00696363d18b38fb60132e6'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV967(): {asOrigin: v967.OriginCaller, call: v967.Call} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'cc481eb86cfe3be9a09dbf0f7c0116cdfcf628a0e6a5ad8f0f432197efc55111'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV968(): {asOrigin: v968.OriginCaller, call: v968.Call} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '2aa754584387e4df673e7c6b3880a0f620de614b887c04e3aca79850d96ccd5a'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV970(): {asOrigin: v970.OriginCaller, call: v970.Call} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'd0489523729360354f4354ebc677e539380df30ab9d74b0ea2c68eaf0aa8dbda'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV972(): {asOrigin: v972.OriginCaller, call: v972.Call} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityForceBatchCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.force_batch')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV944(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '4228c4c92e04f7251b2857b9e9332dc26c365ab8259d73392ef11c00146eccb8'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV944(): {calls: v944.Call[]} {
        assert(this.isV944)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV946(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '54e2bd4c8157434fd11e02d26c5d3eb5f68d17ec6c45be43a82152a08a0bb0db'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV946(): {calls: v946.Call[]} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV948(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '51eabe4e8f2ea8bc30f0a030b5fe9ade404f3ac662f854cf4dc8ad57dfb8d2c7'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV948(): {calls: v948.Call[]} {
        assert(this.isV948)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV952(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '12e3a276ae2637c3bee86647d3492ad1765cb2af903befe60a3cdf2303d40a67'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV952(): {calls: v952.Call[]} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV954(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === 'b3ff1fc1ab64822aebdf1b85d35e91887a884b7a6f102104b0bb2c0eb05bec43'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV954(): {calls: v954.Call[]} {
        assert(this.isV954)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV956(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '5c8af86caaa77e472a7d4a120c9d73b551557f77b68e6667132c1b1db1671103'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV956(): {calls: v956.Call[]} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV958(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '9b81da3cb5ab10bc9c5a32ce410d1feb93f7e52e1f252c7251d1bd8e843931c7'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV958(): {calls: v958.Call[]} {
        assert(this.isV958)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV962(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '29da54e815a22aed5d86f2276114bb691b7eed892db7fa2e7a20e64cbce79914'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV962(): {calls: v962.Call[]} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV964(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '57a9f2d1a080e36c25f0e14a6dde0be536b596248edaa98f5d8b8dde06271989'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV964(): {calls: v964.Call[]} {
        assert(this.isV964)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV967(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === 'af4a5210f89878919d77a6cd37dec9ba1d42bf8b3af3ae32dd91f5e874944de3'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV967(): {calls: v967.Call[]} {
        assert(this.isV967)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV968(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === 'aeef9c8de06794b2b385fec78a22987c3da23d3ac808f435a65138df55d68a54'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV968(): {calls: v968.Call[]} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === 'b1fceaa51fe0fa072fe9fb163f2558c55f3318a1e609203c8e16b3d9397344d3'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV970(): {calls: v970.Call[]} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '9b81376896d5764aeb77347d490b3ba696646768e5d75fbe8a2c902a78a3039d'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV972(): {calls: v972.Call[]} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityWithWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.with_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '12f6e4005d7f5a9f2cc0dadac2f9d8a16e5bdf25434e27bfc38efe17213d91b5'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV970(): {call: v970.Call, weight: v970.Weight} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === 'bc3d6983147d82c6b523ab3be4745479f690a30bb67d8d4227f74cbe26480a8e'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV972(): {call: v972.Call, weight: v972.Weight} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class VsBondAuctionClinchOrderCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VSBondAuction.clinch_order')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Users(non-order-creator) buy the remaining `vsbond` of a sell order.
     */
    get isV912(): boolean {
        return this._chain.getCallHash('VSBondAuction.clinch_order') === 'dbf60d48785f86c03740ee19384747b788c2cda0aed29567a50377d3c2faeba0'
    }

    /**
     * Users(non-order-creator) buy the remaining `vsbond` of a sell order.
     */
    get asV912(): {orderId: bigint} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }
}

export class VsBondAuctionCreateOrderCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VSBondAuction.create_order')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a sell order or buy order to sell `vsbond`.
     */
    get isV912(): boolean {
        return this._chain.getCallHash('VSBondAuction.create_order') === '289cb3854164445829d5995af1d01a7e5157248dfc73b2a8f9fd23f20321b271'
    }

    /**
     * Create a sell order or buy order to sell `vsbond`.
     */
    get asV912(): {index: number, tokenSymbol: v912.TokenSymbol, firstSlot: number, lastSlot: number, amount: bigint, totalPrice: bigint, orderType: v912.OrderType} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a sell order or buy order to sell `vsbond`.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('VSBondAuction.create_order') === '7d4efd875e538a1d21b1dec0cd901c2ff2e5d304bb629008681a87060c4ece88'
    }

    /**
     * Create a sell order or buy order to sell `vsbond`.
     */
    get asV916(): {index: number, tokenSymbol: v916.TokenSymbol, firstSlot: number, lastSlot: number, amount: bigint, totalPrice: bigint, orderType: v916.OrderType} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a sell order or buy order to sell `vsbond`.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('VSBondAuction.create_order') === '78b997364bfdee2c6b57d171ee6641531d654b4c7317863763dda06e1d9941d4'
    }

    /**
     * Create a sell order or buy order to sell `vsbond`.
     */
    get asV920(): {index: number, tokenSymbol: v920.TokenSymbol, firstSlot: number, lastSlot: number, amount: bigint, totalPrice: bigint, orderType: v920.OrderType} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a sell order or buy order to sell `vsbond`.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('VSBondAuction.create_order') === 'eec9ba63dd26a6e2da4c474967d54295f97f4b89095e1dba803de132db0fc801'
    }

    /**
     * Create a sell order or buy order to sell `vsbond`.
     */
    get asV932(): {index: number, tokenSymbol: v932.TokenSymbol, firstSlot: number, lastSlot: number, amount: bigint, totalPrice: bigint, orderType: v932.OrderType} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class VsBondAuctionForceRevokeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VSBondAuction.force_revoke')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Revoke a sell or buy order in trade by the order creator.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('VSBondAuction.force_revoke') === 'dbf60d48785f86c03740ee19384747b788c2cda0aed29567a50377d3c2faeba0'
    }

    /**
     * Revoke a sell or buy order in trade by the order creator.
     */
    get asV916(): {orderId: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }
}

export class VsBondAuctionPartialClinchOrderCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VSBondAuction.partial_clinch_order')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Users(non-order-creator) buys some of the remaining `vsbond` of a sell or buy order.
     */
    get isV912(): boolean {
        return this._chain.getCallHash('VSBondAuction.partial_clinch_order') === 'fa10f8a2b3a1a55b108536c0a04fb91f9db397a4211b5a5dd2d38358a59acfaf'
    }

    /**
     * Users(non-order-creator) buys some of the remaining `vsbond` of a sell or buy order.
     */
    get asV912(): {orderId: bigint, quantity: bigint} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }
}

export class VsBondAuctionRevokeOrderCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VSBondAuction.revoke_order')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Revoke a sell or buy order in trade by the order creator.
     */
    get isV912(): boolean {
        return this._chain.getCallHash('VSBondAuction.revoke_order') === 'dbf60d48785f86c03740ee19384747b788c2cda0aed29567a50377d3c2faeba0'
    }

    /**
     * Revoke a sell or buy order in trade by the order creator.
     */
    get asV912(): {orderId: bigint} {
        assert(this.isV912)
        return this._chain.decodeCall(this.call)
    }
}

export class VsBondAuctionSetBuyAndSellTransactionFeeRateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VSBondAuction.set_buy_and_sell_transaction_fee_rate')
        this._chain = ctx._chain
        this.call = call
    }

    get isV916(): boolean {
        return this._chain.getCallHash('VSBondAuction.set_buy_and_sell_transaction_fee_rate') === '07e2ebba0963eea12740714ce5142ea69beacab6cc53086e74d41b014ee0065d'
    }

    get asV916(): {buyRate: number, sellRate: number} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingForceSetCliffCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.force_set_cliff')
        this._chain = ctx._chain
        this.call = call
    }

    get isV918(): boolean {
        return this._chain.getCallHash('Vesting.force_set_cliff') === '0c2779371187946bfeaaac8dbd18d158063ad357333985132c960a54b5c9b704'
    }

    get asV918(): {target: v918.MultiAddress, cliffBlock: number} {
        assert(this.isV918)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingForceSetVestedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.force_set_vested')
        this._chain = ctx._chain
        this.call = call
    }

    get isV802(): boolean {
        return this._chain.getCallHash('Vesting.force_set_vested') === '554d1f39e9f4e4663daedd61474fa370dcb45b83a4deb1389e96844935fd266e'
    }

    get asV802(): {source: v802.LookupSource, target: v802.LookupSource, schedule: v802.VestingInfo} {
        assert(this.isV802)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingForceVestedTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.force_vested_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force a vested transfer.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `source`: The account whose funds should be transferred.
     *  - `target`: The account that should be transferred the vested funds.
     *  - `amount`: The amount of funds to transfer and will be vested.
     *  - `schedule`: The vesting schedule attached to the transfer.
     * 
     *  Emits `VestingCreated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 4 Reads, 4 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account, Source Account
     *      - Writes: Vesting Storage, Balances Locks, Target Account, Source Account
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Vesting.force_vested_transfer') === '554d1f39e9f4e4663daedd61474fa370dcb45b83a4deb1389e96844935fd266e'
    }

    /**
     *  Force a vested transfer.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `source`: The account whose funds should be transferred.
     *  - `target`: The account that should be transferred the vested funds.
     *  - `amount`: The amount of funds to transfer and will be vested.
     *  - `schedule`: The vesting schedule attached to the transfer.
     * 
     *  Emits `VestingCreated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 4 Reads, 4 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account, Source Account
     *      - Writes: Vesting Storage, Balances Locks, Target Account, Source Account
     *  # </weight>
     */
    get asV1(): {source: v1.LookupSource, target: v1.LookupSource, schedule: v1.VestingInfo} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingInitVestingStartAtCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.init_vesting_start_at')
        this._chain = ctx._chain
        this.call = call
    }

    get isV1(): boolean {
        return this._chain.getCallHash('Vesting.init_vesting_start_at') === '23387e7bfae6320aa47fa1faea3c94545838637dddff757f68eb290d1ad92e1b'
    }

    get asV1(): {vestingStartAt: number} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingSetVestingPerBlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.set_vesting_per_block')
        this._chain = ctx._chain
        this.call = call
    }

    get isV916(): boolean {
        return this._chain.getCallHash('Vesting.set_vesting_per_block') === '8440bb7d6b034b4cd9d8ee5462ce26d217856ab97f9b4c9d8280ea8e3dbc497e'
    }

    get asV916(): {target: v916.MultiAddress, perBlock: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingVestCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.vest')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unlock any vested funds of the sender account.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have funds still
     *  locked under this pallet.
     * 
     *  Emits either `VestingCompleted` or `VestingUpdated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 2 Reads, 2 Writes
     *      - Reads: Vesting Storage, Balances Locks, [Sender Account]
     *      - Writes: Vesting Storage, Balances Locks, [Sender Account]
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Vesting.vest') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Unlock any vested funds of the sender account.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have funds still
     *  locked under this pallet.
     * 
     *  Emits either `VestingCompleted` or `VestingUpdated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 2 Reads, 2 Writes
     *      - Reads: Vesting Storage, Balances Locks, [Sender Account]
     *      - Writes: Vesting Storage, Balances Locks, [Sender Account]
     *  # </weight>
     */
    get asV1(): null {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingVestOtherCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.vest_other')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unlock any vested funds of a `target` account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `target`: The account whose vested funds should be unlocked. Must have funds still
     *  locked under this pallet.
     * 
     *  Emits either `VestingCompleted` or `VestingUpdated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 3 Reads, 3 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account
     *      - Writes: Vesting Storage, Balances Locks, Target Account
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Vesting.vest_other') === 'b473bcbba83335e310f2f681307dcf6b16b8d79ec99a4fb2202c34bed7de3b65'
    }

    /**
     *  Unlock any vested funds of a `target` account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `target`: The account whose vested funds should be unlocked. Must have funds still
     *  locked under this pallet.
     * 
     *  Emits either `VestingCompleted` or `VestingUpdated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 3 Reads, 3 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account
     *      - Writes: Vesting Storage, Balances Locks, Target Account
     *  # </weight>
     */
    get asV1(): {target: v1.LookupSource} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingVestedTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.vested_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Create a vested transfer.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `target`: The account that should be transferred the vested funds.
     *  - `amount`: The amount of funds to transfer and will be vested.
     *  - `schedule`: The vesting schedule attached to the transfer.
     * 
     *  Emits `VestingCreated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 3 Reads, 3 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]
     *      - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]
     *  # </weight>
     */
    get isV1(): boolean {
        return this._chain.getCallHash('Vesting.vested_transfer') === '0f6872962312eb70cc69daaab6af7934f93006a324730cd95bfebe233c99e338'
    }

    /**
     *  Create a vested transfer.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `target`: The account that should be transferred the vested funds.
     *  - `amount`: The amount of funds to transfer and will be vested.
     *  - `schedule`: The vesting schedule attached to the transfer.
     * 
     *  Emits `VestingCreated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 3 Reads, 3 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]
     *      - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]
     *  # </weight>
     */
    get asV1(): {target: v1.LookupSource, schedule: v1.VestingInfo} {
        assert(this.isV1)
        return this._chain.decodeCall(this.call)
    }
}

export class VstokenConversionSetExchangeFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VstokenConversion.set_exchange_fee')
        this._chain = ctx._chain
        this.call = call
    }

    get isV932(): boolean {
        return this._chain.getCallHash('VstokenConversion.set_exchange_fee') === '04d91f4d740370a1ac4c2d5ac0649735065aad4594e00e2e0b7635817abe7cdf'
    }

    get asV932(): {exchangeFee: v932.VstokenConversionExchangeFee} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    get isV952(): boolean {
        return this._chain.getCallHash('VstokenConversion.set_exchange_fee') === '90a895d1b4cc09242306d46872658bef3d1f06f79fd569ca179e8e24f442a817'
    }

    get asV952(): {exchangeFee: v952.VstokenConversionExchangeFee} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }
}

export class VstokenConversionSetExchangeRateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VstokenConversion.set_exchange_rate')
        this._chain = ctx._chain
        this.call = call
    }

    get isV932(): boolean {
        return this._chain.getCallHash('VstokenConversion.set_exchange_rate') === '254877af18edb10783f111576bf806649db70d9aebd11a4aeff2fcc92c0d13d0'
    }

    get asV932(): {lease: number, exchangeRate: v932.VstokenConversionExchangeRate} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    get isV952(): boolean {
        return this._chain.getCallHash('VstokenConversion.set_exchange_rate') === 'd51f18ed5cc67ee9acfc046f430b0021f9f3a2b1d379723322cf73fdf3171d8e'
    }

    get asV952(): {lease: number, exchangeRate: v952.VstokenConversionExchangeRate} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }
}

export class VstokenConversionSetKusamaLeaseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VstokenConversion.set_kusama_lease')
        this._chain = ctx._chain
        this.call = call
    }

    get isV932(): boolean {
        return this._chain.getCallHash('VstokenConversion.set_kusama_lease') === '4e8f0ba804f3c81318a22c5a753df058873bef641bcde1b9159f19b73d019457'
    }

    get asV932(): {lease: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class VstokenConversionSetPolkadotLeaseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VstokenConversion.set_polkadot_lease')
        this._chain = ctx._chain
        this.call = call
    }

    get isV932(): boolean {
        return this._chain.getCallHash('VstokenConversion.set_polkadot_lease') === '4e8f0ba804f3c81318a22c5a753df058873bef641bcde1b9159f19b73d019457'
    }

    get asV932(): {lease: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class VstokenConversionSetRelaychainLeaseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VstokenConversion.set_relaychain_lease')
        this._chain = ctx._chain
        this.call = call
    }

    get isV952(): boolean {
        return this._chain.getCallHash('VstokenConversion.set_relaychain_lease') === '4e8f0ba804f3c81318a22c5a753df058873bef641bcde1b9159f19b73d019457'
    }

    get asV952(): {lease: number} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }
}

export class VstokenConversionVsbondConvertToVsdotCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VstokenConversion.vsbond_convert_to_vsdot')
        this._chain = ctx._chain
        this.call = call
    }

    get isV932(): boolean {
        return this._chain.getCallHash('VstokenConversion.vsbond_convert_to_vsdot') === 'e94caf3925df54fc6d203f02b9475c670aa3d429005a0358d75492720e7c1701'
    }

    get asV932(): {currencyId: v932.CurrencyId, vsbondAmount: bigint, minimumVsdot: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class VstokenConversionVsbondConvertToVsksmCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VstokenConversion.vsbond_convert_to_vsksm')
        this._chain = ctx._chain
        this.call = call
    }

    get isV932(): boolean {
        return this._chain.getCallHash('VstokenConversion.vsbond_convert_to_vsksm') === '78025a4f568764e064633fa7ece2c8ac62e2b9fb8a7183f76fd9d492f7a2b31a'
    }

    get asV932(): {currencyId: v932.CurrencyId, vsbondAmount: bigint, minimumVsksm: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class VstokenConversionVsbondConvertToVstokenCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VstokenConversion.vsbond_convert_to_vstoken')
        this._chain = ctx._chain
        this.call = call
    }

    get isV952(): boolean {
        return this._chain.getCallHash('VstokenConversion.vsbond_convert_to_vstoken') === '0480e14f137a32a82f778618b6677a3c62b319ed42019402d5f7e4d4c97b18e1'
    }

    get asV952(): {currencyId: v952.CurrencyId, vsbondAmount: bigint, minimumVstoken: bigint} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VstokenConversion.vsbond_convert_to_vstoken') === 'c24a0825d98430a798d00f96d8d7eacd4ddb46a077e855a417e836a26a4ec619'
    }

    get asV956(): {vsBondCurrencyId: v956.CurrencyId, vsbondAmount: bigint, minimumVstoken: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VstokenConversion.vsbond_convert_to_vstoken') === 'cf9309c137a6c733ff6fede8d1fe5aeb05835d4ab44a9fe001fef3997a60e231'
    }

    get asV962(): {vsBondCurrencyId: v962.CurrencyId, vsbondAmount: bigint, minimumVstoken: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class VstokenConversionVsdotConvertToVsbondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VstokenConversion.vsdot_convert_to_vsbond')
        this._chain = ctx._chain
        this.call = call
    }

    get isV932(): boolean {
        return this._chain.getCallHash('VstokenConversion.vsdot_convert_to_vsbond') === '9676af9e1b62d635251faa22208b071b5e974f69e59b6ea5e0c541f596dcedd6'
    }

    get asV932(): {currencyId: v932.CurrencyId, vsdotAmount: bigint, minimumVsbond: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class VstokenConversionVsksmConvertToVsbondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VstokenConversion.vsksm_convert_to_vsbond')
        this._chain = ctx._chain
        this.call = call
    }

    get isV932(): boolean {
        return this._chain.getCallHash('VstokenConversion.vsksm_convert_to_vsbond') === 'c29a24e35ac623e2f21542fe05dd4a54aa324f4bf00a4d854074f30c8aab59aa'
    }

    get asV932(): {currencyId: v932.CurrencyId, vsksmAmount: bigint, minimumVsbond: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class VstokenConversionVstokenConvertToVsbondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VstokenConversion.vstoken_convert_to_vsbond')
        this._chain = ctx._chain
        this.call = call
    }

    get isV952(): boolean {
        return this._chain.getCallHash('VstokenConversion.vstoken_convert_to_vsbond') === '1e2b755a3a3c9eeec0a6f8e96221ba32c2d748ffe1d98addc891bd73a8979c5e'
    }

    get asV952(): {currencyId: v952.CurrencyId, vstokenAmount: bigint, minimumVsbond: bigint} {
        assert(this.isV952)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VstokenConversion.vstoken_convert_to_vsbond') === 'c5d84185ba7f55a6c2bf0ff76a25ee0b840d556296349f46c4ae5144de5de12a'
    }

    get asV956(): {currencyId: v956.CurrencyId, vstokenAmount: bigint, minimumVsbond: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VstokenConversion.vstoken_convert_to_vsbond') === 'ea82d08b1eebf79d18455ff30380adf594d5d91e72ad9094530c4d4e20f5c53c'
    }

    get asV962(): {currencyId: v962.CurrencyId, vstokenAmount: bigint, minimumVsbond: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingAddSupportRebondTokenCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.add_support_rebond_token')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('VtokenMinting.add_support_rebond_token') === 'e30616e214f0af41f430fafcb2da3f8c467c25d035265a237ba5004d93829747'
    }

    get asV940(): {tokenId: v940.CurrencyId} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VtokenMinting.add_support_rebond_token') === '8e2066b157b09c675b64c0ff9edaa814874e00589cda201820c9d716c86b7445'
    }

    get asV956(): {tokenId: v956.CurrencyId} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VtokenMinting.add_support_rebond_token') === 'b143aeea360c303aca8f86f15bf8b2d7055d3981fc78ca86b822e5dfb41ddc3f'
    }

    get asV962(): {tokenId: v962.CurrencyId} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingMintCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.mint')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('VtokenMinting.mint') === '1e26bcd9293bbcf48124efcce6c97b63f8dba77b7b4034ce7e30c5830e213543'
    }

    get asV940(): {tokenId: v940.CurrencyId, tokenAmount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VtokenMinting.mint') === 'cc7c26a0e353f4bfbba97a6eb7c29c87b3198b10ec7755813a98fcff3e43532c'
    }

    get asV956(): {tokenId: v956.CurrencyId, tokenAmount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VtokenMinting.mint') === '2bcc72d0fb36af0ea2a4006c825a96e7e605e32fb265569634eef03c6377d515'
    }

    get asV962(): {tokenId: v962.CurrencyId, tokenAmount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingRebondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.rebond')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('VtokenMinting.rebond') === '1e26bcd9293bbcf48124efcce6c97b63f8dba77b7b4034ce7e30c5830e213543'
    }

    get asV940(): {tokenId: v940.CurrencyId, tokenAmount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VtokenMinting.rebond') === 'cc7c26a0e353f4bfbba97a6eb7c29c87b3198b10ec7755813a98fcff3e43532c'
    }

    get asV956(): {tokenId: v956.CurrencyId, tokenAmount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VtokenMinting.rebond') === '2bcc72d0fb36af0ea2a4006c825a96e7e605e32fb265569634eef03c6377d515'
    }

    get asV962(): {tokenId: v962.CurrencyId, tokenAmount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingRebondByUnlockIdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.rebond_by_unlock_id')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('VtokenMinting.rebond_by_unlock_id') === '191ce78895126a6333dd6ef980fca64af846bd17d325cb3ee140f1f6a87f72ab'
    }

    get asV940(): {tokenId: v940.CurrencyId, unlockId: number} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VtokenMinting.rebond_by_unlock_id') === 'e0b05933c4afed20be94303ccf2bff8717eaac11dbd2f01cd57d5ca55c0ee0dd'
    }

    get asV956(): {tokenId: v956.CurrencyId, unlockId: number} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VtokenMinting.rebond_by_unlock_id') === '026b3fd9cc2ecac9afcae0c7976ef4aa5edd63942ca712dc50f608945ca3695d'
    }

    get asV962(): {tokenId: v962.CurrencyId, unlockId: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingRedeemCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.redeem')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('VtokenMinting.redeem') === '7d295a2ac31ba924ce1658b0f9061af23932f19263df3f13c421093bb8b524fe'
    }

    get asV940(): {vtokenId: v940.CurrencyId, vtokenAmount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VtokenMinting.redeem') === '6d0044d373bda38ab2b911f70244cc3d911ac9807b0b5f96a046a610df079f09'
    }

    get asV956(): {vtokenId: v956.CurrencyId, vtokenAmount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VtokenMinting.redeem') === '2917b40e741b533fc6e73cda3eabc8a7d5fd8917be65d0479c4d3239865a22cc'
    }

    get asV962(): {vtokenId: v962.CurrencyId, vtokenAmount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingRemoveSupportRebondTokenCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.remove_support_rebond_token')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('VtokenMinting.remove_support_rebond_token') === 'e30616e214f0af41f430fafcb2da3f8c467c25d035265a237ba5004d93829747'
    }

    get asV940(): {tokenId: v940.CurrencyId} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VtokenMinting.remove_support_rebond_token') === '8e2066b157b09c675b64c0ff9edaa814874e00589cda201820c9d716c86b7445'
    }

    get asV956(): {tokenId: v956.CurrencyId} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VtokenMinting.remove_support_rebond_token') === 'b143aeea360c303aca8f86f15bf8b2d7055d3981fc78ca86b822e5dfb41ddc3f'
    }

    get asV962(): {tokenId: v962.CurrencyId} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingSetFeesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.set_fees')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_fees') === '1c4943227c141adafdcc24737eb875081560e05ae719280ada1a3747ca44627a'
    }

    get asV940(): {mintFee: number, redeemFee: number} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingSetHookIterationLimitCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.set_hook_iteration_limit')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_hook_iteration_limit') === 'f707ff742083978d0b1f391a9771c28219f5e35ce5ba83507482cd04e92d916b'
    }

    get asV940(): {limit: number} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingSetMinTimeUnitCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.set_min_time_unit')
        this._chain = ctx._chain
        this.call = call
    }

    get isV946(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_min_time_unit') === 'fa268c3e4e9a68376abd2d3d9e9b16a48b463f5e0efd48f34136c0c92140a3af'
    }

    get asV946(): {tokenId: v946.CurrencyId, timeUnit: v946.TimeUnit} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_min_time_unit') === '246ea7d9afd8e102eeffd6e6e975322ee37ed650488883d3dcf323c0bf2f5712'
    }

    get asV956(): {tokenId: v956.CurrencyId, timeUnit: v956.TimeUnit} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_min_time_unit') === '31c095df6d266314bdb6508ca8baf1bb115312da6d3d49b809f1cc9d4f311be2'
    }

    get asV962(): {tokenId: v962.CurrencyId, timeUnit: v962.TimeUnit} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_min_time_unit') === 'b185bf65588671e0cf9478ec7df3ce091612b69014fefa7c25d4181cf5ec60e5'
    }

    get asV970(): {tokenId: v970.CurrencyId, timeUnit: v970.TimeUnit} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingSetMinimumMintCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.set_minimum_mint')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_minimum_mint') === 'ac4ae6398066773e53de1d86a54412149f8d3346ea110cc25164422cc8c1e088'
    }

    get asV940(): {tokenId: v940.CurrencyId, amount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_minimum_mint') === '7fca77be3118fb1b790a0d1cab809f3d86e679910d35e6f7ea794354fd782b01'
    }

    get asV956(): {tokenId: v956.CurrencyId, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_minimum_mint') === '3cd93ebf2d816433b9396a5c30e22e535d7163e0a6c22b8dad3f6e75d7d70cac'
    }

    get asV962(): {tokenId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingSetMinimumRedeemCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.set_minimum_redeem')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_minimum_redeem') === 'ac4ae6398066773e53de1d86a54412149f8d3346ea110cc25164422cc8c1e088'
    }

    get asV940(): {tokenId: v940.CurrencyId, amount: bigint} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_minimum_redeem') === '7fca77be3118fb1b790a0d1cab809f3d86e679910d35e6f7ea794354fd782b01'
    }

    get asV956(): {tokenId: v956.CurrencyId, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_minimum_redeem') === '3cd93ebf2d816433b9396a5c30e22e535d7163e0a6c22b8dad3f6e75d7d70cac'
    }

    get asV962(): {tokenId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingSetUnlockDurationCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.set_unlock_duration')
        this._chain = ctx._chain
        this.call = call
    }

    get isV940(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_unlock_duration') === 'f7b0821ac265cebb7d67bb9250398fd789e1aa6de47f7f34d4e1895e2fb71401'
    }

    get asV940(): {tokenId: v940.CurrencyId, unlockDuration: v940.TimeUnit} {
        assert(this.isV940)
        return this._chain.decodeCall(this.call)
    }

    get isV946(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_unlock_duration') === 'bad63f73aef48ed943193663c56f478758917d7eb7c61fbf567e20934c7d6c5c'
    }

    get asV946(): {tokenId: v946.CurrencyId, unlockDuration: v946.TimeUnit} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_unlock_duration') === '87b67946b96c7a03e69ce136908c846a7269c21899e77008b2c11f62b6425933'
    }

    get asV956(): {tokenId: v956.CurrencyId, unlockDuration: v956.TimeUnit} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_unlock_duration') === '8456c93308b0a177273a1bc760e853a43ff01c8e0606368fbe0b139c0d79b9e8'
    }

    get asV962(): {tokenId: v962.CurrencyId, unlockDuration: v962.TimeUnit} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    get isV970(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_unlock_duration') === '593fd2ef411bbcfcce362b064ffffdf2e7cb33f4de79ddbf91a49acbaa9674df'
    }

    get asV970(): {tokenId: v970.CurrencyId, unlockDuration: v970.TimeUnit} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }
}

export class VtokenMintingSetUnlockingTotalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VtokenMinting.set_unlocking_total')
        this._chain = ctx._chain
        this.call = call
    }

    get isV946(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_unlocking_total') === 'ac4ae6398066773e53de1d86a54412149f8d3346ea110cc25164422cc8c1e088'
    }

    get asV946(): {tokenId: v946.CurrencyId, amount: bigint} {
        assert(this.isV946)
        return this._chain.decodeCall(this.call)
    }

    get isV956(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_unlocking_total') === '7fca77be3118fb1b790a0d1cab809f3d86e679910d35e6f7ea794354fd782b01'
    }

    get asV956(): {tokenId: v956.CurrencyId, amount: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    get isV962(): boolean {
        return this._chain.getCallHash('VtokenMinting.set_unlocking_total') === '3cd93ebf2d816433b9396a5c30e22e535d7163e0a6c22b8dad3f6e75d7d70cac'
    }

    get asV962(): {tokenId: v962.CurrencyId, amount: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class XTokensTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XTokens.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer native currencies.
     * 
     *  `dest_weight` is the weight for XCM execution on the dest chain, and
     *  it would be charged from the transferred assets. If set below
     *  requirements, the execution may fail and assets wouldn't be
     *  received.
     * 
     *  It's a no-op if any error on local XCM execution or message sending.
     *  Note sending assets out per se doesn't guarantee they would be
     *  received. Receiving depends on if the XCM message could be delivered
     *  by the network, and if the receiving chain would handle
     *  messages correctly.
     */
    get isV804(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === '6a81c861252fe6c630f9fcf0ef4cbd8ab222a315cb9a001a6ca99c4234b1b343'
    }

    /**
     *  Transfer native currencies.
     * 
     *  `dest_weight` is the weight for XCM execution on the dest chain, and
     *  it would be charged from the transferred assets. If set below
     *  requirements, the execution may fail and assets wouldn't be
     *  received.
     * 
     *  It's a no-op if any error on local XCM execution or message sending.
     *  Note sending assets out per se doesn't guarantee they would be
     *  received. Receiving depends on if the XCM message could be delivered
     *  by the network, and if the receiving chain would handle
     *  messages correctly.
     */
    get asV804(): {currencyId: v804.CurrencyId, amount: bigint, dest: v804.MultiLocation, destWeight: bigint} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Transfer native currencies.
     * 
     *  `dest_weight` is the weight for XCM execution on the dest chain, and
     *  it would be charged from the transferred assets. If set below
     *  requirements, the execution may fail and assets wouldn't be
     *  received.
     * 
     *  It's a no-op if any error on local XCM execution or message sending.
     *  Note sending assets out per se doesn't guarantee they would be
     *  received. Receiving depends on if the XCM message could be delivered
     *  by the network, and if the receiving chain would handle
     *  messages correctly.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === '3be63b77b0fe8e3cf62f514e6a009dada839c41ead9126f7144a62b230ea1deb'
    }

    /**
     *  Transfer native currencies.
     * 
     *  `dest_weight` is the weight for XCM execution on the dest chain, and
     *  it would be charged from the transferred assets. If set below
     *  requirements, the execution may fail and assets wouldn't be
     *  received.
     * 
     *  It's a no-op if any error on local XCM execution or message sending.
     *  Note sending assets out per se doesn't guarantee they would be
     *  received. Receiving depends on if the XCM message could be delivered
     *  by the network, and if the receiving chain would handle
     *  messages correctly.
     */
    get asV902(): {currencyId: v902.CurrencyId, amount: bigint, dest: v902.MultiLocation, destWeight: bigint} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === '65eaebb4468793b790001088b988d26fda4fa3337888d1379c10c937f647a7fd'
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV906(): {currencyId: v906.CurrencyId, amount: bigint, dest: v906.V1MultiLocation, destWeight: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === '1a8eebf044567f59201a99f1247f5e39c73a040cedf0408c18eb3de2cf78d097'
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV908(): {currencyId: v908.CurrencyId, amount: bigint, dest: v908.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === '51e2ce245e21c898fc78755b6e4e03e5256a69e39d87ddeadcbb4665e1003b09'
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV916(): {currencyId: v916.CurrencyId, amount: bigint, dest: v916.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === '09e6e564825668fdd3ec4a34b7aa77ea40dbe14beeef128523c1ad2872b9dfeb'
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV920(): {currencyId: v920.CurrencyId, amount: bigint, dest: v920.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === '8378d4d5ab6ba0b65b9bc78ee5d6b2b0b1cb25f80df0be19e343e75644c8bcd4'
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV932(): {currencyId: v932.CurrencyId, amount: bigint, dest: v932.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === '76c1287112d5bb7cd6913f958eb7aa4fb1d2b762d6ef7e71895c9f0eb2ce7445'
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV956(): {currencyId: v956.CurrencyId, amount: bigint, dest: v956.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === '0efbd753ffb429ae28dfdc217216cc01d1289b0c629cd815a33c8d4e415a9b2f'
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV962(): {currencyId: v962.CurrencyId, amount: bigint, dest: v962.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === '9b7bf39503a8083be642ba6f3226f99fb9145b8b508bb7639194491de45a8168'
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV968(): {currencyId: v968.CurrencyId, amount: bigint, dest: v968.VersionedMultiLocation, destWeightLimit: v968.V2WeightLimit} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === 'dab97fbd30b6086e10af09fdd3ab74777db6c6bad7b2540f96643c460570ee2a'
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV970(): {currencyId: v970.CurrencyId, amount: bigint, dest: v970.VersionedMultiLocation, destWeightLimit: v970.V2WeightLimit} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('XTokens.transfer') === 'ab0447c8c7de2d846e859b244dd57de1efab50a2364a0a45cbf75f0d423327d4'
    }

    /**
     * Transfer native currencies.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV972(): {currencyId: v972.CurrencyId, amount: bigint, dest: v972.VersionedMultiLocation, destWeightLimit: v972.V3WeightLimit} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class XTokensTransferMultiassetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XTokens.transfer_multiasset')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer `MultiAsset`.
     * 
     *  `dest_weight` is the weight for XCM execution on the dest chain, and
     *  it would be charged from the transferred assets. If set below
     *  requirements, the execution may fail and assets wouldn't be
     *  received.
     * 
     *  It's a no-op if any error on local XCM execution or message sending.
     *  Note sending assets out per se doesn't guarantee they would be
     *  received. Receiving depends on if the XCM message could be delivered
     *  by the network, and if the receiving chain would handle
     *  messages correctly.
     */
    get isV804(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset') === '78b3c3cd35b70eb74b8a5893e3cc8f1a23352252ed6f60968c3d0474ec75c5c5'
    }

    /**
     *  Transfer `MultiAsset`.
     * 
     *  `dest_weight` is the weight for XCM execution on the dest chain, and
     *  it would be charged from the transferred assets. If set below
     *  requirements, the execution may fail and assets wouldn't be
     *  received.
     * 
     *  It's a no-op if any error on local XCM execution or message sending.
     *  Note sending assets out per se doesn't guarantee they would be
     *  received. Receiving depends on if the XCM message could be delivered
     *  by the network, and if the receiving chain would handle
     *  messages correctly.
     */
    get asV804(): {asset: v804.MultiAsset, dest: v804.MultiLocation, destWeight: bigint} {
        assert(this.isV804)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Transfer `MultiAsset`.
     * 
     *  `dest_weight` is the weight for XCM execution on the dest chain, and
     *  it would be charged from the transferred assets. If set below
     *  requirements, the execution may fail and assets wouldn't be
     *  received.
     * 
     *  It's a no-op if any error on local XCM execution or message sending.
     *  Note sending assets out per se doesn't guarantee they would be
     *  received. Receiving depends on if the XCM message could be delivered
     *  by the network, and if the receiving chain would handle
     *  messages correctly.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset') === 'd8b5dbc020e39778907693b30d81067b176708e4e1425593aee7cbd4b346fd3a'
    }

    /**
     *  Transfer `MultiAsset`.
     * 
     *  `dest_weight` is the weight for XCM execution on the dest chain, and
     *  it would be charged from the transferred assets. If set below
     *  requirements, the execution may fail and assets wouldn't be
     *  received.
     * 
     *  It's a no-op if any error on local XCM execution or message sending.
     *  Note sending assets out per se doesn't guarantee they would be
     *  received. Receiving depends on if the XCM message could be delivered
     *  by the network, and if the receiving chain would handle
     *  messages correctly.
     */
    get asV902(): {asset: v902.MultiAsset, dest: v902.MultiLocation, destWeight: bigint} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer `MultiAsset`.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset') === '1035df8ed60a0998857c0d660023a59230ddcdc0e076a262c3b2dcf349b920fb'
    }

    /**
     * Transfer `MultiAsset`.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV906(): {asset: v906.V1MultiAsset, dest: v906.V1MultiLocation, destWeight: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer `MultiAsset`.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV908(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset') === 'f33cd4d2466c1e767a4c2d9b00f7b71b359b07f3e78d76d466e3928a3e2ed9b8'
    }

    /**
     * Transfer `MultiAsset`.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV908(): {asset: v908.VersionedMultiAsset, dest: v908.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV908)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer `MultiAsset`.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset') === '124b77e480550e2d7eac49ed107d76163c8e7e2864b828c843c249ef6ae8515f'
    }

    /**
     * Transfer `MultiAsset`.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV968(): {asset: v968.VersionedMultiAsset, dest: v968.VersionedMultiLocation, destWeightLimit: v968.V2WeightLimit} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer `MultiAsset`.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset') === '70d2e3f081439562ff48bfbc83e3505c6b5f0c13d2c5e05113fe23b1a66789c6'
    }

    /**
     * Transfer `MultiAsset`.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV970(): {asset: v970.VersionedMultiAsset, dest: v970.VersionedMultiLocation, destWeightLimit: v970.V2WeightLimit} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer `MultiAsset`.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset') === 'a87b2931a2da31f4548173df0d164afbd7f9413f0b0a9373582011906fdc8ac9'
    }

    /**
     * Transfer `MultiAsset`.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV972(): {asset: v972.VersionedMultiAsset, dest: v972.VersionedMultiLocation, destWeightLimit: v972.V3WeightLimit} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class XTokensTransferMultiassetWithFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XTokens.transfer_multiasset_with_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer `MultiAsset` specifying the fee and amount as separate.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the multiasset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `MultiLocation` id.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset_with_fee') === '72aca3119f971190d4dd5493791879ff41295c5e290079c6179cb41be01e6226'
    }

    /**
     * Transfer `MultiAsset` specifying the fee and amount as separate.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the multiasset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `MultiLocation` id.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV916(): {asset: v916.VersionedMultiAsset, fee: v916.VersionedMultiAsset, dest: v916.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer `MultiAsset` specifying the fee and amount as separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the multiasset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `MultiLocation` id.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset_with_fee') === 'afea57197ed47389f761cf32ea9293aa35a8fb52ae656fb5a27162139197c988'
    }

    /**
     * Transfer `MultiAsset` specifying the fee and amount as separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the multiasset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `MultiLocation` id.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV968(): {asset: v968.VersionedMultiAsset, fee: v968.VersionedMultiAsset, dest: v968.VersionedMultiLocation, destWeightLimit: v968.V2WeightLimit} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer `MultiAsset` specifying the fee and amount as separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the multiasset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `MultiLocation` id.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset_with_fee') === 'defcec42d1b02bac0b413147c092a01a8147ec8f547c09c192c96745b785e9a9'
    }

    /**
     * Transfer `MultiAsset` specifying the fee and amount as separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the multiasset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `MultiLocation` id.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV970(): {asset: v970.VersionedMultiAsset, fee: v970.VersionedMultiAsset, dest: v970.VersionedMultiLocation, destWeightLimit: v970.V2WeightLimit} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer `MultiAsset` specifying the fee and amount as separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the multiasset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `MultiLocation` id.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiasset_with_fee') === 'e1673c048436ca84c1278f4f2f8a12456b25e4911f3ec72d0295b843ed7a4c7f'
    }

    /**
     * Transfer `MultiAsset` specifying the fee and amount as separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the multiasset to be spent to pay for execution in
     * destination chain. Both fee and amount will be subtracted form the
     * callers balance For now we only accept fee and asset having the same
     * `MultiLocation` id.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV972(): {asset: v972.VersionedMultiAsset, fee: v972.VersionedMultiAsset, dest: v972.VersionedMultiLocation, destWeightLimit: v972.V3WeightLimit} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class XTokensTransferMultiassetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XTokens.transfer_multiassets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer several `MultiAsset` specifying the item to be used as fee
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the MultiAssets that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiassets') === '2c9276a8e5652bef69d8e7f6f9bf7caccd48bb5ef0b25b42010d09b4b28b18c5'
    }

    /**
     * Transfer several `MultiAsset` specifying the item to be used as fee
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the MultiAssets that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV926(): {assets: v926.VersionedMultiAssets, feeItem: number, dest: v926.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer several `MultiAsset` specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the MultiAssets that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiassets') === '3c0b0dac1e68352c618c2cea8b190730d35ccc04742093f63dff05648d32475d'
    }

    /**
     * Transfer several `MultiAsset` specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the MultiAssets that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV968(): {assets: v968.VersionedMultiAssets, feeItem: number, dest: v968.VersionedMultiLocation, destWeightLimit: v968.V2WeightLimit} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer several `MultiAsset` specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the MultiAssets that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiassets') === '4346762733fcad772927ca96754d7c2a2ca0f9996809371e524c4b6e252f7cc6'
    }

    /**
     * Transfer several `MultiAsset` specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the MultiAssets that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV970(): {assets: v970.VersionedMultiAssets, feeItem: number, dest: v970.VersionedMultiLocation, destWeightLimit: v970.V2WeightLimit} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer several `MultiAsset` specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the MultiAssets that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multiassets') === 'b49a1a3bce05ffe02f0ac5efca4907e6bf7f963113419870a760a3013dc86495'
    }

    /**
     * Transfer several `MultiAsset` specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the MultiAssets that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV972(): {assets: v972.VersionedMultiAssets, feeItem: number, dest: v972.VersionedMultiLocation, destWeightLimit: v972.V3WeightLimit} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class XTokensTransferMulticurrenciesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XTokens.transfer_multicurrencies')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multicurrencies') === 'ea08b39fdf9d2118ba9a67e3404bac8428601520d53b82c405339b342fedfdca'
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV926(): {currencies: [v926.CurrencyId, bigint][], feeItem: number, dest: v926.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multicurrencies') === 'c4eef5629d74135b67beb5ab91d4631a33271617b7a8055e9fccf9dc994035a4'
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV932(): {currencies: [v932.CurrencyId, bigint][], feeItem: number, dest: v932.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multicurrencies') === 'f86ee8c157a768e0538f0b732d870faa6462150bfc156cd5e8484aee4e843370'
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV956(): {currencies: [v956.CurrencyId, bigint][], feeItem: number, dest: v956.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multicurrencies') === 'e8bcdf93def0a3c4504831d4ff8c3115966f927a64935c605f0f760cd1c46e8b'
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV962(): {currencies: [v962.CurrencyId, bigint][], feeItem: number, dest: v962.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multicurrencies') === 'e909804296a5bb15fc5ce19b6c53bbff057b1017636c4658c6b7669c5ee8a1f6'
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV968(): {currencies: [v968.CurrencyId, bigint][], feeItem: number, dest: v968.VersionedMultiLocation, destWeightLimit: v968.V2WeightLimit} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multicurrencies') === '1eae63c1e88a25ac6ea0348822049447ee1ade9acc50430efbafbb0bd4455357'
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV970(): {currencies: [v970.CurrencyId, bigint][], feeItem: number, dest: v970.VersionedMultiLocation, destWeightLimit: v970.V2WeightLimit} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('XTokens.transfer_multicurrencies') === '95be4bd800ba1555d5e5b1a3b2262ef93f3100e29bc7aee596cf38c93f361803'
    }

    /**
     * Transfer several currencies specifying the item to be used as fee
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee_item` is index of the currencies tuple that we want to use for
     * payment
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV972(): {currencies: [v972.CurrencyId, bigint][], feeItem: number, dest: v972.VersionedMultiLocation, destWeightLimit: v972.V3WeightLimit} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class XTokensTransferWithFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XTokens.transfer_with_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV916(): boolean {
        return this._chain.getCallHash('XTokens.transfer_with_fee') === '18f48f87c0f3b3b38996b11bdcda7f6e218ff9f34a78f83a64db627062643cbc'
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV916(): {currencyId: v916.CurrencyId, amount: bigint, fee: bigint, dest: v916.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV916)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV920(): boolean {
        return this._chain.getCallHash('XTokens.transfer_with_fee') === '45c900a20771c080dca04287f52d1d4ea398d7b316f9a342e0bfbe7441fd705d'
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV920(): {currencyId: v920.CurrencyId, amount: bigint, fee: bigint, dest: v920.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV920)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('XTokens.transfer_with_fee') === '4834de5c9f9152d284c87a1046c70e746bdb4807b9baf04320b6ca63d2d14d1a'
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV932(): {currencyId: v932.CurrencyId, amount: bigint, fee: bigint, dest: v932.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV956(): boolean {
        return this._chain.getCallHash('XTokens.transfer_with_fee') === 'c6cc656310bbcb7e62d821e7537a0d2c8d3b1a133f49a9c2694eab41d68efd86'
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV956(): {currencyId: v956.CurrencyId, amount: bigint, fee: bigint, dest: v956.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV956)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('XTokens.transfer_with_fee') === '20d96474d1f7e48bbcb783dd3a12027e272f74babdd56092cb74b77cc6d2aef4'
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight` is the weight for XCM execution on the dest chain, and
     * it would be charged from the transferred assets. If set below
     * requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV962(): {currencyId: v962.CurrencyId, amount: bigint, fee: bigint, dest: v962.VersionedMultiLocation, destWeight: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV968(): boolean {
        return this._chain.getCallHash('XTokens.transfer_with_fee') === '34ab49ebab2f16994f9a99a6151281c451a6db75e070f75f19bb894e976951e1'
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV968(): {currencyId: v968.CurrencyId, amount: bigint, fee: bigint, dest: v968.VersionedMultiLocation, destWeightLimit: v968.V2WeightLimit} {
        assert(this.isV968)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV970(): boolean {
        return this._chain.getCallHash('XTokens.transfer_with_fee') === 'ca6c82023fb5e57ac251ff21cd8ddbb977b3e8dee0faf0cbbc967e988df7b15c'
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV970(): {currencyId: v970.CurrencyId, amount: bigint, fee: bigint, dest: v970.VersionedMultiLocation, destWeightLimit: v970.V2WeightLimit} {
        assert(this.isV970)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('XTokens.transfer_with_fee') === '24caba08900be72a7c57a5dacae6c9aa3fcc78c81779302b871dd695a3156519'
    }

    /**
     * Transfer native currencies specifying the fee and amount as
     * separate.
     * 
     * `dest_weight_limit` is the weight for XCM execution on the dest
     * chain, and it would be charged from the transferred assets. If set
     * below requirements, the execution may fail and assets wouldn't be
     * received.
     * 
     * `fee` is the amount to be spent to pay for execution in destination
     * chain. Both fee and amount will be subtracted form the callers
     * balance.
     * 
     * If `fee` is not high enough to cover for the execution costs in the
     * destination chain, then the assets will be trapped in the
     * destination chain
     * 
     * It's a no-op if any error on local XCM execution or message sending.
     * Note sending assets out per se doesn't guarantee they would be
     * received. Receiving depends on if the XCM message could be delivered
     * by the network, and if the receiving chain would handle
     * messages correctly.
     */
    get asV972(): {currencyId: v972.CurrencyId, amount: bigint, fee: bigint, dest: v972.VersionedMultiLocation, destWeightLimit: v972.V3WeightLimit} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmInterfaceTransferStatemineAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmInterface.transfer_statemine_assets')
        this._chain = ctx._chain
        this.call = call
    }

    get isV927(): boolean {
        return this._chain.getCallHash('XcmInterface.transfer_statemine_assets') === 'dee1b31b085b54da51e27f6f1a7333fc994698ed15608fba83f10caa139fd66b'
    }

    get asV927(): {amount: bigint, assetId: number, dest: (Uint8Array | undefined)} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmInterfaceUpdateXcmDestWeightAndFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmInterface.update_xcm_dest_weight_and_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the xcm_dest_weight and fee for XCM operation of XcmInterface.
     * 
     * Parameters:
     * - `updates`: vec of tuple: (XcmInterfaceOperation, WeightChange, FeeChange).
     */
    get isV927(): boolean {
        return this._chain.getCallHash('XcmInterface.update_xcm_dest_weight_and_fee') === 'c15eebcc2f5d16c8f6309295a6d7862ded0811f5fc863e965cee7a551aa2b1ed'
    }

    /**
     * Sets the xcm_dest_weight and fee for XCM operation of XcmInterface.
     * 
     * Parameters:
     * - `updates`: vec of tuple: (XcmInterfaceOperation, WeightChange, FeeChange).
     */
    get asV927(): {updates: [v927.XcmInterfaceOperation, (bigint | undefined), (bigint | undefined)][]} {
        assert(this.isV927)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Sets the xcm_dest_weight and fee for XCM operation of XcmInterface.
     * 
     * Parameters:
     * - `updates`: vec of tuple: (XcmInterfaceOperation, WeightChange, FeeChange).
     */
    get isV972(): boolean {
        return this._chain.getCallHash('XcmInterface.update_xcm_dest_weight_and_fee') === 'a2aa0952e569dbddbfb94cecd9c9f0b380cbb2aadddfcd505cee3dfe55e0b6d5'
    }

    /**
     * Sets the xcm_dest_weight and fee for XCM operation of XcmInterface.
     * 
     * Parameters:
     * - `updates`: vec of tuple: (XcmInterfaceOperation, WeightChange, FeeChange).
     */
    get asV972(): {updates: [v972.XcmInterfaceOperation, (v972.Weight | undefined), (bigint | undefined)][]} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueResumeXcmExecutionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.resume_xcm_execution')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Resumes all XCM executions for the XCMP queue.
     * 
     * Note that this function doesn't change the status of the in/out bound channels.
     * 
     * - `origin`: Must pass `ControllerOrigin`.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('XcmpQueue.resume_xcm_execution') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Resumes all XCM executions for the XCMP queue.
     * 
     * Note that this function doesn't change the status of the in/out bound channels.
     * 
     * - `origin`: Must pass `ControllerOrigin`.
     */
    get asV932(): null {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueServiceOverweightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.service_overweight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Services a single overweight XCM.
     * 
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight XCM to service
     * - `weight_limit`: The amount of weight that XCM execution may take.
     * 
     * Errors:
     * - `BadOverweightIndex`: XCM under `index` is not found in the `Overweight` storage map.
     * - `BadXcm`: XCM under `index` cannot be properly decoded into a valid XCM format.
     * - `WeightOverLimit`: XCM execution may use greater `weight_limit`.
     * 
     * Events:
     * - `OverweightServiced`: On success.
     */
    get isV926(): boolean {
        return this._chain.getCallHash('XcmpQueue.service_overweight') === 'f6b281f58290b6af96ac2dda36163d81223f37d0a8a100877e2526969a57d772'
    }

    /**
     * Services a single overweight XCM.
     * 
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight XCM to service
     * - `weight_limit`: The amount of weight that XCM execution may take.
     * 
     * Errors:
     * - `BadOverweightIndex`: XCM under `index` is not found in the `Overweight` storage map.
     * - `BadXcm`: XCM under `index` cannot be properly decoded into a valid XCM format.
     * - `WeightOverLimit`: XCM execution may use greater `weight_limit`.
     * 
     * Events:
     * - `OverweightServiced`: On success.
     */
    get asV926(): {index: bigint, weightLimit: bigint} {
        assert(this.isV926)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Services a single overweight XCM.
     * 
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight XCM to service
     * - `weight_limit`: The amount of weight that XCM execution may take.
     * 
     * Errors:
     * - `BadOverweightIndex`: XCM under `index` is not found in the `Overweight` storage map.
     * - `BadXcm`: XCM under `index` cannot be properly decoded into a valid XCM format.
     * - `WeightOverLimit`: XCM execution may use greater `weight_limit`.
     * 
     * Events:
     * - `OverweightServiced`: On success.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('XcmpQueue.service_overweight') === '80fae8875bf513efc1e06b7dac547fccfc1e5fc45888cc8afd9b43812cf51bf5'
    }

    /**
     * Services a single overweight XCM.
     * 
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight XCM to service
     * - `weight_limit`: The amount of weight that XCM execution may take.
     * 
     * Errors:
     * - `BadOverweightIndex`: XCM under `index` is not found in the `Overweight` storage map.
     * - `BadXcm`: XCM under `index` cannot be properly decoded into a valid XCM format.
     * - `WeightOverLimit`: XCM execution may use greater `weight_limit`.
     * 
     * Events:
     * - `OverweightServiced`: On success.
     */
    get asV972(): {index: bigint, weightLimit: v972.Weight} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueSuspendXcmExecutionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.suspend_xcm_execution')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Suspends all XCM executions for the XCMP queue, regardless of the sender's origin.
     * 
     * - `origin`: Must pass `ControllerOrigin`.
     */
    get isV932(): boolean {
        return this._chain.getCallHash('XcmpQueue.suspend_xcm_execution') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Suspends all XCM executions for the XCMP queue, regardless of the sender's origin.
     * 
     * - `origin`: Must pass `ControllerOrigin`.
     */
    get asV932(): null {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueUpdateDropThresholdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.update_drop_threshold')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Overwrites the number of pages of messages which must be in the queue after which we drop any further
     * messages from the channel.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.drop_threshold`
     */
    get isV932(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_drop_threshold') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Overwrites the number of pages of messages which must be in the queue after which we drop any further
     * messages from the channel.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.drop_threshold`
     */
    get asV932(): {new: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueUpdateResumeThresholdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.update_resume_threshold')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Overwrites the number of pages of messages which the queue must be reduced to before it signals that
     * message sending may recommence after it has been suspended.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.resume_threshold`                                
     */
    get isV932(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_resume_threshold') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Overwrites the number of pages of messages which the queue must be reduced to before it signals that
     * message sending may recommence after it has been suspended.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.resume_threshold`                                
     */
    get asV932(): {new: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueUpdateSuspendThresholdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.update_suspend_threshold')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Overwrites the number of pages of messages which must be in the queue for the other side to be told to
     * suspend their sending.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.suspend_value`
     */
    get isV932(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_suspend_threshold') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Overwrites the number of pages of messages which must be in the queue for the other side to be told to
     * suspend their sending.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.suspend_value`
     */
    get asV932(): {new: number} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueUpdateThresholdWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.update_threshold_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Overwrites the amount of remaining weight under which we stop processing messages.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.threshold_weight`                                
     */
    get isV932(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_threshold_weight') === '8768ae636c927ffed8b3cb5f0df1e15afb0921835e5bc84b9495f4b39ea663b7'
    }

    /**
     * Overwrites the amount of remaining weight under which we stop processing messages.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.threshold_weight`                                
     */
    get asV932(): {new: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Overwrites the amount of remaining weight under which we stop processing messages.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.threshold_weight`
     */
    get isV972(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_threshold_weight') === '75eef6f2cd3523e44f50db837d1610f4db03539037986ac2704c4a043d58ba81'
    }

    /**
     * Overwrites the amount of remaining weight under which we stop processing messages.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.threshold_weight`
     */
    get asV972(): {new: v972.Weight} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueUpdateWeightRestrictDecayCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.update_weight_restrict_decay')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Overwrites the speed to which the available weight approaches the maximum weight.
     * A lower number results in a faster progression. A value of 1 makes the entire weight available initially.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.weight_restrict_decay`.                                
     */
    get isV932(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_weight_restrict_decay') === '8768ae636c927ffed8b3cb5f0df1e15afb0921835e5bc84b9495f4b39ea663b7'
    }

    /**
     * Overwrites the speed to which the available weight approaches the maximum weight.
     * A lower number results in a faster progression. A value of 1 makes the entire weight available initially.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.weight_restrict_decay`.                                
     */
    get asV932(): {new: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Overwrites the speed to which the available weight approaches the maximum weight.
     * A lower number results in a faster progression. A value of 1 makes the entire weight available initially.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.weight_restrict_decay`.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_weight_restrict_decay') === '75eef6f2cd3523e44f50db837d1610f4db03539037986ac2704c4a043d58ba81'
    }

    /**
     * Overwrites the speed to which the available weight approaches the maximum weight.
     * A lower number results in a faster progression. A value of 1 makes the entire weight available initially.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.weight_restrict_decay`.
     */
    get asV972(): {new: v972.Weight} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmpQueueUpdateXcmpMaxIndividualWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmpQueue.update_xcmp_max_individual_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Overwrite the maximum amount of weight any individual message may consume.
     * Messages above this weight go into the overweight queue and may only be serviced explicitly.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.xcmp_max_individual_weight`.                                
     */
    get isV932(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_xcmp_max_individual_weight') === '8768ae636c927ffed8b3cb5f0df1e15afb0921835e5bc84b9495f4b39ea663b7'
    }

    /**
     * Overwrite the maximum amount of weight any individual message may consume.
     * Messages above this weight go into the overweight queue and may only be serviced explicitly.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.xcmp_max_individual_weight`.                                
     */
    get asV932(): {new: bigint} {
        assert(this.isV932)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Overwrite the maximum amount of weight any individual message may consume.
     * Messages above this weight go into the overweight queue and may only be serviced explicitly.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.xcmp_max_individual_weight`.
     */
    get isV972(): boolean {
        return this._chain.getCallHash('XcmpQueue.update_xcmp_max_individual_weight') === '75eef6f2cd3523e44f50db837d1610f4db03539037986ac2704c4a043d58ba81'
    }

    /**
     * Overwrite the maximum amount of weight any individual message may consume.
     * Messages above this weight go into the overweight queue and may only be serviced explicitly.
     * 
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.xcmp_max_individual_weight`.
     */
    get asV972(): {new: v972.Weight} {
        assert(this.isV972)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolAddLiquidityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.add_liquidity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Provide liquidity to a pair.
     * 
     *  The order of foreign dot effect result.
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up pair
     *  - `asset_1`: Asset which make up pair
     *  - `amount_0_desired`: Maximum amount of asset_0 added to the pair
     *  - `amount_1_desired`: Maximum amount of asset_1 added to the pair
     *  - `amount_0_min`: Minimum amount of asset_0 added to the pair
     *  - `amount_1_min`: Minimum amount of asset_1 added to the pair
     *  - `deadline`: Height of the cutoff block of this transaction
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.add_liquidity') === '00307a0580a3d68eb0b6acd0e7b8d48f0bea992c0e583b54dbc23f57fda9871c'
    }

    /**
     *  Provide liquidity to a pair.
     * 
     *  The order of foreign dot effect result.
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up pair
     *  - `asset_1`: Asset which make up pair
     *  - `amount_0_desired`: Maximum amount of asset_0 added to the pair
     *  - `amount_1_desired`: Maximum amount of asset_1 added to the pair
     *  - `amount_0_min`: Minimum amount of asset_0 added to the pair
     *  - `amount_1_min`: Minimum amount of asset_1 added to the pair
     *  - `deadline`: Height of the cutoff block of this transaction
     */
    get asV902(): {asset0: number, asset1: number, amount0Desired: bigint, amount1Desired: bigint, amount0Min: bigint, amount1Min: bigint, deadline: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Provide liquidity to a pair.
     * 
     * The order of foreign dot effect result.
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up pair
     * - `asset_1`: Asset which make up pair
     * - `amount_0_desired`: Maximum amount of asset_0 added to the pair
     * - `amount_1_desired`: Maximum amount of asset_1 added to the pair
     * - `amount_0_min`: Minimum amount of asset_0 added to the pair
     * - `amount_1_min`: Minimum amount of asset_1 added to the pair
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.add_liquidity') === 'bd55af4478958add2a351d6fc48ad81dcd1e4d1718ca5b9989beca6294404e74'
    }

    /**
     * Provide liquidity to a pair.
     * 
     * The order of foreign dot effect result.
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up pair
     * - `asset_1`: Asset which make up pair
     * - `amount_0_desired`: Maximum amount of asset_0 added to the pair
     * - `amount_1_desired`: Maximum amount of asset_1 added to the pair
     * - `amount_0_min`: Minimum amount of asset_0 added to the pair
     * - `amount_1_min`: Minimum amount of asset_1 added to the pair
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get asV906(): {asset0: v906.AssetId, asset1: v906.AssetId, amount0Desired: bigint, amount1Desired: bigint, amount0Min: bigint, amount1Min: bigint, deadline: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolBootstrapChargeRewardCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.bootstrap_charge_reward')
        this._chain = ctx._chain
        this.call = call
    }

    get isV914(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_charge_reward') === '97a2f34aa3d2e22433842906419c98c10cbd14d2453cb0d4f0503e8395b1aeb3'
    }

    get asV914(): {asset0: v914.AssetId, asset1: v914.AssetId, chargeRewards: [v914.AssetId, bigint][]} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolBootstrapClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.bootstrap_claim')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Claim lp asset from a bootstrap pair
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up bootstrap pair
     *  - `asset_1`: Asset which make up bootstrap pair
     *  - `deadline`: Height of the cutoff block of this transaction
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_claim') === '1f253dfc8cdbfae0ade1d858fe720fecd2afc1ced8365f568970ce8615ea6d22'
    }

    /**
     *  Claim lp asset from a bootstrap pair
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up bootstrap pair
     *  - `asset_1`: Asset which make up bootstrap pair
     *  - `deadline`: Height of the cutoff block of this transaction
     */
    get asV902(): {recipient: v902.LookupSource, asset0: number, asset1: number, deadline: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Claim lp asset from a bootstrap pair
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_claim') === '31f9e163a0d9197f970eda233c920ea31aee1c4391e5a130d809104524f26963'
    }

    /**
     * Claim lp asset from a bootstrap pair
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get asV906(): {recipient: v906.MultiAddress, asset0: v906.AssetId, asset1: v906.AssetId, deadline: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolBootstrapContributeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.bootstrap_contribute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Contribute some asset to a bootstrap pair
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up bootstrap pair
     *  - `asset_1`: Asset which make up bootstrap pair
     *  - `amount_0_contribute`: The amount of asset_0 contribute to this bootstrap pair
     *  - `amount_1_contribute`: The amount of asset_1 contribute to this bootstrap pair
     *  - `deadline`: Height of the cutoff block of this transaction
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_contribute') === 'a69c70480c8300dbb3afb2f9d604520fe5f684d2ff2402ab53a0e763f3488b52'
    }

    /**
     *  Contribute some asset to a bootstrap pair
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up bootstrap pair
     *  - `asset_1`: Asset which make up bootstrap pair
     *  - `amount_0_contribute`: The amount of asset_0 contribute to this bootstrap pair
     *  - `amount_1_contribute`: The amount of asset_1 contribute to this bootstrap pair
     *  - `deadline`: Height of the cutoff block of this transaction
     */
    get asV902(): {asset0: number, asset1: number, amount0Contribute: bigint, amount1Contribute: bigint, deadline: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Contribute some asset to a bootstrap pair
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `amount_0_contribute`: The amount of asset_0 contribute to this bootstrap pair
     * - `amount_1_contribute`: The amount of asset_1 contribute to this bootstrap pair
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_contribute') === '23cb0836cf70bc34233400b14397ce55ad717805201732f676687389753f7d58'
    }

    /**
     * Contribute some asset to a bootstrap pair
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `amount_0_contribute`: The amount of asset_0 contribute to this bootstrap pair
     * - `amount_1_contribute`: The amount of asset_1 contribute to this bootstrap pair
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get asV906(): {asset0: v906.AssetId, asset1: v906.AssetId, amount0Contribute: bigint, amount1Contribute: bigint, deadline: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolBootstrapCreateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.bootstrap_create')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Create bootstrap pair
     * 
     *  The order of foreign dot effect result.
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up bootstrap pair
     *  - `asset_1`: Asset which make up bootstrap pair
     *  - `min_contribution_0`: Min amount of asset_0 contribute
     *  - `min_contribution_0`: Min amount of asset_1 contribute
     *  - `target_supply_0`: Target amount of asset_0 total contribute
     *  - `target_supply_0`: Target amount of asset_1 total contribute
     *  - `end`: The earliest ending block.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_create') === '85c63ba4bcc1abb36458904aee998e0b820f8b1dd19f39f9fef5e5a577c014b3'
    }

    /**
     *  Create bootstrap pair
     * 
     *  The order of foreign dot effect result.
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up bootstrap pair
     *  - `asset_1`: Asset which make up bootstrap pair
     *  - `min_contribution_0`: Min amount of asset_0 contribute
     *  - `min_contribution_0`: Min amount of asset_1 contribute
     *  - `target_supply_0`: Target amount of asset_0 total contribute
     *  - `target_supply_0`: Target amount of asset_1 total contribute
     *  - `end`: The earliest ending block.
     */
    get asV902(): {asset0: number, asset1: number, minContribution0: bigint, minContribution1: bigint, targetSupply0: bigint, targetSupply1: bigint, end: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create bootstrap pair
     * 
     * The order of asset don't affect result.
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `target_supply_0`: Target amount of asset_0 total contribute
     * - `target_supply_0`: Target amount of asset_1 total contribute
     * - `capacity_supply_0`: The max amount of asset_0 total contribute
     * - `capacity_supply_1`: The max amount of asset_1 total contribute
     * - `end`: The earliest ending block.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_create') === '2bc680c415f9f79abbb0346dc284a9292b8404939fca3854947fd37c40beb912'
    }

    /**
     * Create bootstrap pair
     * 
     * The order of asset don't affect result.
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `target_supply_0`: Target amount of asset_0 total contribute
     * - `target_supply_0`: Target amount of asset_1 total contribute
     * - `capacity_supply_0`: The max amount of asset_0 total contribute
     * - `capacity_supply_1`: The max amount of asset_1 total contribute
     * - `end`: The earliest ending block.
     */
    get asV906(): {asset0: v906.AssetId, asset1: v906.AssetId, targetSupply0: bigint, targetSupply1: bigint, capacitySupply0: bigint, capacitySupply1: bigint, end: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create bootstrap pair
     * 
     * The order of asset don't affect result.
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `target_supply_0`: Target amount of asset_0 total contribute
     * - `target_supply_0`: Target amount of asset_1 total contribute
     * - `capacity_supply_0`: The max amount of asset_0 total contribute
     * - `capacity_supply_1`: The max amount of asset_1 total contribute
     * - `end`: The earliest ending block.
     */
    get isV914(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_create') === '7aa673325aeaee6721d7d0f71751b33b0de066cc87b5ac65e14d486cf40db096'
    }

    /**
     * Create bootstrap pair
     * 
     * The order of asset don't affect result.
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `target_supply_0`: Target amount of asset_0 total contribute
     * - `target_supply_0`: Target amount of asset_1 total contribute
     * - `capacity_supply_0`: The max amount of asset_0 total contribute
     * - `capacity_supply_1`: The max amount of asset_1 total contribute
     * - `end`: The earliest ending block.
     */
    get asV914(): {asset0: v914.AssetId, asset1: v914.AssetId, targetSupply0: bigint, targetSupply1: bigint, capacitySupply0: bigint, capacitySupply1: bigint, end: number, rewards: v914.AssetId[], limits: [v914.AssetId, bigint][]} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolBootstrapEndCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.bootstrap_end')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  End a bootstrap pair
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up bootstrap pair
     *  - `asset_1`: Asset which make up bootstrap pair
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_end') === 'a65f53bf9822906c6da2f4a9779fc3ee7ef5d3afc12f5fd88656a7dba750c1ac'
    }

    /**
     *  End a bootstrap pair
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up bootstrap pair
     *  - `asset_1`: Asset which make up bootstrap pair
     */
    get asV902(): {asset0: number, asset1: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * End a bootstrap pair
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_end') === '946b724fa01a5a389c6302c7dbeb884cfa8f9263184a14f7903d4e5c71adb10f'
    }

    /**
     * End a bootstrap pair
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     */
    get asV906(): {asset0: v906.AssetId, asset1: v906.AssetId} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolBootstrapRefundCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.bootstrap_refund')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Contributor refund from disable bootstrap pair
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up bootstrap pair
     *  - `asset_1`: Asset which make up bootstrap pair
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_refund') === 'a65f53bf9822906c6da2f4a9779fc3ee7ef5d3afc12f5fd88656a7dba750c1ac'
    }

    /**
     *  Contributor refund from disable bootstrap pair
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up bootstrap pair
     *  - `asset_1`: Asset which make up bootstrap pair
     */
    get asV902(): {asset0: number, asset1: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Contributor refund from disable bootstrap pair
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_refund') === '946b724fa01a5a389c6302c7dbeb884cfa8f9263184a14f7903d4e5c71adb10f'
    }

    /**
     * Contributor refund from disable bootstrap pair
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     */
    get asV906(): {asset0: v906.AssetId, asset1: v906.AssetId} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolBootstrapUpdateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.bootstrap_update')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  update a bootstrap pair
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up bootstrap pair
     *  - `asset_1`: Asset which make up bootstrap pair
     *  - `min_contribution_0`: The new min amount of asset_0 contribute
     *  - `min_contribution_0`: The new min amount of asset_1 contribute
     *  - `target_supply_0`: The new target amount of asset_0 total contribute
     *  - `target_supply_0`: The new target amount of asset_1 total contribute
     *  - `end`: The earliest ending block.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_update') === '85c63ba4bcc1abb36458904aee998e0b820f8b1dd19f39f9fef5e5a577c014b3'
    }

    /**
     *  update a bootstrap pair
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up bootstrap pair
     *  - `asset_1`: Asset which make up bootstrap pair
     *  - `min_contribution_0`: The new min amount of asset_0 contribute
     *  - `min_contribution_0`: The new min amount of asset_1 contribute
     *  - `target_supply_0`: The new target amount of asset_0 total contribute
     *  - `target_supply_0`: The new target amount of asset_1 total contribute
     *  - `end`: The earliest ending block.
     */
    get asV902(): {asset0: number, asset1: number, minContribution0: bigint, minContribution1: bigint, targetSupply0: bigint, targetSupply1: bigint, end: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * update a bootstrap pair
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `min_contribution_0`: The new min amount of asset_0 contribute
     * - `min_contribution_0`: The new min amount of asset_1 contribute
     * - `target_supply_0`: The new target amount of asset_0 total contribute
     * - `target_supply_0`: The new target amount of asset_1 total contribute
     * - `capacity_supply_0`: The new max amount of asset_0 total contribute
     * - `capacity_supply_1`: The new max amount of asset_1 total contribute
     * - `end`: The earliest ending block.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_update') === '2bc680c415f9f79abbb0346dc284a9292b8404939fca3854947fd37c40beb912'
    }

    /**
     * update a bootstrap pair
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `min_contribution_0`: The new min amount of asset_0 contribute
     * - `min_contribution_0`: The new min amount of asset_1 contribute
     * - `target_supply_0`: The new target amount of asset_0 total contribute
     * - `target_supply_0`: The new target amount of asset_1 total contribute
     * - `capacity_supply_0`: The new max amount of asset_0 total contribute
     * - `capacity_supply_1`: The new max amount of asset_1 total contribute
     * - `end`: The earliest ending block.
     */
    get asV906(): {asset0: v906.AssetId, asset1: v906.AssetId, targetSupply0: bigint, targetSupply1: bigint, capacitySupply0: bigint, capacitySupply1: bigint, end: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }

    /**
     * update a bootstrap pair
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `min_contribution_0`: The new min amount of asset_0 contribute
     * - `min_contribution_0`: The new min amount of asset_1 contribute
     * - `target_supply_0`: The new target amount of asset_0 total contribute
     * - `target_supply_0`: The new target amount of asset_1 total contribute
     * - `capacity_supply_0`: The new max amount of asset_0 total contribute
     * - `capacity_supply_1`: The new max amount of asset_1 total contribute
     * - `end`: The earliest ending block.
     */
    get isV914(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_update') === '7aa673325aeaee6721d7d0f71751b33b0de066cc87b5ac65e14d486cf40db096'
    }

    /**
     * update a bootstrap pair
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up bootstrap pair
     * - `asset_1`: Asset which make up bootstrap pair
     * - `min_contribution_0`: The new min amount of asset_0 contribute
     * - `min_contribution_0`: The new min amount of asset_1 contribute
     * - `target_supply_0`: The new target amount of asset_0 total contribute
     * - `target_supply_0`: The new target amount of asset_1 total contribute
     * - `capacity_supply_0`: The new max amount of asset_0 total contribute
     * - `capacity_supply_1`: The new max amount of asset_1 total contribute
     * - `end`: The earliest ending block.
     */
    get asV914(): {asset0: v914.AssetId, asset1: v914.AssetId, targetSupply0: bigint, targetSupply1: bigint, capacitySupply0: bigint, capacitySupply1: bigint, end: number, rewards: v914.AssetId[], limits: [v914.AssetId, bigint][]} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolBootstrapWithdrawRewardCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.bootstrap_withdraw_reward')
        this._chain = ctx._chain
        this.call = call
    }

    get isV914(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.bootstrap_withdraw_reward') === '0e91df5e2ce80654056f668be8b45035147037dfeb99e975b3d1f1efa7a1eb3a'
    }

    get asV914(): {asset0: v914.AssetId, asset1: v914.AssetId, recipient: v914.MultiAddress} {
        assert(this.isV914)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolCreatePairCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.create_pair')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Create pair by two assets.
     * 
     *  The order of foreign dot effect result.
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up Pair
     *  - `asset_1`: Asset which make up Pair
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.create_pair') === 'a65f53bf9822906c6da2f4a9779fc3ee7ef5d3afc12f5fd88656a7dba750c1ac'
    }

    /**
     *  Create pair by two assets.
     * 
     *  The order of foreign dot effect result.
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up Pair
     *  - `asset_1`: Asset which make up Pair
     */
    get asV902(): {asset0: number, asset1: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create pair by two assets.
     * 
     * The order of foreign dot effect result.
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up Pair
     * - `asset_1`: Asset which make up Pair
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.create_pair') === '946b724fa01a5a389c6302c7dbeb884cfa8f9263184a14f7903d4e5c71adb10f'
    }

    /**
     * Create pair by two assets.
     * 
     * The order of foreign dot effect result.
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up Pair
     * - `asset_1`: Asset which make up Pair
     */
    get asV906(): {asset0: v906.AssetId, asset1: v906.AssetId} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolRemoveLiquidityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.remove_liquidity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Extract liquidity.
     * 
     *  The order of foreign dot effect result.
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up pair
     *  - `asset_1`: Asset which make up pair
     *  - `amount_asset_0_min`: Minimum amount of asset_0 to exact
     *  - `amount_asset_1_min`: Minimum amount of asset_1 to exact
     *  - `recipient`: Account that accepts withdrawal of assets
     *  - `deadline`: Height of the cutoff block of this transaction
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.remove_liquidity') === '200b1fcda83fd35a94fa1b533e718b5ae1b0a15e55007b71fe34589c15d10a06'
    }

    /**
     *  Extract liquidity.
     * 
     *  The order of foreign dot effect result.
     * 
     *  # Arguments
     * 
     *  - `asset_0`: Asset which make up pair
     *  - `asset_1`: Asset which make up pair
     *  - `amount_asset_0_min`: Minimum amount of asset_0 to exact
     *  - `amount_asset_1_min`: Minimum amount of asset_1 to exact
     *  - `recipient`: Account that accepts withdrawal of assets
     *  - `deadline`: Height of the cutoff block of this transaction
     */
    get asV902(): {asset0: number, asset1: number, liquidity: bigint, amount0Min: bigint, amount1Min: bigint, recipient: v902.LookupSource, deadline: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Extract liquidity.
     * 
     * The order of foreign dot effect result.
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up pair
     * - `asset_1`: Asset which make up pair
     * - `amount_asset_0_min`: Minimum amount of asset_0 to exact
     * - `amount_asset_1_min`: Minimum amount of asset_1 to exact
     * - `recipient`: Account that accepts withdrawal of assets
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.remove_liquidity') === '39fa37ce2bc75c02973cfb24b96594fce02c9acce562043d8802e6a8530bad7d'
    }

    /**
     * Extract liquidity.
     * 
     * The order of foreign dot effect result.
     * 
     * # Arguments
     * 
     * - `asset_0`: Asset which make up pair
     * - `asset_1`: Asset which make up pair
     * - `amount_asset_0_min`: Minimum amount of asset_0 to exact
     * - `amount_asset_1_min`: Minimum amount of asset_1 to exact
     * - `recipient`: Account that accepts withdrawal of assets
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get asV906(): {asset0: v906.AssetId, asset1: v906.AssetId, liquidity: bigint, amount0Min: bigint, amount1Min: bigint, recipient: v906.MultiAddress, deadline: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolSetFeePointCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.set_fee_point')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the protocol fee point.
     * 
     *  # Arguments
     * 
     *  - `fee_point`:
     *  The fee_point which integer between [0,30]
     *  0 means no protocol fee.
     *  30 means 0.3% * 100% = 0.0030.
     *  default is 5 and means 0.3% * 1 / 6 = 0.0005.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.set_fee_point') === '89fa7959e86a423cd3d76bf5b4fb33e45dd8405a69eeaa5b2d335cae9668a22d'
    }

    /**
     *  Set the protocol fee point.
     * 
     *  # Arguments
     * 
     *  - `fee_point`:
     *  The fee_point which integer between [0,30]
     *  0 means no protocol fee.
     *  30 means 0.3% * 100% = 0.0030.
     *  default is 5 and means 0.3% * 1 / 6 = 0.0005.
     */
    get asV902(): {feePoint: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolSetFeeReceiverCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.set_fee_receiver')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the new receiver of the protocol fee.
     * 
     *  # Arguments
     * 
     *  - `send_to`:
     *  (1) Some(receiver): it turn on the protocol fee and the new receiver account.
     *  (2) None: it turn off the protocol fee.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.set_fee_receiver') === 'ea59a71cbe9aace9cae32146a92e3980024d41b5cdbecde90655947dc731260f'
    }

    /**
     *  Set the new receiver of the protocol fee.
     * 
     *  # Arguments
     * 
     *  - `send_to`:
     *  (1) Some(receiver): it turn on the protocol fee and the new receiver account.
     *  (2) None: it turn off the protocol fee.
     */
    get asV902(): {sendTo: (v902.LookupSource | undefined)} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolSwapAssetsForExactAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.swap_assets_for_exact_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Buy amount of foreign by path.
     * 
     *  # Arguments
     * 
     *  - `amount_out`: Amount of the foreign will be bought
     *  - `amount_in_max`: Maximum amount of sold foreign
     *  - `path`: path can convert to pairs.
     *  - `recipient`: Account that receive the target foreign
     *  - `deadline`: Height of the cutoff block of this transaction
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.swap_assets_for_exact_assets') === '87a2834ebee34d5aaeaa19315f4b2b66d700dcdd39a982395a876b31b7a1f2d1'
    }

    /**
     *  Buy amount of foreign by path.
     * 
     *  # Arguments
     * 
     *  - `amount_out`: Amount of the foreign will be bought
     *  - `amount_in_max`: Maximum amount of sold foreign
     *  - `path`: path can convert to pairs.
     *  - `recipient`: Account that receive the target foreign
     *  - `deadline`: Height of the cutoff block of this transaction
     */
    get asV902(): {amountOut: bigint, amountInMax: bigint, path: number[], recipient: v902.LookupSource, deadline: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Buy amount of foreign by path.
     * 
     * # Arguments
     * 
     * - `amount_out`: Amount of the foreign will be bought
     * - `amount_in_max`: Maximum amount of sold foreign
     * - `path`: path can convert to pairs.
     * - `recipient`: Account that receive the target foreign
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.swap_assets_for_exact_assets') === '24541140324e21b90b6917efc6ca03b09755c11defb1cd60109c029659d570e4'
    }

    /**
     * Buy amount of foreign by path.
     * 
     * # Arguments
     * 
     * - `amount_out`: Amount of the foreign will be bought
     * - `amount_in_max`: Maximum amount of sold foreign
     * - `path`: path can convert to pairs.
     * - `recipient`: Account that receive the target foreign
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get asV906(): {amountOut: bigint, amountInMax: bigint, path: v906.AssetId[], recipient: v906.MultiAddress, deadline: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolSwapExactAssetsForAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.swap_exact_assets_for_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sell amount of foreign by path.
     * 
     *  # Arguments
     * 
     *  - `amount_in`: Amount of the foreign will be sold
     *  - `amount_out_min`: Minimum amount of target foreign
     *  - `path`: path can convert to pairs.
     *  - `recipient`: Account that receive the target foreign
     *  - `deadline`: Height of the cutoff block of this transaction
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.swap_exact_assets_for_assets') === '00cbcb897a6e28a4cc142838bd5c2d8a1044b253ea2d5273eac94c8018332086'
    }

    /**
     *  Sell amount of foreign by path.
     * 
     *  # Arguments
     * 
     *  - `amount_in`: Amount of the foreign will be sold
     *  - `amount_out_min`: Minimum amount of target foreign
     *  - `path`: path can convert to pairs.
     *  - `recipient`: Account that receive the target foreign
     *  - `deadline`: Height of the cutoff block of this transaction
     */
    get asV902(): {amountIn: bigint, amountOutMin: bigint, path: number[], recipient: v902.LookupSource, deadline: number} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Sell amount of foreign by path.
     * 
     * # Arguments
     * 
     * - `amount_in`: Amount of the foreign will be sold
     * - `amount_out_min`: Minimum amount of target foreign
     * - `path`: path can convert to pairs.
     * - `recipient`: Account that receive the target foreign
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.swap_exact_assets_for_assets') === '670de9c5a3dd8d884471561e6fa6c8450c17b6bc2364edb6aa7dd944315e47fd'
    }

    /**
     * Sell amount of foreign by path.
     * 
     * # Arguments
     * 
     * - `amount_in`: Amount of the foreign will be sold
     * - `amount_out_min`: Minimum amount of target foreign
     * - `path`: path can convert to pairs.
     * - `recipient`: Account that receive the target foreign
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get asV906(): {amountIn: bigint, amountOutMin: bigint, path: v906.AssetId[], recipient: v906.MultiAddress, deadline: number} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Move some assets from one holder to another.
     * 
     *  # Arguments
     * 
     *  - `asset_id`: The foreign id.
     *  - `target`: The receiver of the foreign.
     *  - `amount`: The amount of the foreign to transfer.
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.transfer') === '59919a4a5ecfe633d5527841c42d2b6f98d3146a2ec77b69a8238162027a51d3'
    }

    /**
     *  Move some assets from one holder to another.
     * 
     *  # Arguments
     * 
     *  - `asset_id`: The foreign id.
     *  - `target`: The receiver of the foreign.
     *  - `amount`: The amount of the foreign to transfer.
     */
    get asV902(): {assetId: number, recipient: v902.LookupSource, amount: bigint} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Move some assets from one holder to another.
     * 
     * # Arguments
     * 
     * - `asset_id`: The foreign id.
     * - `target`: The receiver of the foreign.
     * - `amount`: The amount of the foreign to transfer.
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.transfer') === 'cbd8d58f48b23c3b7a0b61fc429c1f3ab3c67b00a70d2128cb03ca53f98a8108'
    }

    /**
     * Move some assets from one holder to another.
     * 
     * # Arguments
     * 
     * - `asset_id`: The foreign id.
     * - `target`: The receiver of the foreign.
     * - `amount`: The amount of the foreign to transfer.
     */
    get asV906(): {assetId: v906.AssetId, recipient: v906.MultiAddress, amount: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkProtocolTransferToParachainCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkProtocol.transfer_to_parachain')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer zenlink assets to a sibling parachain.
     * 
     *  Zenlink assets can be either native or foreign to the sending parachain.
     * 
     *  # Arguments
     * 
     *  - `asset_id`: Global identifier for a zenlink foreign
     *  - `para_id`: Destination parachain
     *  - `account`: Destination account
     *  - `amount`: Amount to transfer
     */
    get isV902(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.transfer_to_parachain') === 'acb8a5cbc17cc20f304acbb0c6cd6237d626cc3ec433e089363c88ec9234237c'
    }

    /**
     *  Transfer zenlink assets to a sibling parachain.
     * 
     *  Zenlink assets can be either native or foreign to the sending parachain.
     * 
     *  # Arguments
     * 
     *  - `asset_id`: Global identifier for a zenlink foreign
     *  - `para_id`: Destination parachain
     *  - `account`: Destination account
     *  - `amount`: Amount to transfer
     */
    get asV902(): {assetId: number, paraId: number, recipient: Uint8Array, amount: bigint, maxWeight: bigint} {
        assert(this.isV902)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer zenlink assets to a sibling parachain.
     * 
     * Zenlink assets can be either native or foreign to the sending parachain.
     * 
     * # Arguments
     * 
     * - `asset_id`: Global identifier for a zenlink foreign
     * - `para_id`: Destination parachain
     * - `account`: Destination account
     * - `amount`: Amount to transfer
     */
    get isV906(): boolean {
        return this._chain.getCallHash('ZenlinkProtocol.transfer_to_parachain') === 'cf58ee94a581994c7ae3cdaf8fe0c04237c45ae51539ba171a0f62bdf8be477d'
    }

    /**
     * Transfer zenlink assets to a sibling parachain.
     * 
     * Zenlink assets can be either native or foreign to the sending parachain.
     * 
     * # Arguments
     * 
     * - `asset_id`: Global identifier for a zenlink foreign
     * - `para_id`: Destination parachain
     * - `account`: Destination account
     * - `amount`: Amount to transfer
     */
    get asV906(): {assetId: v906.AssetId, paraId: number, recipient: Uint8Array, amount: bigint, maxWeight: bigint} {
        assert(this.isV906)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmAddLiquidityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.add_liquidity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Supply amounts of currencies to the pool.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `amounts`: Supply amounts of currencies.
     * - `min_mint_amount`: The min amount of lp currency get.
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.add_liquidity') === 'f3b86c599bf7b062b6295929f89055d95b49889a9a77ad41e5404a219a2ff9fa'
    }

    /**
     * Supply amounts of currencies to the pool.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `amounts`: Supply amounts of currencies.
     * - `min_mint_amount`: The min amount of lp currency get.
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get asV962(): {poolId: number, amounts: bigint[], minMintAmount: bigint, to: Uint8Array, deadline: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmAddPoolAndBasePoolLiquidityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.add_pool_and_base_pool_liquidity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Supply amounts of currencies to the pool which contains the lp currency of the base
     * pool.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `base_pool_id`: The id of base pool.
     * - `meta_amounts`: Supply amounts of currencies to pool. The last element must be zero.
     * - `base_amounts`: Supply amounts of currencies to base pool.
     * - `min_to_mint`: The min amount of pool lp currency get.
     * - `deadline`: Height of the cutoff block of this transaction.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.add_pool_and_base_pool_liquidity') === '893baf5516e53c38fdfaf789e48ef645cd4f602ad5831d9414811dac78d966e6'
    }

    /**
     * Supply amounts of currencies to the pool which contains the lp currency of the base
     * pool.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `base_pool_id`: The id of base pool.
     * - `meta_amounts`: Supply amounts of currencies to pool. The last element must be zero.
     * - `base_amounts`: Supply amounts of currencies to base pool.
     * - `min_to_mint`: The min amount of pool lp currency get.
     * - `deadline`: Height of the cutoff block of this transaction.
     */
    get asV962(): {poolId: number, basePoolId: number, metaAmounts: bigint[], baseAmounts: bigint[], minToMint: bigint, to: Uint8Array, deadline: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmCreateBasePoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.create_base_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a stable amm pool.
     * 
     * Only admin can create pool.
     * 
     * # Argument
     * 
     * - `currency_ids`: The currencies will be join the created pool.
     * - `currency_decimals`: The currencies corresponding decimals.
     * - `lp_currency_id`: The specify lp currency id of the created pool.
     * - `a`: The initial A of created pool.
     * - `fee`: The swap fee of created pool.
     * - `admin_fee`: The admin fee of created pool.
     * - `admin_fee_receiver`: The admin fee receiver of created pool.
     * - `lp_currency_symbol`: The symbol of created pool lp currency.
     * - `lp_currency_decimal`: The decimal of created pool lp currency.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.create_base_pool') === '407a386e845585dd764385da21d215f944551772c3d5794c8790afedb8ba276d'
    }

    /**
     * Create a stable amm pool.
     * 
     * Only admin can create pool.
     * 
     * # Argument
     * 
     * - `currency_ids`: The currencies will be join the created pool.
     * - `currency_decimals`: The currencies corresponding decimals.
     * - `lp_currency_id`: The specify lp currency id of the created pool.
     * - `a`: The initial A of created pool.
     * - `fee`: The swap fee of created pool.
     * - `admin_fee`: The admin fee of created pool.
     * - `admin_fee_receiver`: The admin fee receiver of created pool.
     * - `lp_currency_symbol`: The symbol of created pool lp currency.
     * - `lp_currency_decimal`: The decimal of created pool lp currency.
     */
    get asV962(): {currencyIds: v962.CurrencyId[], currencyDecimals: number[], a: bigint, fee: bigint, adminFee: bigint, adminFeeReceiver: Uint8Array, lpCurrencySymbol: Uint8Array} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmCreateMetaPoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.create_meta_pool')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a stable amm meta pool.
     * 
     * Only admin can create pool.
     * 
     * # Argument
     * 
     * - `currency_ids`: The currencies will be join the created pool.
     * - `currency_decimals`: The currencies corresponding decimals.
     * - `lp_currency_id`: The specify lp currency id of the created pool.
     * - `a`: The initial A of created pool.
     * - `fee`: The swap fee of created pool.
     * - `admin_fee`: The admin fee of created pool.
     * - `admin_fee_receiver`: The admin fee receiver of created pool.
     * - `lp_currency_symbol`: The symbol of created pool lp currency.
     * - `lp_currency_decimal`: The decimal of created pool lp currency.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.create_meta_pool') === '407a386e845585dd764385da21d215f944551772c3d5794c8790afedb8ba276d'
    }

    /**
     * Create a stable amm meta pool.
     * 
     * Only admin can create pool.
     * 
     * # Argument
     * 
     * - `currency_ids`: The currencies will be join the created pool.
     * - `currency_decimals`: The currencies corresponding decimals.
     * - `lp_currency_id`: The specify lp currency id of the created pool.
     * - `a`: The initial A of created pool.
     * - `fee`: The swap fee of created pool.
     * - `admin_fee`: The admin fee of created pool.
     * - `admin_fee_receiver`: The admin fee receiver of created pool.
     * - `lp_currency_symbol`: The symbol of created pool lp currency.
     * - `lp_currency_decimal`: The decimal of created pool lp currency.
     */
    get asV962(): {currencyIds: v962.CurrencyId[], currencyDecimals: number[], a: bigint, fee: bigint, adminFee: bigint, adminFeeReceiver: Uint8Array, lpCurrencySymbol: Uint8Array} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmRampACall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.ramp_a')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Start ramping up or down A parameter towards given future_a and future_a_time
     * 
     * Only called by admin.
     * Checks if the change is too rapid, and commits the new A value only when it falls under
     * the limit range.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `future_a`: The new A to ramp towards.
     * - `future_a_time`: Timestamp when the new A should be reached
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.ramp_a') === '8bd2d5b0056c23bdf5916105a1c473aee6c41aec607eec569647ced9e28d3e78'
    }

    /**
     * Start ramping up or down A parameter towards given future_a and future_a_time
     * 
     * Only called by admin.
     * Checks if the change is too rapid, and commits the new A value only when it falls under
     * the limit range.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `future_a`: The new A to ramp towards.
     * - `future_a_time`: Timestamp when the new A should be reached
     */
    get asV962(): {poolId: number, futureA: bigint, futureATime: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmRemoveLiquidityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.remove_liquidity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove liquidity from a pool.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `lp_amount`: The amounts of lp currency.
     * - `min_amounts`: The min amounts of pool's currencies to get.
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.remove_liquidity') === '5fa5f0a4b27a44da065709aeae9b4df2f8dab2d13b086a99cdcecd2ac9fcd57c'
    }

    /**
     * Remove liquidity from a pool.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `lp_amount`: The amounts of lp currency.
     * - `min_amounts`: The min amounts of pool's currencies to get.
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get asV962(): {pooId: number, lpAmount: bigint, minAmounts: bigint[], to: Uint8Array, deadline: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmRemoveLiquidityImbalanceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.remove_liquidity_imbalance')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove liquidity from a pool to the specify amounts of currencies.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `amounts`: The specify amounts of receive currencies.
     * - `max_burn_amount`: The max amount of burned lp currency.
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.remove_liquidity_imbalance') === '327f20553737fc41ac05d7372a2a65b6406f93dcedee89cba3c83a463b12becb'
    }

    /**
     * Remove liquidity from a pool to the specify amounts of currencies.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `amounts`: The specify amounts of receive currencies.
     * - `max_burn_amount`: The max amount of burned lp currency.
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get asV962(): {poolId: number, amounts: bigint[], maxBurnAmount: bigint, to: Uint8Array, deadline: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmRemoveLiquidityOneCurrencyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.remove_liquidity_one_currency')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove liquidity from a pool to get one currency.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `lp_amount`: The amounts of lp currency.
     * - `index`: The index of receive currency.
     * - `min_amount`: The min amounts of received currency;
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.remove_liquidity_one_currency') === '195e00c5cc505e876bed509913674230a6284582f175dd95fa4a26bfae59b745'
    }

    /**
     * Remove liquidity from a pool to get one currency.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `lp_amount`: The amounts of lp currency.
     * - `index`: The index of receive currency.
     * - `min_amount`: The min amounts of received currency;
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get asV962(): {pooId: number, lpAmount: bigint, index: number, minAmount: bigint, to: Uint8Array, deadline: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmRemovePoolAndBasePoolLiquidityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.remove_pool_and_base_pool_liquidity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove liquidity from a pool which contains the lp currency of the base pool.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `base_pool_id`: The id of base pool.
     * - `amount`: The amounts of lp currency to burn.
     * - `min_amounts_meta`: The min amounts of pool's currencies to get.
     * - `min_amounts_base`: The min amounts of basic pool's currencies to get.
     * - `deadline`: Height of the cutoff block of this transaction.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.remove_pool_and_base_pool_liquidity') === '528ac4314cb653ff556dd48ef206e5e2248705399904213474730e63579325cb'
    }

    /**
     * Remove liquidity from a pool which contains the lp currency of the base pool.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `base_pool_id`: The id of base pool.
     * - `amount`: The amounts of lp currency to burn.
     * - `min_amounts_meta`: The min amounts of pool's currencies to get.
     * - `min_amounts_base`: The min amounts of basic pool's currencies to get.
     * - `deadline`: Height of the cutoff block of this transaction.
     */
    get asV962(): {poolId: number, basePoolId: number, amount: bigint, minAmountsMeta: bigint[], minAmountsBase: bigint[], to: Uint8Array, deadline: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmRemovePoolAndBasePoolLiquidityOneCurrencyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.remove_pool_and_base_pool_liquidity_one_currency')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove liquidity from a pool which contains the lp currency of the base pool
     * to get one currency.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `base_pool_id`: The id of base pool.
     * - `amount`: The amounts of lp currency to burn.
     * - `i`: The index of target currency in basic pool.
     * - `min_amount`: The min amounts of received currency.
     * - `deadline`: Height of the cutoff block of this transaction.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.remove_pool_and_base_pool_liquidity_one_currency') === '5dfe170cc7926d126b9e707493cc90799335ee093b5902056b9825a781e672a5'
    }

    /**
     * Remove liquidity from a pool which contains the lp currency of the base pool
     * to get one currency.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `base_pool_id`: The id of base pool.
     * - `amount`: The amounts of lp currency to burn.
     * - `i`: The index of target currency in basic pool.
     * - `min_amount`: The min amounts of received currency.
     * - `deadline`: Height of the cutoff block of this transaction.
     */
    get asV962(): {poolId: number, basePoolId: number, amount: bigint, i: number, minAmount: bigint, to: Uint8Array, deadline: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmSetAdminFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.set_admin_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update admin fee of the pool.
     * 
     * Only called by admin.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `new_admin_fee`: The new admin fee of this pool.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.set_admin_fee') === '354aacd87525ee5edab25bfc7703181a00e6bb535431cf8546eea25c7f0fcf9d'
    }

    /**
     * Update admin fee of the pool.
     * 
     * Only called by admin.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `new_admin_fee`: The new admin fee of this pool.
     */
    get asV962(): {poolId: number, newAdminFee: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmSetSwapFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.set_swap_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update fee of the pool.
     * 
     * Only called by admin.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `new_swap_fee`: The new swap fee of this pool.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.set_swap_fee') === '5a651444f44feda108605f5777f9ad6e8411982c46c30660727dcdc176f49c48'
    }

    /**
     * Update fee of the pool.
     * 
     * Only called by admin.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `new_swap_fee`: The new swap fee of this pool.
     */
    get asV962(): {poolId: number, newSwapFee: bigint} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmStopRampACall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.stop_ramp_a')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Stop ramping A parameter.
     * 
     * Only called by admin.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.stop_ramp_a') === 'a662258b1bdb045a915972ea29e9ec0b46cdd5598b0da37b0e70ac766e3735a0'
    }

    /**
     * Stop ramping A parameter.
     * 
     * Only called by admin.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     */
    get asV962(): {poolId: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmSwapCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.swap')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Swap a amounts of currencies to get other.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `from_index`: The index of swap currency id.
     * - `to_index`: The index of receive currency id.
     * - `in_amount`: The amounts of currencies swap.
     * - `min_mint_amount`: The min amount of receive currency.
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.swap') === 'df83d445ffc24d781cce6f65a942302aca5a08b050e34ef9e3a6e53d0847a7c6'
    }

    /**
     * Swap a amounts of currencies to get other.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `from_index`: The index of swap currency id.
     * - `to_index`: The index of receive currency id.
     * - `in_amount`: The amounts of currencies swap.
     * - `min_mint_amount`: The min amount of receive currency.
     * - `deadline`: Height of the cutoff block of this transaction
     */
    get asV962(): {pooId: number, fromIndex: number, toIndex: number, inAmount: bigint, minOutAmount: bigint, to: Uint8Array, deadline: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmSwapMetaPoolUnderlyingCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.swap_meta_pool_underlying')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.swap_meta_pool_underlying') === '97f2dbc1174318f8f6a78b656837dc72514fae94eac1b42da8d7689ce19b8dd7'
    }

    get asV962(): {poolId: number, inIndex: number, outIndex: number, dx: bigint, minDy: bigint, to: Uint8Array, deadline: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmSwapPoolFromBaseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.swap_pool_from_base')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Swap the currency from basic pool to get amounts of other currency in pool.
     * to get one currency.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `base_pool_id`: The id of base pool.
     * - `in_index`: The index of swap currency in basic pool.
     * - `out_index`: The index of target currency in pool.
     * - `dx`: The amounts of swap currency.
     * - `min_dy`: The min amounts of target currency.
     * - `deadline`: Height of the cutoff block of this transaction.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.swap_pool_from_base') === '71d9e3bb15015d3a398a6469bbca5bd59ef8734814d85045a8249bf644aedf4e'
    }

    /**
     * Swap the currency from basic pool to get amounts of other currency in pool.
     * to get one currency.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `base_pool_id`: The id of base pool.
     * - `in_index`: The index of swap currency in basic pool.
     * - `out_index`: The index of target currency in pool.
     * - `dx`: The amounts of swap currency.
     * - `min_dy`: The min amounts of target currency.
     * - `deadline`: Height of the cutoff block of this transaction.
     */
    get asV962(): {poolId: number, basePoolId: number, inIndex: number, outIndex: number, dx: bigint, minDy: bigint, to: Uint8Array, deadline: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmSwapPoolToBaseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.swap_pool_to_base')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Swap the currency from pool to get amounts of other currency in basic pool.
     * to get one currency.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `base_pool_id`: The id of base pool.
     * - `in_index`: The index of swap currency in basic pool.
     * - `out_index`: The index of target currency in pool.
     * - `dx`: The amounts of swap currency.
     * - `min_dy`: The min amounts of target currency.
     * - `deadline`: Height of the cutoff block of this transaction.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.swap_pool_to_base') === '71d9e3bb15015d3a398a6469bbca5bd59ef8734814d85045a8249bf644aedf4e'
    }

    /**
     * Swap the currency from pool to get amounts of other currency in basic pool.
     * to get one currency.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `base_pool_id`: The id of base pool.
     * - `in_index`: The index of swap currency in basic pool.
     * - `out_index`: The index of target currency in pool.
     * - `dx`: The amounts of swap currency.
     * - `min_dy`: The min amounts of target currency.
     * - `deadline`: Height of the cutoff block of this transaction.
     */
    get asV962(): {poolId: number, basePoolId: number, inIndex: number, outIndex: number, dx: bigint, minDy: bigint, to: Uint8Array, deadline: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmUpdateFeeReceiverCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.update_fee_receiver')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update admin fee receiver of the pool.
     * 
     * Only called by admin.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `fee_receiver`: The new admin fee receiver of this pool.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.update_fee_receiver') === '68f3639ade32a36b0ace8c4fbc625cfb699b932160e155c9cfee5b73648d0c2b'
    }

    /**
     * Update admin fee receiver of the pool.
     * 
     * Only called by admin.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     * - `fee_receiver`: The new admin fee receiver of this pool.
     */
    get asV962(): {poolId: number, feeReceiver: v962.MultiAddress} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkStableAmmWithdrawAdminFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkStableAMM.withdraw_admin_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Withdraw the admin fee from pool to admin fee receiver.
     * 
     * Can called by anyone.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     */
    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkStableAMM.withdraw_admin_fee') === 'a662258b1bdb045a915972ea29e9ec0b46cdd5598b0da37b0e70ac766e3735a0'
    }

    /**
     * Withdraw the admin fee from pool to admin fee receiver.
     * 
     * Can called by anyone.
     * 
     * # Argument
     * 
     * - `pool_id`: The id of pool.
     */
    get asV962(): {poolId: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}

export class ZenlinkSwapRouterSwapExactTokenForTokensThroughStablePoolCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ZenlinkSwapRouter.swap_exact_token_for_tokens_through_stable_pool')
        this._chain = ctx._chain
        this.call = call
    }

    get isV962(): boolean {
        return this._chain.getCallHash('ZenlinkSwapRouter.swap_exact_token_for_tokens_through_stable_pool') === 'df7fdf4d0813186bb9394a1181685a8141e6487374ca9b1580da76b5ab0ed088'
    }

    get asV962(): {amountIn: bigint, amountOutMin: bigint, routes: v962.Route[], to: Uint8Array, deadline: number} {
        assert(this.isV962)
        return this._chain.decodeCall(this.call)
    }
}
