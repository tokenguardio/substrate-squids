import assert from 'assert'
import {Chain, ChainContext, CallContext, Call, Result, Option} from './support'
import * as v1020 from './v1020'
import * as v1022 from './v1022'
import * as v1024 from './v1024'
import * as v1027 from './v1027'
import * as v1029 from './v1029'
import * as v1030 from './v1030'
import * as v1031 from './v1031'
import * as v1032 from './v1032'
import * as v1038 from './v1038'
import * as v1039 from './v1039'
import * as v1040 from './v1040'
import * as v1042 from './v1042'
import * as v1050 from './v1050'
import * as v1054 from './v1054'
import * as v1055 from './v1055'
import * as v1058 from './v1058'
import * as v1062 from './v1062'
import * as v2005 from './v2005'
import * as v2007 from './v2007'
import * as v2011 from './v2011'
import * as v2013 from './v2013'
import * as v2015 from './v2015'
import * as v2022 from './v2022'
import * as v2023 from './v2023'
import * as v2024 from './v2024'
import * as v2025 from './v2025'
import * as v2026 from './v2026'
import * as v2028 from './v2028'
import * as v2029 from './v2029'
import * as v2030 from './v2030'
import * as v9010 from './v9010'
import * as v9030 from './v9030'
import * as v9040 from './v9040'
import * as v9050 from './v9050'
import * as v9080 from './v9080'
import * as v9090 from './v9090'
import * as v9100 from './v9100'
import * as v9111 from './v9111'
import * as v9122 from './v9122'
import * as v9130 from './v9130'
import * as v9160 from './v9160'
import * as v9170 from './v9170'
import * as v9180 from './v9180'
import * as v9190 from './v9190'
import * as v9220 from './v9220'
import * as v9230 from './v9230'
import * as v9250 from './v9250'
import * as v9271 from './v9271'
import * as v9291 from './v9291'
import * as v9300 from './v9300'
import * as v9320 from './v9320'
import * as v9340 from './v9340'
import * as v9350 from './v9350'
import * as v9370 from './v9370'

export class AttestationsMoreAttestationsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Attestations.more_attestations')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Provide candidate receipts for parachains, in ascending order by id.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Attestations.more_attestations') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Provide candidate receipts for parachains, in ascending order by id.
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class AuctionsBidCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Auctions.bid')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Make a new bid from an account (including a parachain account) for deploying a new
     *  parachain.
     * 
     *  Multiple simultaneous bids from the same bidder are allowed only as long as all active
     *  bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
     * 
     *  - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
     *  funded by) the same account.
     *  - `auction_index` is the index of the auction to bid on. Should just be the present
     *  value of `AuctionCounter`.
     *  - `first_slot` is the first lease period index of the range to bid on. This is the
     *  absolute lease period index value, not an auction-specific offset.
     *  - `last_slot` is the last lease period index of the range to bid on. This is the
     *  absolute lease period index value, not an auction-specific offset.
     *  - `amount` is the amount to bid to be held as deposit for the parachain should the
     *  bid win. This amount is held throughout the range.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Auctions.bid') === '875d3f461aae7e3ba782bc8174e50928c136bb1285ec107fb43dee7de4f50f54'
    }

    /**
     *  Make a new bid from an account (including a parachain account) for deploying a new
     *  parachain.
     * 
     *  Multiple simultaneous bids from the same bidder are allowed only as long as all active
     *  bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
     * 
     *  - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
     *  funded by) the same account.
     *  - `auction_index` is the index of the auction to bid on. Should just be the present
     *  value of `AuctionCounter`.
     *  - `first_slot` is the first lease period index of the range to bid on. This is the
     *  absolute lease period index value, not an auction-specific offset.
     *  - `last_slot` is the last lease period index of the range to bid on. This is the
     *  absolute lease period index value, not an auction-specific offset.
     *  - `amount` is the amount to bid to be held as deposit for the parachain should the
     *  bid win. This amount is held throughout the range.
     */
    get asV9010(): {para: number, auctionIndex: number, firstSlot: number, lastSlot: number, amount: bigint} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class AuctionsCancelAuctionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Auctions.cancel_auction')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel an in-progress auction.
     * 
     *  Can only be called by Root origin.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Auctions.cancel_auction') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Cancel an in-progress auction.
     * 
     *  Can only be called by Root origin.
     */
    get asV9010(): null {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class AuctionsNewAuctionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Auctions.new_auction')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Create a new auction.
     * 
     *  This can only happen when there isn't already an auction in progress and may only be
     *  called by the root origin. Accepts the `duration` of this auction and the
     *  `lease_period_index` of the initial lease period of the four that are to be auctioned.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Auctions.new_auction') === 'f9c6104e2d8ee4a5650bf6b22307030d44c7c7014eb5b79c3fdc26e37431996c'
    }

    /**
     *  Create a new auction.
     * 
     *  This can only happen when there isn't already an auction in progress and may only be
     *  called by the root origin. Accepts the `duration` of this auction and the
     *  `lease_period_index` of the initial lease period of the four that are to be auctioned.
     */
    get asV9010(): {duration: number, leasePeriodIndex: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class AuthorshipSetUnclesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Authorship.set_uncles')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Provide a set of uncles.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Authorship.set_uncles') === 'efd6e78708f873b5d0804d67dee4f6351287add79134d8ee5b59dcfa2a5e21af'
    }

    /**
     *  Provide a set of uncles.
     */
    get asV1020(): {newUncles: v1020.Header[]} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Provide a set of uncles.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Authorship.set_uncles') === '491502deec691ea043fa56fc39b50b58deab8a6411c511016c06289ee5867611'
    }

    /**
     * Provide a set of uncles.
     */
    get asV9111(): {newUncles: v9111.Header[]} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Provide a set of uncles.
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Authorship.set_uncles') === 'cf2d7dac8c8babfdda54dfcca36fda32336dc937b0f1767c6b2332a9b718e0b5'
    }

    /**
     * Provide a set of uncles.
     */
    get asV9130(): {newUncles: v9130.Header[]} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }
}

export class BabePlanConfigChangeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Babe.plan_config_change')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Plan an epoch config change. The epoch config change is recorded and will be enacted on
     *  the next call to `enact_epoch_change`. The config will be activated one epoch after.
     *  Multiple calls to this method will replace any existing planned config change that had
     *  not been enacted yet.
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Babe.plan_config_change') === '946c3b7711f3b1f220d667d61c273d578be27f354f9dba32bbaa932d9f688173'
    }

    /**
     *  Plan an epoch config change. The epoch config change is recorded and will be enacted on
     *  the next call to `enact_epoch_change`. The config will be activated one epoch after.
     *  Multiple calls to this method will replace any existing planned config change that had
     *  not been enacted yet.
     */
    get asV2030(): {config: v2030.NextConfigDescriptor} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Plan an epoch config change. The epoch config change is recorded and will be enacted on
     * the next call to `enact_epoch_change`. The config will be activated one epoch after.
     * Multiple calls to this method will replace any existing planned config change that had
     * not been enacted yet.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Babe.plan_config_change') === '445d07b89db2246e1bb7a27672210d26caa40906751dc15e2e91036d19c646c3'
    }

    /**
     * Plan an epoch config change. The epoch config change is recorded and will be enacted on
     * the next call to `enact_epoch_change`. The config will be activated one epoch after.
     * Multiple calls to this method will replace any existing planned config change that had
     * not been enacted yet.
     */
    get asV9111(): {config: v9111.NextConfigDescriptor} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class BabeReportEquivocationCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Babe.report_equivocation')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Report authority equivocation/misbehavior. This method will verify
     *  the equivocation proof and validate the given key ownership proof
     *  against the extracted offender. If both are valid, the offence will
     *  be reported.
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Babe.report_equivocation') === 'fcf96782e661e8bdc1e552a10118353083fddfff1d09bd4252866b71177bb5da'
    }

    /**
     *  Report authority equivocation/misbehavior. This method will verify
     *  the equivocation proof and validate the given key ownership proof
     *  against the extracted offender. If both are valid, the offence will
     *  be reported.
     */
    get asV2015(): {equivocationProof: v2015.BabeEquivocationProof, keyOwnerProof: v2015.KeyOwnerProof} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Babe.report_equivocation') === 'd4b7f8ae0f516932ce32b6fd7ab44e0be08145614766db6fcb3040fecd285290'
    }

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     */
    get asV9111(): {equivocationProof: v9111.EquivocationProof, keyOwnerProof: v9111.MembershipProof} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Babe.report_equivocation') === '40d799eb32ff6f2d8c0e11e555d627ab95ad001691371ef039423f40d5d53b2b'
    }

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     */
    get asV9130(): {equivocationProof: v9130.EquivocationProof, keyOwnerProof: v9130.MembershipProof} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }
}

export class BabeReportEquivocationUnsignedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Babe.report_equivocation_unsigned')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Report authority equivocation/misbehavior. This method will verify
     *  the equivocation proof and validate the given key ownership proof
     *  against the extracted offender. If both are valid, the offence will
     *  be reported.
     *  This extrinsic must be called unsigned and it is expected that only
     *  block authors will call it (validated in `ValidateUnsigned`), as such
     *  if the block author is defined it will be defined as the equivocation
     *  reporter.
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Babe.report_equivocation_unsigned') === 'fcf96782e661e8bdc1e552a10118353083fddfff1d09bd4252866b71177bb5da'
    }

    /**
     *  Report authority equivocation/misbehavior. This method will verify
     *  the equivocation proof and validate the given key ownership proof
     *  against the extracted offender. If both are valid, the offence will
     *  be reported.
     *  This extrinsic must be called unsigned and it is expected that only
     *  block authors will call it (validated in `ValidateUnsigned`), as such
     *  if the block author is defined it will be defined as the equivocation
     *  reporter.
     */
    get asV2015(): {equivocationProof: v2015.BabeEquivocationProof, keyOwnerProof: v2015.KeyOwnerProof} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Babe.report_equivocation_unsigned') === 'd4b7f8ae0f516932ce32b6fd7ab44e0be08145614766db6fcb3040fecd285290'
    }

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    get asV9111(): {equivocationProof: v9111.EquivocationProof, keyOwnerProof: v9111.MembershipProof} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Babe.report_equivocation_unsigned') === '40d799eb32ff6f2d8c0e11e555d627ab95ad001691371ef039423f40d5d53b2b'
    }

    /**
     * Report authority equivocation/misbehavior. This method will verify
     * the equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence will
     * be reported.
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     */
    get asV9130(): {equivocationProof: v9130.EquivocationProof, keyOwnerProof: v9130.MembershipProof} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }
}

export class BagsListPutInFrontOfCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'BagsList.put_in_front_of')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Move the caller's Id directly in front of `lighter`.
     * 
     * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
     * the account going in front of `lighter`.
     * 
     * Only works if
     * - both nodes are within the same bag,
     * - and `origin` has a greater `VoteWeight` than `lighter`.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('BagsList.put_in_front_of') === '1c9b6f4fe2c3f09518b5cf691b90a9cfbbb049860f2d665fdf2f18450ebe9b2f'
    }

    /**
     * Move the caller's Id directly in front of `lighter`.
     * 
     * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
     * the account going in front of `lighter`.
     * 
     * Only works if
     * - both nodes are within the same bag,
     * - and `origin` has a greater `VoteWeight` than `lighter`.
     */
    get asV9160(): {lighter: Uint8Array} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class BagsListRebagCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'BagsList.rebag')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
     * changed its weight that it should properly fall into a different bag than its current
     * one.
     * 
     * Anyone can call this function about any potentially dislocated account.
     * 
     * Will never return an error; if `dislocated` does not exist or doesn't need a rebag, then
     * it is a noop and fees are still collected from `origin`.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('BagsList.rebag') === '6f1b791f1be804afc4e38eb1e926ba86935e013132cb323a061f4b76a89cbd3e'
    }

    /**
     * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
     * changed its weight that it should properly fall into a different bag than its current
     * one.
     * 
     * Anyone can call this function about any potentially dislocated account.
     * 
     * Will never return an error; if `dislocated` does not exist or doesn't need a rebag, then
     * it is a noop and fees are still collected from `origin`.
     */
    get asV9111(): {dislocated: Uint8Array} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesForceTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.force_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Exactly as `transfer`, except the origin must be root and the source account may be
     *  specified.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Balances.force_transfer') === 'df4a214d4dde3e82d3b36a6bb537e569f58b42cd75a9ad78b1b909171e93b042'
    }

    /**
     *  Exactly as `transfer`, except the origin must be root and the source account may be
     *  specified.
     */
    get asV1020(): {source: v1020.LookupSource, dest: v1020.LookupSource, value: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Exactly as `transfer`, except the origin must be root and the source account may be
     *  specified.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Balances.force_transfer') === '2fe8348cf811b833de74f02f6eeab668dbfad8a5d53274dd89837666ed3eb6fe'
    }

    /**
     *  Exactly as `transfer`, except the origin must be root and the source account may be
     *  specified.
     */
    get asV1050(): {source: Uint8Array, dest: Uint8Array, value: bigint} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Exactly as `transfer`, except the origin must be root and the source account may be
     *  specified.
     *  # <weight>
     *  - Same as transfer, but additional read and write because the source account is
     *    not assumed to be in the overlay.
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Balances.force_transfer') === '906df11f4f65ebd03a2b87ba248e1fba11c3a0bca42c892bee828bac3ec80348'
    }

    /**
     *  Exactly as `transfer`, except the origin must be root and the source account may be
     *  specified.
     *  # <weight>
     *  - Same as transfer, but additional read and write because the source account is
     *    not assumed to be in the overlay.
     *  # </weight>
     */
    get asV2028(): {source: v2028.LookupSource, dest: v2028.LookupSource, value: bigint} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source account may be
     * specified.
     * # <weight>
     * - Same as transfer, but additional read and write because the source account is not
     *   assumed to be in the overlay.
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Balances.force_transfer') === 'e5944fbe8224a17fe49f9c1d1d01efaf87fb1778fd39618512af54c9ba6f9dff'
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source account may be
     * specified.
     * # <weight>
     * - Same as transfer, but additional read and write because the source account is not
     *   assumed to be in the overlay.
     * # </weight>
     */
    get asV9111(): {source: v9111.MultiAddress, dest: v9111.MultiAddress, value: bigint} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesForceUnreserveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.force_unreserve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unreserve some balance from a user by force.
     * 
     * Can only be called by ROOT.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Balances.force_unreserve') === '30bc48977e2a7ad3fc8ac014948ded50fc54886bad9a1f65b02bb64f27d8a6be'
    }

    /**
     * Unreserve some balance from a user by force.
     * 
     * Can only be called by ROOT.
     */
    get asV9111(): {who: v9111.MultiAddress, amount: bigint} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesSetBalanceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.set_balance')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the balances of a given account.
     * 
     *  This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     *  also decrease the total issuance of the system (`TotalIssuance`).
     *  If the new free or reserved balance is below the existential deposit,
     *  it will reset the account nonce (`system::AccountNonce`).
     * 
     *  The dispatch origin for this call is `root`.
     * 
     *  # <weight>
     *  - Independent of the arguments.
     *  - Contains a limited number of reads and writes.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Balances.set_balance') === 'df3bdd91fbe08cf76871e50adc316a9af2680e58a405b5e82923c08840985843'
    }

    /**
     *  Set the balances of a given account.
     * 
     *  This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     *  also decrease the total issuance of the system (`TotalIssuance`).
     *  If the new free or reserved balance is below the existential deposit,
     *  it will reset the account nonce (`system::AccountNonce`).
     * 
     *  The dispatch origin for this call is `root`.
     * 
     *  # <weight>
     *  - Independent of the arguments.
     *  - Contains a limited number of reads and writes.
     *  # </weight>
     */
    get asV1020(): {who: v1020.LookupSource, newFree: bigint, newReserved: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set the balances of a given account.
     * 
     *  This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     *  also decrease the total issuance of the system (`TotalIssuance`).
     *  If the new free or reserved balance is below the existential deposit,
     *  it will reset the account nonce (`frame_system::AccountNonce`).
     * 
     *  The dispatch origin for this call is `root`.
     * 
     *  # <weight>
     *  - Independent of the arguments.
     *  - Contains a limited number of reads and writes.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Balances.set_balance') === 'a65ed3500227691ff89565c1bf5a0244c2a05366e34d1ab50167d0c006774edc'
    }

    /**
     *  Set the balances of a given account.
     * 
     *  This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     *  also decrease the total issuance of the system (`TotalIssuance`).
     *  If the new free or reserved balance is below the existential deposit,
     *  it will reset the account nonce (`frame_system::AccountNonce`).
     * 
     *  The dispatch origin for this call is `root`.
     * 
     *  # <weight>
     *  - Independent of the arguments.
     *  - Contains a limited number of reads and writes.
     *  # </weight>
     */
    get asV1050(): {who: Uint8Array, newFree: bigint, newReserved: bigint} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set the balances of a given account.
     * 
     *  This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     *  also decrease the total issuance of the system (`TotalIssuance`).
     *  If the new free or reserved balance is below the existential deposit,
     *  it will reset the account nonce (`frame_system::AccountNonce`).
     * 
     *  The dispatch origin for this call is `root`.
     * 
     *  # <weight>
     *  - Independent of the arguments.
     *  - Contains a limited number of reads and writes.
     *  ---------------------
     *  - Base Weight:
     *      - Creating: 27.56 µs
     *      - Killing: 35.11 µs
     *  - DB Weight: 1 Read, 1 Write to `who`
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Balances.set_balance') === '94e2a75e6cd4bfc2ec9211ae3a29870014cac2dd2f37c1f9634b6e4bbef0442f'
    }

    /**
     *  Set the balances of a given account.
     * 
     *  This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     *  also decrease the total issuance of the system (`TotalIssuance`).
     *  If the new free or reserved balance is below the existential deposit,
     *  it will reset the account nonce (`frame_system::AccountNonce`).
     * 
     *  The dispatch origin for this call is `root`.
     * 
     *  # <weight>
     *  - Independent of the arguments.
     *  - Contains a limited number of reads and writes.
     *  ---------------------
     *  - Base Weight:
     *      - Creating: 27.56 µs
     *      - Killing: 35.11 µs
     *  - DB Weight: 1 Read, 1 Write to `who`
     *  # </weight>
     */
    get asV2028(): {who: v2028.LookupSource, newFree: bigint, newReserved: bigint} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     * also decrease the total issuance of the system (`TotalIssuance`).
     * If the new free or reserved balance is below the existential deposit,
     * it will reset the account nonce (`frame_system::AccountNonce`).
     * 
     * The dispatch origin for this call is `root`.
     * 
     * # <weight>
     * - Independent of the arguments.
     * - Contains a limited number of reads and writes.
     * ---------------------
     * - Base Weight:
     *     - Creating: 27.56 µs
     *     - Killing: 35.11 µs
     * - DB Weight: 1 Read, 1 Write to `who`
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Balances.set_balance') === 'beb82909d38c015bc075ff8b107e47a02f8772bf5cf681d6cd84ef685e448a8f'
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     * also decrease the total issuance of the system (`TotalIssuance`).
     * If the new free or reserved balance is below the existential deposit,
     * it will reset the account nonce (`frame_system::AccountNonce`).
     * 
     * The dispatch origin for this call is `root`.
     * 
     * # <weight>
     * - Independent of the arguments.
     * - Contains a limited number of reads and writes.
     * ---------------------
     * - Base Weight:
     *     - Creating: 27.56 µs
     *     - Killing: 35.11 µs
     * - DB Weight: 1 Read, 1 Write to `who`
     * # </weight>
     */
    get asV9111(): {who: v9111.MultiAddress, newFree: bigint, newReserved: bigint} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer some liquid free balance to another account.
     * 
     *  `transfer` will set the `FreeBalance` of the sender and receiver.
     *  It will decrease the total issuance of the system by the `TransferFee`.
     *  If the sender's account is below the existential deposit as a result
     *  of the transfer, the account will be reaped.
     * 
     *  The dispatch origin for this call must be `Signed` by the transactor.
     * 
     *  # <weight>
     *  - Dependent on arguments but not critical, given proper implementations for
     *    input config types. See related functions below.
     *  - It contains a limited number of reads and writes internally and no complex computation.
     * 
     *  Related functions:
     * 
     *    - `ensure_can_withdraw` is always called internally but has a bounded complexity.
     *    - Transferring balances to accounts that did not exist before will cause
     *       `T::OnNewAccount::on_new_account` to be called.
     *    - Removing enough funds from an account will trigger
     *      `T::DustRemoval::on_unbalanced` and `T::OnFreeBalanceZero::on_free_balance_zero`.
     *    - `transfer_keep_alive` works the same way as `transfer`, but has an additional
     *      check that the transfer will not kill the origin account.
     * 
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Balances.transfer') === '5a96e49eaf0745110a2342c53e5619233745028a575c67865c4ad4921e77634b'
    }

    /**
     *  Transfer some liquid free balance to another account.
     * 
     *  `transfer` will set the `FreeBalance` of the sender and receiver.
     *  It will decrease the total issuance of the system by the `TransferFee`.
     *  If the sender's account is below the existential deposit as a result
     *  of the transfer, the account will be reaped.
     * 
     *  The dispatch origin for this call must be `Signed` by the transactor.
     * 
     *  # <weight>
     *  - Dependent on arguments but not critical, given proper implementations for
     *    input config types. See related functions below.
     *  - It contains a limited number of reads and writes internally and no complex computation.
     * 
     *  Related functions:
     * 
     *    - `ensure_can_withdraw` is always called internally but has a bounded complexity.
     *    - Transferring balances to accounts that did not exist before will cause
     *       `T::OnNewAccount::on_new_account` to be called.
     *    - Removing enough funds from an account will trigger
     *      `T::DustRemoval::on_unbalanced` and `T::OnFreeBalanceZero::on_free_balance_zero`.
     *    - `transfer_keep_alive` works the same way as `transfer`, but has an additional
     *      check that the transfer will not kill the origin account.
     * 
     *  # </weight>
     */
    get asV1020(): {dest: v1020.LookupSource, value: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Transfer some liquid free balance to another account.
     * 
     *  `transfer` will set the `FreeBalance` of the sender and receiver.
     *  It will decrease the total issuance of the system by the `TransferFee`.
     *  If the sender's account is below the existential deposit as a result
     *  of the transfer, the account will be reaped.
     * 
     *  The dispatch origin for this call must be `Signed` by the transactor.
     * 
     *  # <weight>
     *  - Dependent on arguments but not critical, given proper implementations for
     *    input config types. See related functions below.
     *  - It contains a limited number of reads and writes internally and no complex computation.
     * 
     *  Related functions:
     * 
     *    - `ensure_can_withdraw` is always called internally but has a bounded complexity.
     *    - Transferring balances to accounts that did not exist before will cause
     *       `T::OnNewAccount::on_new_account` to be called.
     *    - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
     *    - `transfer_keep_alive` works the same way as `transfer`, but has an additional
     *      check that the transfer will not kill the origin account.
     * 
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Balances.transfer') === 'cf5bb376709277883598390b3462e93b0f3c383df391c0649728c965e8da82fd'
    }

    /**
     *  Transfer some liquid free balance to another account.
     * 
     *  `transfer` will set the `FreeBalance` of the sender and receiver.
     *  It will decrease the total issuance of the system by the `TransferFee`.
     *  If the sender's account is below the existential deposit as a result
     *  of the transfer, the account will be reaped.
     * 
     *  The dispatch origin for this call must be `Signed` by the transactor.
     * 
     *  # <weight>
     *  - Dependent on arguments but not critical, given proper implementations for
     *    input config types. See related functions below.
     *  - It contains a limited number of reads and writes internally and no complex computation.
     * 
     *  Related functions:
     * 
     *    - `ensure_can_withdraw` is always called internally but has a bounded complexity.
     *    - Transferring balances to accounts that did not exist before will cause
     *       `T::OnNewAccount::on_new_account` to be called.
     *    - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
     *    - `transfer_keep_alive` works the same way as `transfer`, but has an additional
     *      check that the transfer will not kill the origin account.
     * 
     *  # </weight>
     */
    get asV1050(): {dest: Uint8Array, value: bigint} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Transfer some liquid free balance to another account.
     * 
     *  `transfer` will set the `FreeBalance` of the sender and receiver.
     *  It will decrease the total issuance of the system by the `TransferFee`.
     *  If the sender's account is below the existential deposit as a result
     *  of the transfer, the account will be reaped.
     * 
     *  The dispatch origin for this call must be `Signed` by the transactor.
     * 
     *  # <weight>
     *  - Dependent on arguments but not critical, given proper implementations for
     *    input config types. See related functions below.
     *  - It contains a limited number of reads and writes internally and no complex computation.
     * 
     *  Related functions:
     * 
     *    - `ensure_can_withdraw` is always called internally but has a bounded complexity.
     *    - Transferring balances to accounts that did not exist before will cause
     *       `T::OnNewAccount::on_new_account` to be called.
     *    - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
     *    - `transfer_keep_alive` works the same way as `transfer`, but has an additional
     *      check that the transfer will not kill the origin account.
     *  ---------------------------------
     *  - Base Weight: 73.64 µs, worst case scenario (account created, account removed)
     *  - DB Weight: 1 Read and 1 Write to destination account
     *  - Origin account is already in memory, so no DB operations for them.
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Balances.transfer') === 'c3f0f475940fc4bef49b298f76ba345680f20fc48d5899b4678314a07e2ce090'
    }

    /**
     *  Transfer some liquid free balance to another account.
     * 
     *  `transfer` will set the `FreeBalance` of the sender and receiver.
     *  It will decrease the total issuance of the system by the `TransferFee`.
     *  If the sender's account is below the existential deposit as a result
     *  of the transfer, the account will be reaped.
     * 
     *  The dispatch origin for this call must be `Signed` by the transactor.
     * 
     *  # <weight>
     *  - Dependent on arguments but not critical, given proper implementations for
     *    input config types. See related functions below.
     *  - It contains a limited number of reads and writes internally and no complex computation.
     * 
     *  Related functions:
     * 
     *    - `ensure_can_withdraw` is always called internally but has a bounded complexity.
     *    - Transferring balances to accounts that did not exist before will cause
     *       `T::OnNewAccount::on_new_account` to be called.
     *    - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
     *    - `transfer_keep_alive` works the same way as `transfer`, but has an additional
     *      check that the transfer will not kill the origin account.
     *  ---------------------------------
     *  - Base Weight: 73.64 µs, worst case scenario (account created, account removed)
     *  - DB Weight: 1 Read and 1 Write to destination account
     *  - Origin account is already in memory, so no DB operations for them.
     *  # </weight>
     */
    get asV2028(): {dest: v2028.LookupSource, value: bigint} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the `TransferFee`.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the transactor.
     * 
     * # <weight>
     * - Dependent on arguments but not critical, given proper implementations for input config
     *   types. See related functions below.
     * - It contains a limited number of reads and writes internally and no complex
     *   computation.
     * 
     * Related functions:
     * 
     *   - `ensure_can_withdraw` is always called internally but has a bounded complexity.
     *   - Transferring balances to accounts that did not exist before will cause
     *     `T::OnNewAccount::on_new_account` to be called.
     *   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
     *   - `transfer_keep_alive` works the same way as `transfer`, but has an additional check
     *     that the transfer will not kill the origin account.
     * ---------------------------------
     * - Base Weight: 73.64 µs, worst case scenario (account created, account removed)
     * - DB Weight: 1 Read and 1 Write to destination account
     * - Origin account is already in memory, so no DB operations for them.
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Balances.transfer') === 'fc85bea9d0d171982f66e8a55667d58dc9a1612bcafe84309942bf47e23e3094'
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * It will decrease the total issuance of the system by the `TransferFee`.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the transactor.
     * 
     * # <weight>
     * - Dependent on arguments but not critical, given proper implementations for input config
     *   types. See related functions below.
     * - It contains a limited number of reads and writes internally and no complex
     *   computation.
     * 
     * Related functions:
     * 
     *   - `ensure_can_withdraw` is always called internally but has a bounded complexity.
     *   - Transferring balances to accounts that did not exist before will cause
     *     `T::OnNewAccount::on_new_account` to be called.
     *   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
     *   - `transfer_keep_alive` works the same way as `transfer`, but has an additional check
     *     that the transfer will not kill the origin account.
     * ---------------------------------
     * - Base Weight: 73.64 µs, worst case scenario (account created, account removed)
     * - DB Weight: 1 Read and 1 Write to destination account
     * - Origin account is already in memory, so no DB operations for them.
     * # </weight>
     */
    get asV9111(): {dest: v9111.MultiAddress, value: bigint} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesTransferAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.transfer_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer the entire transferable balance from the caller account.
     * 
     *  NOTE: This function only attempts to transfer _transferable_ balances. This means that
     *  any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     *  transferred by this function. To ensure that this function results in a killed account,
     *  you might need to prepare the account by removing any reference counters, storage
     *  deposits, etc...
     * 
     *  The dispatch origin of this call must be Signed.
     * 
     *  - `dest`: The recipient of the transfer.
     *  - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     *    of the funds the account has, causing the sender account to be killed (false), or
     *    transfer everything except at least the existential deposit, which will guarantee to
     *    keep the sender account alive (true).
     *    # <weight>
     *  - O(1). Just like transfer, but reading the user's transferable balance first.
     *    #</weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Balances.transfer_all') === '56952003e07947f758a9928d8462037abffea6a7fa991c0d3451f5c47d45f254'
    }

    /**
     *  Transfer the entire transferable balance from the caller account.
     * 
     *  NOTE: This function only attempts to transfer _transferable_ balances. This means that
     *  any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     *  transferred by this function. To ensure that this function results in a killed account,
     *  you might need to prepare the account by removing any reference counters, storage
     *  deposits, etc...
     * 
     *  The dispatch origin of this call must be Signed.
     * 
     *  - `dest`: The recipient of the transfer.
     *  - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     *    of the funds the account has, causing the sender account to be killed (false), or
     *    transfer everything except at least the existential deposit, which will guarantee to
     *    keep the sender account alive (true).
     *    # <weight>
     *  - O(1). Just like transfer, but reading the user's transferable balance first.
     *    #</weight>
     */
    get asV9050(): {dest: v9050.LookupSource, keepAlive: boolean} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer the entire transferable balance from the caller account.
     * 
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     * 
     * The dispatch origin of this call must be Signed.
     * 
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     *   of the funds the account has, causing the sender account to be killed (false), or
     *   transfer everything except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true). # <weight>
     * - O(1). Just like transfer, but reading the user's transferable balance first.
     *   #</weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Balances.transfer_all') === '9c94c2ca9979f6551af6e123fb6b6ba14d026f862f9a023706f8f88c556b355f'
    }

    /**
     * Transfer the entire transferable balance from the caller account.
     * 
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     * 
     * The dispatch origin of this call must be Signed.
     * 
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     *   of the funds the account has, causing the sender account to be killed (false), or
     *   transfer everything except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true). # <weight>
     * - O(1). Just like transfer, but reading the user's transferable balance first.
     *   #</weight>
     */
    get asV9111(): {dest: v9111.MultiAddress, keepAlive: boolean} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class BalancesTransferKeepAliveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Balances.transfer_keep_alive')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Same as the [`transfer`] call, but with a check that the transfer will not kill the
     *  origin account.
     * 
     *  99% of the time you want [`transfer`] instead.
     * 
     *  [`transfer`]: struct.Module.html#method.transfer
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Balances.transfer_keep_alive') === '5a96e49eaf0745110a2342c53e5619233745028a575c67865c4ad4921e77634b'
    }

    /**
     *  Same as the [`transfer`] call, but with a check that the transfer will not kill the
     *  origin account.
     * 
     *  99% of the time you want [`transfer`] instead.
     * 
     *  [`transfer`]: struct.Module.html#method.transfer
     */
    get asV1020(): {dest: v1020.LookupSource, value: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Same as the [`transfer`] call, but with a check that the transfer will not kill the
     *  origin account.
     * 
     *  99% of the time you want [`transfer`] instead.
     * 
     *  [`transfer`]: struct.Module.html#method.transfer
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Balances.transfer_keep_alive') === 'cf5bb376709277883598390b3462e93b0f3c383df391c0649728c965e8da82fd'
    }

    /**
     *  Same as the [`transfer`] call, but with a check that the transfer will not kill the
     *  origin account.
     * 
     *  99% of the time you want [`transfer`] instead.
     * 
     *  [`transfer`]: struct.Module.html#method.transfer
     */
    get asV1050(): {dest: Uint8Array, value: bigint} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Same as the [`transfer`] call, but with a check that the transfer will not kill the
     *  origin account.
     * 
     *  99% of the time you want [`transfer`] instead.
     * 
     *  [`transfer`]: struct.Module.html#method.transfer
     *  # <weight>
     *  - Cheaper than transfer because account cannot be killed.
     *  - Base Weight: 51.4 µs
     *  - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)
     *  #</weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Balances.transfer_keep_alive') === 'c3f0f475940fc4bef49b298f76ba345680f20fc48d5899b4678314a07e2ce090'
    }

    /**
     *  Same as the [`transfer`] call, but with a check that the transfer will not kill the
     *  origin account.
     * 
     *  99% of the time you want [`transfer`] instead.
     * 
     *  [`transfer`]: struct.Module.html#method.transfer
     *  # <weight>
     *  - Cheaper than transfer because account cannot be killed.
     *  - Base Weight: 51.4 µs
     *  - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)
     *  #</weight>
     */
    get asV2028(): {dest: v2028.LookupSource, value: bigint} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer will not kill the
     * origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * [`transfer`]: struct.Pallet.html#method.transfer
     * # <weight>
     * - Cheaper than transfer because account cannot be killed.
     * - Base Weight: 51.4 µs
     * - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)
     * #</weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Balances.transfer_keep_alive') === 'fc85bea9d0d171982f66e8a55667d58dc9a1612bcafe84309942bf47e23e3094'
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer will not kill the
     * origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * [`transfer`]: struct.Pallet.html#method.transfer
     * # <weight>
     * - Cheaper than transfer because account cannot be killed.
     * - Base Weight: 51.4 µs
     * - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)
     * #</weight>
     */
    get asV9111(): {dest: v9111.MultiAddress, value: bigint} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesAcceptCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.accept_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Accept the curator role for a bounty.
     *  A deposit will be reserved from curator and refund upon successful payout.
     * 
     *  May only be called from the curator.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Bounties.accept_curator') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Accept the curator role for a bounty.
     *  A deposit will be reserved from curator and refund upon successful payout.
     * 
     *  May only be called from the curator.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV2028(): {bountyId: number} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesApproveBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.approve_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Approve a bounty proposal. At a later time, the bounty will be funded and become active
     *  and the original deposit will be returned.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Bounties.approve_bounty') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Approve a bounty proposal. At a later time, the bounty will be funded and become active
     *  and the original deposit will be returned.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV2028(): {bountyId: number} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesAwardBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.award_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Award bounty to a beneficiary account. The beneficiary will be able to claim the funds after a delay.
     * 
     *  The dispatch origin for this call must be the curator of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to award.
     *  - `beneficiary`: The beneficiary account whom will receive the payout.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Bounties.award_bounty') === 'd740fadb3b6bd5fcbc882e8a8741448f60283d3c52cc1fc64c08d97c4b7467ae'
    }

    /**
     *  Award bounty to a beneficiary account. The beneficiary will be able to claim the funds after a delay.
     * 
     *  The dispatch origin for this call must be the curator of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to award.
     *  - `beneficiary`: The beneficiary account whom will receive the payout.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV2028(): {bountyId: number, beneficiary: v2028.LookupSource} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
     * after a delay.
     * 
     * The dispatch origin for this call must be the curator of this bounty.
     * 
     * - `bounty_id`: Bounty ID to award.
     * - `beneficiary`: The beneficiary account whom will receive the payout.
     * 
     * # <weight>
     * - O(1).
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Bounties.award_bounty') === 'cfa73dafdcbe89b3b4e24bfc41cf4f3b1fcd9527b052ecc6549b6ac07b965606'
    }

    /**
     * Award bounty to a beneficiary account. The beneficiary will be able to claim the funds
     * after a delay.
     * 
     * The dispatch origin for this call must be the curator of this bounty.
     * 
     * - `bounty_id`: Bounty ID to award.
     * - `beneficiary`: The beneficiary account whom will receive the payout.
     * 
     * # <weight>
     * - O(1).
     * # </weight>
     */
    get asV9111(): {bountyId: number, beneficiary: v9111.MultiAddress} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesClaimBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.claim_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Claim the payout from an awarded bounty after payout delay.
     * 
     *  The dispatch origin for this call must be the beneficiary of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to claim.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Bounties.claim_bounty') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Claim the payout from an awarded bounty after payout delay.
     * 
     *  The dispatch origin for this call must be the beneficiary of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to claim.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV2028(): {bountyId: number} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesCloseBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.close_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel a proposed or active bounty. All the funds will be sent to treasury and
     *  the curator deposit will be unreserved if possible.
     * 
     *  Only `T::RejectOrigin` is able to cancel a bounty.
     * 
     *  - `bounty_id`: Bounty ID to cancel.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Bounties.close_bounty') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Cancel a proposed or active bounty. All the funds will be sent to treasury and
     *  the curator deposit will be unreserved if possible.
     * 
     *  Only `T::RejectOrigin` is able to cancel a bounty.
     * 
     *  - `bounty_id`: Bounty ID to cancel.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV2028(): {bountyId: number} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesExtendBountyExpiryCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.extend_bounty_expiry')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Extend the expiry time of an active bounty.
     * 
     *  The dispatch origin for this call must be the curator of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to extend.
     *  - `remark`: additional information.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Bounties.extend_bounty_expiry') === '710d6b76ffcee45bd9bffc1f299fa0b621450769559963379fa259c0f427f1bb'
    }

    /**
     *  Extend the expiry time of an active bounty.
     * 
     *  The dispatch origin for this call must be the curator of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to extend.
     *  - `remark`: additional information.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV2028(): {bountyId: number, remark: Uint8Array} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesProposeBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.propose_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Propose a new bounty.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     *  `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
     *  or slashed when rejected.
     * 
     *  - `curator`: The curator account whom will manage this bounty.
     *  - `fee`: The curator fee.
     *  - `value`: The total payment amount of this bounty, curator fee included.
     *  - `description`: The description of this bounty.
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Bounties.propose_bounty') === '6a012b4069a991972d0d3268cb20dfba3163919c325c7ebbe980b2dc15f1b1f5'
    }

    /**
     *  Propose a new bounty.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     *  `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
     *  or slashed when rejected.
     * 
     *  - `curator`: The curator account whom will manage this bounty.
     *  - `fee`: The curator fee.
     *  - `value`: The total payment amount of this bounty, curator fee included.
     *  - `description`: The description of this bounty.
     */
    get asV2028(): {value: bigint, description: Uint8Array} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesProposeCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.propose_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Assign a curator to a funded bounty.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Bounties.propose_curator') === '2496ed9b22c4f45280f8b1f616ce6e1fff5629ded2a6ed9237e80ab77e4bff2f'
    }

    /**
     *  Assign a curator to a funded bounty.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV2028(): {bountyId: number, curator: v2028.LookupSource, fee: bigint} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Assign a curator to a funded bounty.
     * 
     * May only be called from `T::ApproveOrigin`.
     * 
     * # <weight>
     * - O(1).
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Bounties.propose_curator') === 'db115713847ce9db3eac62037c4aefcca595bcd9aa876776d8fba64491d881d3'
    }

    /**
     * Assign a curator to a funded bounty.
     * 
     * May only be called from `T::ApproveOrigin`.
     * 
     * # <weight>
     * - O(1).
     * # </weight>
     */
    get asV9111(): {bountyId: number, curator: v9111.MultiAddress, fee: bigint} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class BountiesUnassignCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Bounties.unassign_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unassign curator from a bounty.
     * 
     *  This function can only be called by the `RejectOrigin` a signed origin.
     * 
     *  If this function is called by the `RejectOrigin`, we assume that the curator is malicious
     *  or inactive. As a result, we will slash the curator when possible.
     * 
     *  If the origin is the curator, we take this as a sign they are unable to do their job and
     *  they willingly give up. We could slash them, but for now we allow them to recover their
     *  deposit and exit without issue. (We may want to change this if it is abused.)
     * 
     *  Finally, the origin can be anyone if and only if the curator is "inactive". This allows
     *  anyone in the community to call out that a curator is not doing their due diligence, and
     *  we should pick a new curator. In this case the curator should also be slashed.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Bounties.unassign_curator') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Unassign curator from a bounty.
     * 
     *  This function can only be called by the `RejectOrigin` a signed origin.
     * 
     *  If this function is called by the `RejectOrigin`, we assume that the curator is malicious
     *  or inactive. As a result, we will slash the curator when possible.
     * 
     *  If the origin is the curator, we take this as a sign they are unable to do their job and
     *  they willingly give up. We could slash them, but for now we allow them to recover their
     *  deposit and exit without issue. (We may want to change this if it is abused.)
     * 
     *  Finally, the origin can be anyone if and only if the curator is "inactive". This allows
     *  anyone in the community to call out that a curator is not doing their due diligence, and
     *  we should pick a new curator. In this case the curator should also be slashed.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV2028(): {bountyId: number} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class ChildBountiesAcceptCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ChildBounties.accept_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Accept the curator role for the child-bounty.
     * 
     * The dispatch origin for this call must be the curator of this
     * child-bounty.
     * 
     * A deposit will be reserved from the curator and refund upon
     * successful payout or cancellation.
     * 
     * Fee for curator is deducted from curator fee of parent bounty.
     * 
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     * 
     * Child-bounty must be in "CuratorProposed" state, for processing the
     * call. And state of child-bounty is moved to "Active" on successful
     * call completion.
     * 
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('ChildBounties.accept_curator') === '3dca7b9fd6bc92337517a800e3ddd90a757f5b4e8ccfd63c20fde7d675eed25e'
    }

    /**
     * Accept the curator role for the child-bounty.
     * 
     * The dispatch origin for this call must be the curator of this
     * child-bounty.
     * 
     * A deposit will be reserved from the curator and refund upon
     * successful payout or cancellation.
     * 
     * Fee for curator is deducted from curator fee of parent bounty.
     * 
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     * 
     * Child-bounty must be in "CuratorProposed" state, for processing the
     * call. And state of child-bounty is moved to "Active" on successful
     * call completion.
     * 
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     */
    get asV9190(): {parentBountyId: number, childBountyId: number} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }
}

export class ChildBountiesAddChildBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ChildBounties.add_child_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add a new child-bounty.
     * 
     * The dispatch origin for this call must be the curator of parent
     * bounty and the parent bounty must be in "active" state.
     * 
     * Child-bounty gets added successfully & fund gets transferred from
     * parent bounty to child-bounty account, if parent bounty has enough
     * funds, else the call fails.
     * 
     * Upper bound to maximum number of active  child-bounties that can be
     * added are managed via runtime trait config
     * [`Config::MaxActiveChildBountyCount`].
     * 
     * If the call is success, the status of child-bounty is updated to
     * "Added".
     * 
     * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
     * - `value`: Value for executing the proposal.
     * - `description`: Text description for the child-bounty.
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('ChildBounties.add_child_bounty') === '9b64a969bb5d19a05e1a3105d04ed330d9a8ddbbbde926a9fd4d997acab9553a'
    }

    /**
     * Add a new child-bounty.
     * 
     * The dispatch origin for this call must be the curator of parent
     * bounty and the parent bounty must be in "active" state.
     * 
     * Child-bounty gets added successfully & fund gets transferred from
     * parent bounty to child-bounty account, if parent bounty has enough
     * funds, else the call fails.
     * 
     * Upper bound to maximum number of active  child-bounties that can be
     * added are managed via runtime trait config
     * [`Config::MaxActiveChildBountyCount`].
     * 
     * If the call is success, the status of child-bounty is updated to
     * "Added".
     * 
     * - `parent_bounty_id`: Index of parent bounty for which child-bounty is being added.
     * - `value`: Value for executing the proposal.
     * - `description`: Text description for the child-bounty.
     */
    get asV9190(): {parentBountyId: number, value: bigint, description: Uint8Array} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }
}

export class ChildBountiesAwardChildBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ChildBounties.award_child_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Award child-bounty to a beneficiary.
     * 
     * The beneficiary will be able to claim the funds after a delay.
     * 
     * The dispatch origin for this call must be the master curator or
     * curator of this child-bounty.
     * 
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     * 
     * Child-bounty must be in active state, for processing the call. And
     * state of child-bounty is moved to "PendingPayout" on successful call
     * completion.
     * 
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     * - `beneficiary`: Beneficiary account.
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('ChildBounties.award_child_bounty') === '21ccef873d503d210c4bdfa475a51fbd212513d7a7e99964ec19e6491df69e6b'
    }

    /**
     * Award child-bounty to a beneficiary.
     * 
     * The beneficiary will be able to claim the funds after a delay.
     * 
     * The dispatch origin for this call must be the master curator or
     * curator of this child-bounty.
     * 
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     * 
     * Child-bounty must be in active state, for processing the call. And
     * state of child-bounty is moved to "PendingPayout" on successful call
     * completion.
     * 
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     * - `beneficiary`: Beneficiary account.
     */
    get asV9190(): {parentBountyId: number, childBountyId: number, beneficiary: v9190.MultiAddress} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }
}

export class ChildBountiesClaimChildBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ChildBounties.claim_child_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Claim the payout from an awarded child-bounty after payout delay.
     * 
     * The dispatch origin for this call may be any signed origin.
     * 
     * Call works independent of parent bounty state, No need for parent
     * bounty to be in active state.
     * 
     * The Beneficiary is paid out with agreed bounty value. Curator fee is
     * paid & curator deposit is unreserved.
     * 
     * Child-bounty must be in "PendingPayout" state, for processing the
     * call. And instance of child-bounty is removed from the state on
     * successful call completion.
     * 
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('ChildBounties.claim_child_bounty') === '3dca7b9fd6bc92337517a800e3ddd90a757f5b4e8ccfd63c20fde7d675eed25e'
    }

    /**
     * Claim the payout from an awarded child-bounty after payout delay.
     * 
     * The dispatch origin for this call may be any signed origin.
     * 
     * Call works independent of parent bounty state, No need for parent
     * bounty to be in active state.
     * 
     * The Beneficiary is paid out with agreed bounty value. Curator fee is
     * paid & curator deposit is unreserved.
     * 
     * Child-bounty must be in "PendingPayout" state, for processing the
     * call. And instance of child-bounty is removed from the state on
     * successful call completion.
     * 
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     */
    get asV9190(): {parentBountyId: number, childBountyId: number} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }
}

export class ChildBountiesCloseChildBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ChildBounties.close_child_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel a proposed or active child-bounty. Child-bounty account funds
     * are transferred to parent bounty account. The child-bounty curator
     * deposit may be unreserved if possible.
     * 
     * The dispatch origin for this call must be either parent curator or
     * `T::RejectOrigin`.
     * 
     * If the state of child-bounty is `Active`, curator deposit is
     * unreserved.
     * 
     * If the state of child-bounty is `PendingPayout`, call fails &
     * returns `PendingPayout` error.
     * 
     * For the origin other than T::RejectOrigin, parent bounty must be in
     * active state, for this child-bounty call to work. For origin
     * T::RejectOrigin execution is forced.
     * 
     * Instance of child-bounty is removed from the state on successful
     * call completion.
     * 
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('ChildBounties.close_child_bounty') === '3dca7b9fd6bc92337517a800e3ddd90a757f5b4e8ccfd63c20fde7d675eed25e'
    }

    /**
     * Cancel a proposed or active child-bounty. Child-bounty account funds
     * are transferred to parent bounty account. The child-bounty curator
     * deposit may be unreserved if possible.
     * 
     * The dispatch origin for this call must be either parent curator or
     * `T::RejectOrigin`.
     * 
     * If the state of child-bounty is `Active`, curator deposit is
     * unreserved.
     * 
     * If the state of child-bounty is `PendingPayout`, call fails &
     * returns `PendingPayout` error.
     * 
     * For the origin other than T::RejectOrigin, parent bounty must be in
     * active state, for this child-bounty call to work. For origin
     * T::RejectOrigin execution is forced.
     * 
     * Instance of child-bounty is removed from the state on successful
     * call completion.
     * 
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     */
    get asV9190(): {parentBountyId: number, childBountyId: number} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }
}

export class ChildBountiesProposeCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ChildBounties.propose_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Propose curator for funded child-bounty.
     * 
     * The dispatch origin for this call must be curator of parent bounty.
     * 
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     * 
     * Child-bounty must be in "Added" state, for processing the call. And
     * state of child-bounty is moved to "CuratorProposed" on successful
     * call completion.
     * 
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     * - `curator`: Address of child-bounty curator.
     * - `fee`: payment fee to child-bounty curator for execution.
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('ChildBounties.propose_curator') === '09efda450821b39ea5773344d5f1bf8266853d4e7804037ae70b689acf2c9e80'
    }

    /**
     * Propose curator for funded child-bounty.
     * 
     * The dispatch origin for this call must be curator of parent bounty.
     * 
     * Parent bounty must be in active state, for this child-bounty call to
     * work.
     * 
     * Child-bounty must be in "Added" state, for processing the call. And
     * state of child-bounty is moved to "CuratorProposed" on successful
     * call completion.
     * 
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     * - `curator`: Address of child-bounty curator.
     * - `fee`: payment fee to child-bounty curator for execution.
     */
    get asV9190(): {parentBountyId: number, childBountyId: number, curator: v9190.MultiAddress, fee: bigint} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }
}

export class ChildBountiesUnassignCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ChildBounties.unassign_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unassign curator from a child-bounty.
     * 
     * The dispatch origin for this call can be either `RejectOrigin`, or
     * the curator of the parent bounty, or any signed origin.
     * 
     * For the origin other than T::RejectOrigin and the child-bounty
     * curator, parent-bounty must be in active state, for this call to
     * work. We allow child-bounty curator and T::RejectOrigin to execute
     * this call irrespective of the parent-bounty state.
     * 
     * If this function is called by the `RejectOrigin` or the
     * parent-bounty curator, we assume that the child-bounty curator is
     * malicious or inactive. As a result, child-bounty curator deposit is
     * slashed.
     * 
     * If the origin is the child-bounty curator, we take this as a sign
     * that they are unable to do their job, and are willingly giving up.
     * We could slash the deposit, but for now we allow them to unreserve
     * their deposit and exit without issue. (We may want to change this if
     * it is abused.)
     * 
     * Finally, the origin can be anyone iff the child-bounty curator is
     * "inactive". Expiry update due of parent bounty is used to estimate
     * inactive state of child-bounty curator.
     * 
     * This allows anyone in the community to call out that a child-bounty
     * curator is not doing their due diligence, and we should pick a new
     * one. In this case the child-bounty curator deposit is slashed.
     * 
     * State of child-bounty is moved to Added state on successful call
     * completion.
     * 
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('ChildBounties.unassign_curator') === '3dca7b9fd6bc92337517a800e3ddd90a757f5b4e8ccfd63c20fde7d675eed25e'
    }

    /**
     * Unassign curator from a child-bounty.
     * 
     * The dispatch origin for this call can be either `RejectOrigin`, or
     * the curator of the parent bounty, or any signed origin.
     * 
     * For the origin other than T::RejectOrigin and the child-bounty
     * curator, parent-bounty must be in active state, for this call to
     * work. We allow child-bounty curator and T::RejectOrigin to execute
     * this call irrespective of the parent-bounty state.
     * 
     * If this function is called by the `RejectOrigin` or the
     * parent-bounty curator, we assume that the child-bounty curator is
     * malicious or inactive. As a result, child-bounty curator deposit is
     * slashed.
     * 
     * If the origin is the child-bounty curator, we take this as a sign
     * that they are unable to do their job, and are willingly giving up.
     * We could slash the deposit, but for now we allow them to unreserve
     * their deposit and exit without issue. (We may want to change this if
     * it is abused.)
     * 
     * Finally, the origin can be anyone iff the child-bounty curator is
     * "inactive". Expiry update due of parent bounty is used to estimate
     * inactive state of child-bounty curator.
     * 
     * This allows anyone in the community to call out that a child-bounty
     * curator is not doing their due diligence, and we should pick a new
     * one. In this case the child-bounty curator deposit is slashed.
     * 
     * State of child-bounty is moved to Added state on successful call
     * completion.
     * 
     * - `parent_bounty_id`: Index of parent bounty.
     * - `child_bounty_id`: Index of child bounty.
     */
    get asV9190(): {parentBountyId: number, childBountyId: number} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsAttestCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.attest')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Attest to a statement, needed to finalize the claims process.
     * 
     *  WARNING: Insecure unless your chain includes `PrevalidateAttests` as a `SignedExtension`.
     * 
     *  Unsigned Validation:
     *  A call to attest is deemed valid if the sender has a `Preclaim` registered
     *  and provides a `statement` which is expected for the account.
     * 
     *  Parameters:
     *  - `statement`: The identity of the statement which is being attested to in the signature.
     * 
     *  <weight>
     *  Total Complexity: O(1)
     *  ----------------------------
     *  Base Weight: 93.3 µs
     *  DB Weight:
     *  - Read: Preclaims, Signing, Claims, Total, Claims Vesting, Vesting Vesting, Balance Lock, Account
     *  - Write: Vesting Vesting, Account, Balance Lock, Total, Claim, Claims Vesting, Signing, Preclaims
     *  Validate PreValidateAttests: +8.631 µs
     *  </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Claims.attest') === '110ca18454a6d22ce0d47f5b3af09a22580ef5eb8a4478c2c65f7982144f5c73'
    }

    /**
     *  Attest to a statement, needed to finalize the claims process.
     * 
     *  WARNING: Insecure unless your chain includes `PrevalidateAttests` as a `SignedExtension`.
     * 
     *  Unsigned Validation:
     *  A call to attest is deemed valid if the sender has a `Preclaim` registered
     *  and provides a `statement` which is expected for the account.
     * 
     *  Parameters:
     *  - `statement`: The identity of the statement which is being attested to in the signature.
     * 
     *  <weight>
     *  Total Complexity: O(1)
     *  ----------------------------
     *  Base Weight: 93.3 µs
     *  DB Weight:
     *  - Read: Preclaims, Signing, Claims, Total, Claims Vesting, Vesting Vesting, Balance Lock, Account
     *  - Write: Vesting Vesting, Account, Balance Lock, Total, Claim, Claims Vesting, Signing, Preclaims
     *  Validate PreValidateAttests: +8.631 µs
     *  </weight>
     */
    get asV2005(): {statement: Uint8Array} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.claim')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Make a claim.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Claims.claim') === '46f6fbe643b51ee7e3a08e102493b6291f118e76145971a19fb90446b9af7251'
    }

    /**
     *  Make a claim.
     */
    get asV1020(): {dest: Uint8Array, ethereumSignature: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsClaimAttestCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.claim_attest')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Make a claim to collect your DOTs by signing a statement.
     * 
     *  The dispatch origin for this call must be _None_.
     * 
     *  Unsigned Validation:
     *  A call to `claim_attest` is deemed valid if the signature provided matches
     *  the expected signed message of:
     * 
     *  > Ethereum Signed Message:
     *  > (configured prefix string)(address)(statement)
     * 
     *  and `address` matches the `dest` account; the `statement` must match that which is
     *  expected according to your purchase arrangement.
     * 
     *  Parameters:
     *  - `dest`: The destination account to payout the claim.
     *  - `ethereum_signature`: The signature of an ethereum signed message
     *     matching the format described above.
     *  - `statement`: The identity of the statement which is being attested to in the signature.
     * 
     *  <weight>
     *  The weight of this call is invariant over the input parameters.
     *  - One `eth_recover` operation which involves a keccak hash and a
     *    ecdsa recover.
     *  - Four storage reads to check if a claim exists for the user, to
     *    get the current pot size, to see if there exists a vesting schedule, to get the
     *    required statement.
     *  - Up to one storage write for adding a new vesting schedule.
     *  - One `deposit_creating` Currency call.
     *  - One storage write to update the total.
     *  - Two storage removals for vesting and claims information.
     *  - One deposit event.
     * 
     *  Total Complexity: O(1)
     *  ----------------------------
     *  Base Weight: 270.2 µs
     *  DB Weight:
     *  - Read: Signing, Claims, Total, Claims Vesting, Vesting Vesting, Balance Lock, Account
     *  - Write: Vesting Vesting, Account, Balance Lock, Total, Claim, Claims Vesting, Signing
     *  Validate Unsigned: +190.1 µs
     *  </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Claims.claim_attest') === 'de61f8dbba6a3bc8fcf3266422fc3463ad981e728b6ada5f53490d822a372fb9'
    }

    /**
     *  Make a claim to collect your DOTs by signing a statement.
     * 
     *  The dispatch origin for this call must be _None_.
     * 
     *  Unsigned Validation:
     *  A call to `claim_attest` is deemed valid if the signature provided matches
     *  the expected signed message of:
     * 
     *  > Ethereum Signed Message:
     *  > (configured prefix string)(address)(statement)
     * 
     *  and `address` matches the `dest` account; the `statement` must match that which is
     *  expected according to your purchase arrangement.
     * 
     *  Parameters:
     *  - `dest`: The destination account to payout the claim.
     *  - `ethereum_signature`: The signature of an ethereum signed message
     *     matching the format described above.
     *  - `statement`: The identity of the statement which is being attested to in the signature.
     * 
     *  <weight>
     *  The weight of this call is invariant over the input parameters.
     *  - One `eth_recover` operation which involves a keccak hash and a
     *    ecdsa recover.
     *  - Four storage reads to check if a claim exists for the user, to
     *    get the current pot size, to see if there exists a vesting schedule, to get the
     *    required statement.
     *  - Up to one storage write for adding a new vesting schedule.
     *  - One `deposit_creating` Currency call.
     *  - One storage write to update the total.
     *  - Two storage removals for vesting and claims information.
     *  - One deposit event.
     * 
     *  Total Complexity: O(1)
     *  ----------------------------
     *  Base Weight: 270.2 µs
     *  DB Weight:
     *  - Read: Signing, Claims, Total, Claims Vesting, Vesting Vesting, Balance Lock, Account
     *  - Write: Vesting Vesting, Account, Balance Lock, Total, Claim, Claims Vesting, Signing
     *  Validate Unsigned: +190.1 µs
     *  </weight>
     */
    get asV2005(): {dest: Uint8Array, ethereumSignature: Uint8Array, statement: Uint8Array} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsMintClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.mint_claim')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add a new claim, if you are root.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Claims.mint_claim') === 'bd93629e146aeda1b31bc7c1c194470feee46b9e4aed4d426ce152fe4c633fce'
    }

    /**
     *  Add a new claim, if you are root.
     */
    get asV1020(): {who: Uint8Array, value: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new claim, if you are root.
     */
    get isV1024(): boolean {
        return this._chain.getCallHash('Claims.mint_claim') === 'ec1e931adbe7d10ee0807f1cce6c19a1b6d7ed79f162daa9853d2ab62494d030'
    }

    /**
     *  Add a new claim, if you are root.
     */
    get asV1024(): {who: Uint8Array, value: bigint, vestingSchedule: ([bigint, bigint, number] | undefined)} {
        assert(this.isV1024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Mint a new claim to collect DOTs.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  Parameters:
     *  - `who`: The Ethereum address allowed to collect this claim.
     *  - `value`: The number of DOTs that will be claimed.
     *  - `vesting_schedule`: An optional vesting schedule for these DOTs.
     * 
     *  <weight>
     *  The weight of this call is invariant over the input parameters.
     *  - One storage mutate to increase the total claims available.
     *  - One storage write to add a new claim.
     *  - Up to one storage write to add a new vesting schedule.
     * 
     *  Total Complexity: O(1)
     *  ---------------------
     *  Base Weight: 10.46 µs
     *  DB Weight:
     *  - Reads: Total
     *  - Writes: Total, Claims
     *  - Maybe Write: Vesting, Statement
     *  </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Claims.mint_claim') === '63bb967752cf979f3cee14fba71b5a6c81590665d3b84d1ca8674865ec9104ff'
    }

    /**
     *  Mint a new claim to collect DOTs.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  Parameters:
     *  - `who`: The Ethereum address allowed to collect this claim.
     *  - `value`: The number of DOTs that will be claimed.
     *  - `vesting_schedule`: An optional vesting schedule for these DOTs.
     * 
     *  <weight>
     *  The weight of this call is invariant over the input parameters.
     *  - One storage mutate to increase the total claims available.
     *  - One storage write to add a new claim.
     *  - Up to one storage write to add a new vesting schedule.
     * 
     *  Total Complexity: O(1)
     *  ---------------------
     *  Base Weight: 10.46 µs
     *  DB Weight:
     *  - Reads: Total
     *  - Writes: Total, Claims
     *  - Maybe Write: Vesting, Statement
     *  </weight>
     */
    get asV2005(): {who: Uint8Array, value: bigint, vestingSchedule: ([bigint, bigint, number] | undefined), statement: (v2005.StatementKind | undefined)} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class ClaimsMoveClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Claims.move_claim')
        this._chain = ctx._chain
        this.call = call
    }

    get isV2007(): boolean {
        return this._chain.getCallHash('Claims.move_claim') === '141d7420c9fafec5c9c80590a2dc9e528311f92ec2465a0dfc29eb44c0c7f2c5'
    }

    get asV2007(): {old: Uint8Array, new: Uint8Array, maybePreclaim: (Uint8Array | undefined)} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetBypassConsistencyCheckCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_bypass_consistency_check')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Setting this to true will disable consistency checks for the configuration setters.
     * Use with caution.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Configuration.set_bypass_consistency_check') === 'd05b18ea2c0001429a8a368f643f1f81d54c8340ae4e7a6d0779f3174891b509'
    }

    /**
     * Setting this to true will disable consistency checks for the configuration setters.
     * Use with caution.
     */
    get asV9160(): {new: boolean} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetChainAvailabilityPeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_chain_availability_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the availability period for parachains.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_chain_availability_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the availability period for parachains.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetCodeRetentionPeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_code_retention_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the acceptance period for an included candidate.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_code_retention_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the acceptance period for an included candidate.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetDisputeConclusionByTimeOutPeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_dispute_conclusion_by_time_out_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the dispute conclusion by time out period.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_dispute_conclusion_by_time_out_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the dispute conclusion by time out period.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetDisputeMaxSpamSlotsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_dispute_max_spam_slots')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the maximum number of dispute spam slots.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_dispute_max_spam_slots') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the maximum number of dispute spam slots.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetDisputePeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_dispute_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the dispute period, in number of sessions to keep for disputes.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_dispute_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the dispute period, in number of sessions to keep for disputes.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetDisputePostConclusionAcceptancePeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_dispute_post_conclusion_acceptance_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the dispute post conclusion acceptance period.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_dispute_post_conclusion_acceptance_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the dispute post conclusion acceptance period.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetGroupRotationFrequencyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_group_rotation_frequency')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the parachain validator-group rotation frequency
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_group_rotation_frequency') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the parachain validator-group rotation frequency
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpChannelMaxCapacityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_channel_max_capacity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of messages allowed in an HRMP channel at once.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_channel_max_capacity') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of messages allowed in an HRMP channel at once.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpChannelMaxMessageSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_channel_max_message_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum size of a message that could ever be put into an HRMP channel.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_channel_max_message_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum size of a message that could ever be put into an HRMP channel.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpChannelMaxTotalSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_channel_max_total_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum total size of messages in bytes allowed in an HRMP channel at once.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_channel_max_total_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum total size of messages in bytes allowed in an HRMP channel at once.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpMaxMessageNumPerCandidateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_max_message_num_per_candidate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of outbound HRMP messages can be sent by a candidate.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_max_message_num_per_candidate') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of outbound HRMP messages can be sent by a candidate.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpMaxParachainInboundChannelsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_max_parachain_inbound_channels')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of inbound HRMP channels a parachain is allowed to accept.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_max_parachain_inbound_channels') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of inbound HRMP channels a parachain is allowed to accept.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpMaxParachainOutboundChannelsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_max_parachain_outbound_channels')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of outbound HRMP channels a parachain is allowed to open.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_max_parachain_outbound_channels') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of outbound HRMP channels a parachain is allowed to open.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpMaxParathreadInboundChannelsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_max_parathread_inbound_channels')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of inbound HRMP channels a parathread is allowed to accept.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_max_parathread_inbound_channels') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of inbound HRMP channels a parathread is allowed to accept.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpMaxParathreadOutboundChannelsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_max_parathread_outbound_channels')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of outbound HRMP channels a parathread is allowed to open.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_max_parathread_outbound_channels') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of outbound HRMP channels a parathread is allowed to open.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpOpenRequestTtlCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_open_request_ttl')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the number of sessions after which an HRMP open channel request expires.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_open_request_ttl') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the number of sessions after which an HRMP open channel request expires.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpRecipientDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_recipient_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the amount of funds that the recipient should provide for accepting opening an HRMP
     *  channel.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_recipient_deposit') === '86d3c70a5efeaca7d1a72b006ed6757b84fb71871eb54ca1d98d6a8fdeb79e3a'
    }

    /**
     *  Sets the amount of funds that the recipient should provide for accepting opening an HRMP
     *  channel.
     */
    get asV9090(): {new: bigint} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetHrmpSenderDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_hrmp_sender_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the amount of funds that the sender should provide for opening an HRMP channel.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_hrmp_sender_deposit') === '86d3c70a5efeaca7d1a72b006ed6757b84fb71871eb54ca1d98d6a8fdeb79e3a'
    }

    /**
     *  Sets the amount of funds that the sender should provide for opening an HRMP channel.
     */
    get asV9090(): {new: bigint} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxCodeSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_code_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the max validation code size for incoming upgrades.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_max_code_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the max validation code size for incoming upgrades.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxDownwardMessageSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_downward_message_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the critical downward message size.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_max_downward_message_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the critical downward message size.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxHeadDataSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_head_data_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the max head data size for paras.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_max_head_data_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the max head data size for paras.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxPovSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_pov_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the max POV block size for incoming upgrades.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_max_pov_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the max POV block size for incoming upgrades.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxUpwardMessageNumPerCandidateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_upward_message_num_per_candidate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of messages that a candidate can contain.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_max_upward_message_num_per_candidate') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of messages that a candidate can contain.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxUpwardMessageSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_upward_message_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum size of an upward message that can be sent by a candidate.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_max_upward_message_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum size of an upward message that can be sent by a candidate.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxUpwardQueueCountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_upward_queue_count')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum items that can present in a upward dispatch queue at once.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_max_upward_queue_count') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum items that can present in a upward dispatch queue at once.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxUpwardQueueSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_upward_queue_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum total size of items that can present in a upward dispatch queue at once.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_max_upward_queue_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum total size of items that can present in a upward dispatch queue at once.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxValidatorsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_validators')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the maximum number of validators to use in parachain consensus.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_max_validators') === 'b271d6a449f9641d900bc39e1a293351b09e8f890436186c9fc6db7592ba0967'
    }

    /**
     *  Set the maximum number of validators to use in parachain consensus.
     */
    get asV9090(): {new: (number | undefined)} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMaxValidatorsPerCoreCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_max_validators_per_core')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the maximum number of validators to assign to any core.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_max_validators_per_core') === 'b271d6a449f9641d900bc39e1a293351b09e8f890436186c9fc6db7592ba0967'
    }

    /**
     *  Set the maximum number of validators to assign to any core.
     */
    get asV9090(): {new: (number | undefined)} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetMinimumValidationUpgradeDelayCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_minimum_validation_upgrade_delay')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the minimum delay between announcing the upgrade block for a parachain until the
     * upgrade taking place.
     * 
     * See the field documentation for information and constraints for the new value.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Configuration.set_minimum_validation_upgrade_delay') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the minimum delay between announcing the upgrade block for a parachain until the
     * upgrade taking place.
     * 
     * See the field documentation for information and constraints for the new value.
     */
    get asV9160(): {new: number} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetNDelayTranchesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_n_delay_tranches')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the total number of delay tranches.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_n_delay_tranches') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the total number of delay tranches.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetNeededApprovalsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_needed_approvals')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the number of validators needed to approve a block.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_needed_approvals') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the number of validators needed to approve a block.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetNoShowSlotsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_no_show_slots')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the no show slots, in number of number of consensus slots.
     *  Must be at least 1.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_no_show_slots') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the no show slots, in number of number of consensus slots.
     *  Must be at least 1.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetParathreadCoresCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_parathread_cores')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the number of parathread execution cores.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_parathread_cores') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the number of parathread execution cores.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetParathreadRetriesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_parathread_retries')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the number of retries for a particular parathread.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_parathread_retries') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the number of retries for a particular parathread.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetPvfCheckingEnabledCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_pvf_checking_enabled')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Enable or disable PVF pre-checking. Consult the field documentation prior executing.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Configuration.set_pvf_checking_enabled') === 'd05b18ea2c0001429a8a368f643f1f81d54c8340ae4e7a6d0779f3174891b509'
    }

    /**
     * Enable or disable PVF pre-checking. Consult the field documentation prior executing.
     */
    get asV9160(): {new: boolean} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetPvfVotingTtlCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_pvf_voting_ttl')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the number of session changes after which a PVF pre-checking voting is rejected.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Configuration.set_pvf_voting_ttl') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the number of session changes after which a PVF pre-checking voting is rejected.
     */
    get asV9160(): {new: number} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetRelayVrfModuloSamplesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_relay_vrf_modulo_samples')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the number of samples to do of the `RelayVRFModulo` approval assignment criterion.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_relay_vrf_modulo_samples') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the number of samples to do of the `RelayVRFModulo` approval assignment criterion.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetSchedulingLookaheadCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_scheduling_lookahead')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the scheduling lookahead, in expected number of blocks at peak throughput.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_scheduling_lookahead') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the scheduling lookahead, in expected number of blocks at peak throughput.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetThreadAvailabilityPeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_thread_availability_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the availability period for parathreads.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_thread_availability_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the availability period for parathreads.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetUmpMaxIndividualWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_ump_max_individual_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum amount of weight any individual upward message may consume.
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Configuration.set_ump_max_individual_weight') === '8768ae636c927ffed8b3cb5f0df1e15afb0921835e5bc84b9495f4b39ea663b7'
    }

    /**
     *  Sets the maximum amount of weight any individual upward message may consume.
     */
    get asV9100(): {new: bigint} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Sets the maximum amount of weight any individual upward message may consume.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Configuration.set_ump_max_individual_weight') === 'ceb02ac7f45638dcb446470f1d43ad1d0dd56ac82f1a2cd9432b8e99555f672c'
    }

    /**
     * Sets the maximum amount of weight any individual upward message may consume.
     */
    get asV9291(): {new: v9291.Weight} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Sets the maximum amount of weight any individual upward message may consume.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Configuration.set_ump_max_individual_weight') === '75eef6f2cd3523e44f50db837d1610f4db03539037986ac2704c4a043d58ba81'
    }

    /**
     * Sets the maximum amount of weight any individual upward message may consume.
     */
    get asV9320(): {new: v9320.Weight} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetUmpServiceTotalWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_ump_service_total_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the soft limit for the phase of dispatching dispatchable upward messages.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_ump_service_total_weight') === '8768ae636c927ffed8b3cb5f0df1e15afb0921835e5bc84b9495f4b39ea663b7'
    }

    /**
     *  Sets the soft limit for the phase of dispatching dispatchable upward messages.
     */
    get asV9090(): {new: bigint} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Sets the soft limit for the phase of dispatching dispatchable upward messages.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Configuration.set_ump_service_total_weight') === 'ceb02ac7f45638dcb446470f1d43ad1d0dd56ac82f1a2cd9432b8e99555f672c'
    }

    /**
     * Sets the soft limit for the phase of dispatching dispatchable upward messages.
     */
    get asV9291(): {new: v9291.Weight} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Sets the soft limit for the phase of dispatching dispatchable upward messages.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Configuration.set_ump_service_total_weight') === '75eef6f2cd3523e44f50db837d1610f4db03539037986ac2704c4a043d58ba81'
    }

    /**
     * Sets the soft limit for the phase of dispatching dispatchable upward messages.
     */
    get asV9320(): {new: v9320.Weight} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetValidationUpgradeCooldownCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_validation_upgrade_cooldown')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the validation upgrade cooldown.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Configuration.set_validation_upgrade_cooldown') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Set the validation upgrade cooldown.
     */
    get asV9160(): {new: number} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetValidationUpgradeDelayCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_validation_upgrade_delay')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the validation upgrade delay.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_validation_upgrade_delay') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the validation upgrade delay.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetValidationUpgradeFrequencyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_validation_upgrade_frequency')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the validation upgrade frequency.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_validation_upgrade_frequency') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the validation upgrade frequency.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConfigurationSetZerothDelayTrancheWidthCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Configuration.set_zeroth_delay_tranche_width')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the zeroth delay tranche width.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Configuration.set_zeroth_delay_tranche_width') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the zeroth delay tranche width.
     */
    get asV9090(): {new: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ConvictionVotingDelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ConvictionVoting.delegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Delegate the voting power (with some given conviction) of the sending account for a
     * particular class of polls.
     * 
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     * 
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     *   - be delegating already; or
     *   - have no voting activity (if there is, then it will need to be removed/consolidated
     *     through `reap_vote` or `unvote`).
     * 
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
     *   to this function are required.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     *   account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     *   be more than the account's current balance.
     * 
     * Emits `Delegated`.
     * 
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     *   voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('ConvictionVoting.delegate') === '563d5eab734fe469b3fd1a773588895c1e243f7cab2958e6049514318be32953'
    }

    /**
     * Delegate the voting power (with some given conviction) of the sending account for a
     * particular class of polls.
     * 
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     * 
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     *   - be delegating already; or
     *   - have no voting activity (if there is, then it will need to be removed/consolidated
     *     through `reap_vote` or `unvote`).
     * 
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `class`: The class of polls to delegate. To delegate multiple classes, multiple calls
     *   to this function are required.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     *   account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     *   be more than the account's current balance.
     * 
     * Emits `Delegated`.
     * 
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     *   voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    get asV9320(): {class: number, to: v9320.MultiAddress, conviction: v9320.Conviction, balance: bigint} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ConvictionVotingRemoveOtherVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ConvictionVoting.remove_other_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a vote for a poll.
     * 
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     *   `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     * 
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('ConvictionVoting.remove_other_vote') === '852f4a0a1605e3f516a2a6871f4fb69a9ef09ca1678667ccfea4b04852621c76'
    }

    /**
     * Remove a vote for a poll.
     * 
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the poll was cancelled, because the voter lost the poll or
     * because the conviction period is over.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account of the vote to be removed; this account must have voted for poll
     *   `index`.
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: The class of the poll.
     * 
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get asV9320(): {target: v9320.MultiAddress, class: number, index: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ConvictionVotingRemoveVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ConvictionVoting.remove_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a vote for a poll.
     * 
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     *   - the vote of the account was in opposition to the result; or
     *   - there was no conviction to the account's vote; or
     *   - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     * 
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     * 
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     * 
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     *   which have finished or are cancelled, this must be `Some`.
     * 
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('ConvictionVoting.remove_vote') === 'be8a5ba82f77b6bda5e0784b678fdfe0fe9d28837d87406cb5d907269bb45b25'
    }

    /**
     * Remove a vote for a poll.
     * 
     * If:
     * - the poll was cancelled, or
     * - the poll is ongoing, or
     * - the poll has ended such that
     *   - the vote of the account was in opposition to the result; or
     *   - there was no conviction to the account's vote; or
     *   - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     * 
     * If, however, the poll has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     * 
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for poll `index`.
     * 
     * - `index`: The index of poll of the vote to be removed.
     * - `class`: Optional parameter, if given it indicates the class of the poll. For polls
     *   which have finished or are cancelled, this must be `Some`.
     * 
     * Weight: `O(R + log R)` where R is the number of polls that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get asV9320(): {class: (number | undefined), index: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ConvictionVotingUndelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ConvictionVoting.undelegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Undelegate the voting power of the sending account for a particular class of polls.
     * 
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued.
     * 
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     * 
     * - `class`: The class of polls to remove the delegation from.
     * 
     * Emits `Undelegated`.
     * 
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     *   voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('ConvictionVoting.undelegate') === '55363f75c61dc45265060eec3a1e578e86c93c9059f3f1b3d63fc1f2da6e7ea5'
    }

    /**
     * Undelegate the voting power of the sending account for a particular class of polls.
     * 
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued.
     * 
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     * 
     * - `class`: The class of polls to remove the delegation from.
     * 
     * Emits `Undelegated`.
     * 
     * Weight: `O(R)` where R is the number of polls the voter delegating to has
     *   voted on. Weight is initially charged as if maximum votes, but is refunded later.
     */
    get asV9320(): {class: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ConvictionVotingUnlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ConvictionVoting.unlock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the lock caused prior voting/delegating which has expired within a particluar
     * class.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     * 
     * Weight: `O(R)` with R number of vote of target.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('ConvictionVoting.unlock') === 'd0c817de5611525243564693dd06f5defa9929cf71d85585f26348b2a7e0ae97'
    }

    /**
     * Remove the lock caused prior voting/delegating which has expired within a particluar
     * class.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `class`: The class of polls to unlock.
     * - `target`: The account to remove the lock on.
     * 
     * Weight: `O(R)` with R number of vote of target.
     */
    get asV9320(): {class: number, target: v9320.MultiAddress} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ConvictionVotingVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ConvictionVoting.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     * 
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('ConvictionVoting.vote') === 'd10ef1b298a681ecd2445c4d8c083dbabfcf6f60a2f8103238e6ab7895b95b86'
    }

    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     * 
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     */
    get asV9320(): {pollIndex: number, vote: v9320.AccountVote} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     * 
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('ConvictionVoting.vote') === 'c659a6e0d84861cd97f11d84780117a5b61201e70e1e5533a740761dc9489558'
    }

    /**
     * Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `poll_index`: The index of the poll to vote for.
     * - `vote`: The vote configuration.
     * 
     * Weight: `O(R)` where R is the number of polls the voter has voted on.
     */
    get asV9340(): {pollIndex: number, vote: v9340.Type_144} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilCloseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.close')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  May be called by any signed account after the voting duration has ended in order to
     *  finish voting and close the proposal.
     * 
     *  Abstentions are counted as rejections unless there is a prime member set and the prime
     *  member cast an approval.
     * 
     *  - the weight of `proposal` preimage.
     *  - up to three events deposited.
     *  - one read, two removals, one mutation. (plus three static reads.)
     *  - computation and i/o `O(P + L + M)` where:
     *    - `M` is number of members,
     *    - `P` is number of active proposals,
     *    - `L` is the encoded length of `proposal` preimage.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Council.close') === 'fd20d3b556f7bbf9b7c10df80be10c41ffa28074b5360241d2572f30ee3e445e'
    }

    /**
     *  May be called by any signed account after the voting duration has ended in order to
     *  finish voting and close the proposal.
     * 
     *  Abstentions are counted as rejections unless there is a prime member set and the prime
     *  member cast an approval.
     * 
     *  - the weight of `proposal` preimage.
     *  - up to three events deposited.
     *  - one read, two removals, one mutation. (plus three static reads.)
     *  - computation and i/o `O(P + L + M)` where:
     *    - `M` is number of members,
     *    - `P` is number of active proposals,
     *    - `L` is the encoded length of `proposal` preimage.
     */
    get asV1050(): {proposal: Uint8Array, index: number} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     *  May be called by any signed account in order to finish voting and close the proposal.
     * 
     *  If called before the end of the voting period it will only close the vote if it is
     *  has enough votes to be approved or disapproved.
     * 
     *  If called after the end of the voting period abstentions are counted as rejections
     *  unless there is a prime member set and the prime member cast an approval.
     * 
     *  + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.
     *  + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     *                    `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1 + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - `P1` is the complexity of `proposal` preimage.
     *    - `P2` is proposal-count (code-bounded)
     *  - DB:
     *   - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *   - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)
     *   - any mutations done while executing `proposal` (`P1`)
     *  - up to 3 events
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Council.close') === '45a5978a11ceb5a8b2c51f7152abaa939cd8bd4bcdc5e1162029cedba4b598ea'
    }

    /**
     *  Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     *  May be called by any signed account in order to finish voting and close the proposal.
     * 
     *  If called before the end of the voting period it will only close the vote if it is
     *  has enough votes to be approved or disapproved.
     * 
     *  If called after the end of the voting period abstentions are counted as rejections
     *  unless there is a prime member set and the prime member cast an approval.
     * 
     *  + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.
     *  + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     *                    `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1 + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - `P1` is the complexity of `proposal` preimage.
     *    - `P2` is proposal-count (code-bounded)
     *  - DB:
     *   - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *   - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)
     *   - any mutations done while executing `proposal` (`P1`)
     *  - up to 3 events
     *  # </weight>
     */
    get asV2005(): {proposalHash: Uint8Array, index: number, proposalWeightBound: bigint, lengthBound: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Council.close') === '683905378cce329de8c5e9460bd36984188fb48a39207d985ea43cb10bd1eb81'
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get asV9291(): {proposalHash: Uint8Array, index: number, proposalWeightBound: bigint, lengthBound: number} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Council.close') === 'a88911953f51bddf0f0aeafa7caa7ca904d30cdb24f940ff177d2acf7088d3bd'
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get asV9320(): {proposalHash: Uint8Array, index: number, proposalWeightBound: v9320.Weight, lengthBound: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilCloseOldWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.close_old_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Council.close_old_weight') === '45a5978a11ceb5a8b2c51f7152abaa939cd8bd4bcdc5e1162029cedba4b598ea'
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get asV9320(): {proposalHash: Uint8Array, index: number, proposalWeightBound: bigint, lengthBound: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilDisapproveProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.disapprove_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Disapprove a proposal, close, and remove it from the system, regardless of its current state.
     * 
     *  Must be called by the Root origin.
     * 
     *  Parameters:
     *  * `proposal_hash`: The hash of the proposal that should be disapproved.
     * 
     *  # <weight>
     *  Complexity: O(P) where P is the number of max proposals
     *  Base Weight: .49 * P
     *  DB Weight:
     *  * Reads: Proposals
     *  * Writes: Voting, Proposals, ProposalOf
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Council.disapprove_proposal') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Disapprove a proposal, close, and remove it from the system, regardless of its current state.
     * 
     *  Must be called by the Root origin.
     * 
     *  Parameters:
     *  * `proposal_hash`: The hash of the proposal that should be disapproved.
     * 
     *  # <weight>
     *  Complexity: O(P) where P is the number of max proposals
     *  Base Weight: .49 * P
     *  DB Weight:
     *  * Reads: Proposals
     *  * Writes: Voting, Proposals, ProposalOf
     *  # </weight>
     */
    get asV2005(): {proposalHash: Uint8Array} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilExecuteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.execute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Council.execute') === 'd293bf72755f74e0a3c41405c24364f91ece4ae9f9232bac11a6f5affc83e757'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1020(): {proposal: v1020.Proposal} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Council.execute') === '8498bfdc84d1625d23edbd51ffcb13e409261b8fc8d521a5baf18e38a71d11bd'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1022(): {proposal: v1022.Proposal} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1024(): boolean {
        return this._chain.getCallHash('Council.execute') === 'a063f98c85fa3aa21741ef693e7db4691f62d07662dafe2cfcdf078fd1183eff'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1024(): {proposal: v1024.Proposal} {
        assert(this.isV1024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1027(): boolean {
        return this._chain.getCallHash('Council.execute') === '103c4ad4666083c5f76b2f94904c2baa1c2bf6791b8971bf7b5b6b11aa6ebfab'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1027(): {proposal: v1027.Proposal} {
        assert(this.isV1027)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1029(): boolean {
        return this._chain.getCallHash('Council.execute') === '8f21ad8522bbc5f1d4f24c87782bb355026326f8223cccbeebb869d83aea5b85'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1029(): {proposal: v1029.Proposal} {
        assert(this.isV1029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Council.execute') === '77c63f975f5c52c5687dae4c3c2fc5c50fca80036f94afdb29c46eca336016d5'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1030(): {proposal: v1030.Proposal} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1031(): boolean {
        return this._chain.getCallHash('Council.execute') === 'c019f5435be92b6c3c5aeb58c6fb52c15d46af90b84c35cb4058c97a3f185529'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1031(): {proposal: v1031.Proposal} {
        assert(this.isV1031)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1032(): boolean {
        return this._chain.getCallHash('Council.execute') === '83dba0323feced5fb65e2f27a5cbb59b6a2f25bc3a0c48894cb9758404fe7968'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1032(): {proposal: v1032.Proposal} {
        assert(this.isV1032)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('Council.execute') === 'abc3dca26b519e737066372b4701b35d06178df1e6817fcd308603f9f9981d27'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1038(): {proposal: v1038.Proposal} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1039(): boolean {
        return this._chain.getCallHash('Council.execute') === '61fc47099099d3379e246ea412b5feb511714e8a678be8e7b9e24a2de774725d'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1039(): {proposal: v1039.Proposal} {
        assert(this.isV1039)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Council.execute') === 'ea230917623dcc803b4d219f89a7bd6d823cfd79d0ee1d8cd6a1a8ca8bbfdfed'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1040(): {proposal: v1040.Proposal} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('Council.execute') === '0f592c1c871cb7fc886d43c723f368759280e5a052de98a40096a0597cf34f12'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1042(): {proposal: v1042.Proposal} {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Council.execute') === '15b95215355f7f34ae33745f598c387a1777391e8cbf8e7bd02b0660a63c66c7'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1050(): {proposal: v1050.Proposal} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1054(): boolean {
        return this._chain.getCallHash('Council.execute') === 'a86c1368b80f82d44ee1ebbb492e5293feb000bff5b32ad24f5c26d77057a539'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1054(): {proposal: v1054.Proposal} {
        assert(this.isV1054)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Council.execute') === '9e22cb75a4d5393444662e9a4e942e2ab55987ab5e252989c01b568c4bd74109'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1055(): {proposal: v1055.Proposal} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('Council.execute') === '8a0db224817dca4f0f13046927b7f87c45016d4da748016f536d2a2a1899bc56'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1058(): {proposal: v1058.Proposal} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1062(): boolean {
        return this._chain.getCallHash('Council.execute') === '8614694c9bfa8d1acc7375a4a0e16f756a192a1ece3799da4065f5e72b82e96b'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1062(): {proposal: v1062.Proposal} {
        assert(this.isV1062)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Council.execute') === 'a458cb574cf1d9cc0803104e1ca4f9380d67b4f8445191e6a4012f781605b15a'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2005(): {proposal: v2005.Proposal, lengthBound: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('Council.execute') === 'fbf4b1d601c522a0e36ac8fae3ce1d2df578b4a562fa505aa2a93a11dab6532a'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2007(): {proposal: v2007.Proposal, lengthBound: number} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Council.execute') === '40f6d8225192125c7d91a4bdb5dd49454bf91ac50421e32dd873bdb4acf6bbba'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2011(): {proposal: v2011.Proposal, lengthBound: number} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('Council.execute') === 'aa6eab46863da4f4a9b4b1e37a2a52d192696563013a8e13c695b08e9cf30e77'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2013(): {proposal: v2013.Proposal, lengthBound: number} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Council.execute') === '30017151b285b611e4242425e79c3758adbf0fff7fa580e0d5d7268c50dc27fb'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2015(): {proposal: v2015.Proposal, lengthBound: number} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('Council.execute') === '02ce2076feb62e6dc21a509e31b7ccaf5d44a2a39db203e3f2319528631443e9'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2022(): {proposal: v2022.Proposal, lengthBound: number} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Council.execute') === 'f46a3a2b6ddd28de79e6d129c654d456b3e1562d9452e4af2a7576fee30ca184'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2023(): {proposal: v2023.Proposal, lengthBound: number} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Council.execute') === 'fb31fdf1647e9c002f7fcc4121d45abea44505b3a5a48b6acafcfd34466e4920'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2024(): {proposal: v2024.Proposal, lengthBound: number} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Council.execute') === '4e98dfe08733f7543c42bc6c939fdfbc9a328d1c45ff30c60e75f9e1dd9f8dfb'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2025(): {proposal: v2025.Proposal, lengthBound: number} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Council.execute') === '85a9e0893c8558a38f60719d19c0e4240a6a3bbffaa6262f1da58e9b5101fa84'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2026(): {proposal: v2026.Proposal, lengthBound: number} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Council.execute') === '2da779f50394a5b3fe50376f509407030422e09390f8f5b5ced47a7950abdedc'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2028(): {proposal: v2028.Proposal, lengthBound: number} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Council.execute') === 'c4c44a2562f0f9fa441167e2b0acc08f50d21c8b1b72171b4f0fe79eebdc66ea'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2029(): {proposal: v2029.Proposal, lengthBound: number} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Council.execute') === 'f9d0a73d4ef17b0f75d455d944edcbed8d1027b7d147cc146745877b1fd6b099'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2030(): {proposal: v2030.Proposal, lengthBound: number} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Council.execute') === '7294d1c45e4f8896b7807aca5fabbbe261da58896bfab8239f1808866b91f5be'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9010(): {proposal: v9010.Proposal, lengthBound: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Council.execute') === 'bef0f01aca31de0fa2637790f0cda4144b314d53e017159c69f3301385084833'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9030(): {proposal: v9030.Proposal, lengthBound: number} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Council.execute') === '47011dd27a24a8cfa1287f2e276dd4c6f9a2b65f4e461278f1403d6df1754bb9'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9040(): {proposal: v9040.Proposal, lengthBound: number} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Council.execute') === '894f34477e8f37516ed613128f63ffcaf1f1b11c87f9b41615fd51b050037980'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9050(): {proposal: v9050.Proposal, lengthBound: number} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Council.execute') === '4f563ee3669dd563f135e9b6e425a078e3d5a813f60a564757b90063672d9309'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9080(): {proposal: v9080.Proposal, lengthBound: number} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Council.execute') === '60dcf6426c033719d13484747b16687ef11066fc415b4d5bbe21bad3a294535a'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9090(): {proposal: v9090.Proposal, lengthBound: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Council.execute') === '1cea735c8b9d18b31168c72901781f38bc6e93e1962e3dec4e3cfe8d7e6c2d90'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9100(): {proposal: v9100.Proposal, lengthBound: number} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Council.execute') === '6ea0aeb4746df6cf971cd3daa3308d0ae9c873b9642c1e08926900a90f2de1af'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9111(): {proposal: v9111.Call, lengthBound: number} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Council.execute') === '04664c341aecc03c7939cc84768c64dcd545e1d5277f6f8b2438cbcf098a7c70'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9122(): {proposal: v9122.Call, lengthBound: number} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Council.execute') === 'e731bfbe7a98093d91e1789d0969f1279046f02d7f3c13083a7591db3c4a581c'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9130(): {proposal: v9130.Call, lengthBound: number} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Council.execute') === 'c78119823f6fb94f49eebca2f9f892c3297144646e2a002f31c72cd7f2650f73'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9160(): {proposal: v9160.Call, lengthBound: number} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Council.execute') === 'fee3072f2f80e0b9f4997c37808ec64ac1528cd907b6ac3fbfbf02bf9dc0590f'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9170(): {proposal: v9170.Call, lengthBound: number} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Council.execute') === '12f769688e4882e2f9782debf5b29ed428b78eac264683ccf373bd781a49c82d'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9180(): {proposal: v9180.Call, lengthBound: number} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Council.execute') === 'b6d471ea5c241b983a0a0e6ed7225121c9257b38ee1e370dd86bd3afd59ef148'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9190(): {proposal: v9190.Call, lengthBound: number} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Council.execute') === '51454c962412d286c114ad11eb9d8059eeec294977285e508acf9c2413de48fe'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9220(): {proposal: v9220.Call, lengthBound: number} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Council.execute') === '6448117ca202ff3d8c91097dba8e20a3f10650fc7222efe203f9f15c5d0c1f9f'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9230(): {proposal: v9230.Call, lengthBound: number} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Council.execute') === '19b3887cab624d57389c8560c3901c5b9e956da8f3c405c30c8381d303a59c09'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9250(): {proposal: v9250.Call, lengthBound: number} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Council.execute') === '8a8d5d325384eee66d0fdd23ff058ff574f550de0cb07f33d190f37d596f5b82'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9271(): {proposal: v9271.Call, lengthBound: number} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Council.execute') === '2ae4824124910cb5d89e5f617ca87a763c5dfc3e44fef23506d7c5e5b171707e'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9291(): {proposal: v9291.Call, lengthBound: number} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Council.execute') === 'a695717a491a5cfe8b100d51a5eb5307234afcaba60440a290525ea938fb3f4b'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9300(): {proposal: v9300.Call, lengthBound: number} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Council.execute') === '29581b33367202e06895de163f76752c2c2f4ed6903da981903ea2e995db9caa'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9320(): {proposal: v9320.Call, lengthBound: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Council.execute') === 'b71ddcdda6fdbd88f8e13bb78a4a7e5bf555f6ba167c039677aacdb8f29d2fab'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9340(): {proposal: v9340.Call, lengthBound: number} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Council.execute') === '1aa6bf700a490e8b1941e0647c1c2643c2de2f958591b81369b2e16f3d511163'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9350(): {proposal: v9350.Call, lengthBound: number} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Council.execute') === '801aed297d7f67a9f5896061fe8366bdc91c6ec8aa4df7efe643a9a7a4981e8e'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9370(): {proposal: v9370.Call, lengthBound: number} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilProposeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.propose')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Council.propose') === 'b8ffa1d1417679324bb008beaf891bbac5aab9c65683a7f7fe19e5bd880540ad'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1020(): {threshold: number, proposal: v1020.Proposal} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Council.propose') === '0733f77354596f9c073a9166590f01875ae078ec750297178588ac18ebccfcd1'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1022(): {threshold: number, proposal: v1022.Proposal} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1024(): boolean {
        return this._chain.getCallHash('Council.propose') === 'f2373a84f143f19aa4ceb0f0ffa356d36e64a8ee8781cabbc4fd5bb7e39a1086'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1024(): {threshold: number, proposal: v1024.Proposal} {
        assert(this.isV1024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1027(): boolean {
        return this._chain.getCallHash('Council.propose') === '9740f05ac462f641fd3f66ba27922f4c616a30ba2a30f5f3dee3319b7e8d4c42'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1027(): {threshold: number, proposal: v1027.Proposal} {
        assert(this.isV1027)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1029(): boolean {
        return this._chain.getCallHash('Council.propose') === 'aa7229741a014afe80df7bace305287fba001ff889d95c8ef481eaf092b0aeb0'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1029(): {threshold: number, proposal: v1029.Proposal} {
        assert(this.isV1029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Council.propose') === 'bd750cd6777e89f5c24fa186b138a5167c0c5703bc2f880fb061d2ffcaac7485'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1030(): {threshold: number, proposal: v1030.Proposal} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1031(): boolean {
        return this._chain.getCallHash('Council.propose') === 'ab2408e2e9f60521f8ced9cfb8986b6b0a5224716ec6036b472bee571ffb20d3'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1031(): {threshold: number, proposal: v1031.Proposal} {
        assert(this.isV1031)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1032(): boolean {
        return this._chain.getCallHash('Council.propose') === '67c2fe1dfdbe4e0c3524f6bbdb5cfa78a3180250fdc9b90bd23d1d6fdd106170'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1032(): {threshold: number, proposal: v1032.Proposal} {
        assert(this.isV1032)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('Council.propose') === '34a8413001e080189c80438ed529b307dc454b4fff47f83a74fcce9abb0f16d8'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1038(): {threshold: number, proposal: v1038.Proposal} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1039(): boolean {
        return this._chain.getCallHash('Council.propose') === '6b5faf71789e3dff5d5ba6b345526dbd1c2008916dec8b4375a5ae8abd33a0ff'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1039(): {threshold: number, proposal: v1039.Proposal} {
        assert(this.isV1039)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Council.propose') === '2a426d9da44cb5bcab3c3334ae315836a9a46bbdffe0472c278b0ad2e7b65c47'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1040(): {threshold: number, proposal: v1040.Proposal} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('Council.propose') === '4dac6093a9fda8aa08e86a0a3d10b8bd4d7bed3ef08753c90140de37d5f804c3'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1042(): {threshold: number, proposal: v1042.Proposal} {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Council.propose') === '360d54bbd3add22d251b1e7b5a8159bf8b7805a44bad6ffc4f495ffb37a29aa3'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1050(): {threshold: number, proposal: v1050.Proposal} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1054(): boolean {
        return this._chain.getCallHash('Council.propose') === 'b7ed71d5de49cf512c52c5534643f51df2a0ed3e1ba35cb45f1302ca70d3d1dd'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1054(): {threshold: number, proposal: v1054.Proposal} {
        assert(this.isV1054)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Council.propose') === 'c9d83d3d10bfd5ef50ad610885c72863a5802065b8fd28a4f7c6c686932329f8'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1055(): {threshold: number, proposal: v1055.Proposal} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('Council.propose') === '39d267dc2baec569e413fbab4230df769aef9c59980ff208e266e1bac3c0ccb8'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1058(): {threshold: number, proposal: v1058.Proposal} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1062(): boolean {
        return this._chain.getCallHash('Council.propose') === 'f092bdb8159b1e16f939a8ac6bd7d66fd0b919a8097ab17e1e1352da914e8cf4'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1062(): {threshold: number, proposal: v1062.Proposal} {
        assert(this.isV1062)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Council.propose') === '0211294356c41641323a2e0eb77df577362fdde27f14467e1f5e1734c321fa6b'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2005(): {threshold: number, proposal: v2005.Proposal, lengthBound: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('Council.propose') === '093f0fb90388dac3b4c97ffbc60402f85ca2fc3e2be7f64b33707fe88c1483c0'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2007(): {threshold: number, proposal: v2007.Proposal, lengthBound: number} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Council.propose') === 'e5b4049febde77b7dbe5ae724daf9a70110572f324c6a957b78de0e7e7de5e87'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2011(): {threshold: number, proposal: v2011.Proposal, lengthBound: number} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('Council.propose') === '4571aa24bfc4fd4775b78411fc0a36c9a287df16903ce3cb30634c6ca1adebc8'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2013(): {threshold: number, proposal: v2013.Proposal, lengthBound: number} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Council.propose') === 'c28794823d43711b64190d421d876cfecc8e127458ff8c2eaa6f1e87ae7628f0'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2015(): {threshold: number, proposal: v2015.Proposal, lengthBound: number} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('Council.propose') === 'd180a7800b68f8cc27fbd9f0d24b640cb9ead8e9a7a7906eeab0cb3f45f80b14'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2022(): {threshold: number, proposal: v2022.Proposal, lengthBound: number} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Council.propose') === 'a899b60732f05ff785a2560ff27467fd3abb9c3e540fef09163d82c1e1aef31b'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2023(): {threshold: number, proposal: v2023.Proposal, lengthBound: number} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Council.propose') === '487809b0870920ea2d48c3504a542c83d3fdc91466937bec7aab15bacf5478b5'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2024(): {threshold: number, proposal: v2024.Proposal, lengthBound: number} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Council.propose') === 'ce4c6b7550cb4d0446071af036bf50d160c2249fd23acd5ced06da863357f1d4'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2025(): {threshold: number, proposal: v2025.Proposal, lengthBound: number} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Council.propose') === '4890b73ff8fb119cda121ce7f8be70e4e156edce353f9745720708758e7f018e'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2026(): {threshold: number, proposal: v2026.Proposal, lengthBound: number} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Council.propose') === 'e12119568ab0eb9e69e060fdd185f9a95183776fb763e4e5cef2f6e75df29978'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2028(): {threshold: number, proposal: v2028.Proposal, lengthBound: number} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Council.propose') === 'ac82f7f3517c6fa971647213b5e6d5141c270634845528a59a26ebdf75e662b8'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2029(): {threshold: number, proposal: v2029.Proposal, lengthBound: number} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Council.propose') === '4d17d810aa29765ae2f09fbf5194e0e89e8010bf502290d0415ca33d7002c971'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2030(): {threshold: number, proposal: v2030.Proposal, lengthBound: number} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Council.propose') === '46176c5c57d9b0009711479e5f95dccaaeed53bced22b5810c4b4fed0d1c57ac'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9010(): {threshold: number, proposal: v9010.Proposal, lengthBound: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Council.propose') === 'd8a670318591c03ccab97275e1b235ae9ea970b3a4178e63b1ae51c25fe6b9d9'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9030(): {threshold: number, proposal: v9030.Proposal, lengthBound: number} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Council.propose') === 'a25a8620dc53ceeb150c13a91ff242718de0c6c789b51a67c0dff0f0f2ea8086'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9040(): {threshold: number, proposal: v9040.Proposal, lengthBound: number} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Council.propose') === 'd314ccac1e5ba5752a74b24f613a8f1d639720e8c54e14fc72c9801862b77523'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9050(): {threshold: number, proposal: v9050.Proposal, lengthBound: number} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Council.propose') === '931f349041e9545a02a924f75dde7a551ae5c27e256f30a017e59918dbc5f590'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9080(): {threshold: number, proposal: v9080.Proposal, lengthBound: number} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Council.propose') === 'c3bf8fc02b712455b03d218f5a7c82ddfa3a1ba9ce90b3ac5e358d4ac38331e0'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9090(): {threshold: number, proposal: v9090.Proposal, lengthBound: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Council.propose') === 'c01ef6c0598d3165c9c4c86d63035adfa3458dbde434ce52c94b507f2ee10fdc'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9100(): {threshold: number, proposal: v9100.Proposal, lengthBound: number} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Council.propose') === '0c0257cda4b8453fb7606e6618e78afa7f767980399eda27db7479577baed06c'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9111(): {threshold: number, proposal: v9111.Call, lengthBound: number} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Council.propose') === '7acb9a65dea691f181c3406898de9c0b1376a3c3808b7a3463661b80c806db03'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9122(): {threshold: number, proposal: v9122.Call, lengthBound: number} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Council.propose') === 'faa84e3a68f0ba3cc1226056db374cbd0bb402fc12e1fd7355d7246f5b5f5290'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9130(): {threshold: number, proposal: v9130.Call, lengthBound: number} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Council.propose') === 'c4d5e6a24d87d13f39fe70614f1631f20cf6108f71d1bf193993ed81340e21c0'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9160(): {threshold: number, proposal: v9160.Call, lengthBound: number} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Council.propose') === 'a85430d1b6982cea0328c3f23342466a313eed3f7cb9078d2c66060ee1639bb5'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9170(): {threshold: number, proposal: v9170.Call, lengthBound: number} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Council.propose') === '4fe8c479e88f7b05ed10e25b2ff005138b6ba93f382c60a92dfcce703dfdefa3'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9180(): {threshold: number, proposal: v9180.Call, lengthBound: number} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Council.propose') === '2cad573db30e8e37e99e07e40b03c9b7ba7ebd10e2c47d081e2ba6a820f90a47'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9190(): {threshold: number, proposal: v9190.Call, lengthBound: number} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Council.propose') === '8ac7d297c3f78781aa250eb00585ddc0f3dfe25e4541faaaad85ea28d7b8b1e5'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9220(): {threshold: number, proposal: v9220.Call, lengthBound: number} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Council.propose') === '9e5016f74d7cc7b8cb97996b4134eecf5af38baab32cf3d5e1b6756ce93915a8'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9230(): {threshold: number, proposal: v9230.Call, lengthBound: number} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Council.propose') === '43e82fd1806795f866e4db0eaf6d16cfec23e0f6d8ef2115f93841e357ed02d9'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9250(): {threshold: number, proposal: v9250.Call, lengthBound: number} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Council.propose') === '5d00c76b3c55b81fcd856165e07529c0771418ae70fe8ff25877028f3b3cc4ab'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9271(): {threshold: number, proposal: v9271.Call, lengthBound: number} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Council.propose') === 'ad0813495d84c471e4f14492855dad7c377b8687ed5be0c9d1071d9b6c91860d'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9291(): {threshold: number, proposal: v9291.Call, lengthBound: number} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Council.propose') === 'c85d0cb8ba24bf2c879cec22c7b3d30f30d2d1771aaa03ae59a907a2acde9644'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9300(): {threshold: number, proposal: v9300.Call, lengthBound: number} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Council.propose') === '767d7e9520a1aabdd80e2ce3e71fecb78c5fa41461902130d69acbf4f4b6d9e6'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9320(): {threshold: number, proposal: v9320.Call, lengthBound: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Council.propose') === '6df14b1a9d6bad672da91dfa576a6017a3b9a3eefee3dbf83715e70e7ff3e309'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9340(): {threshold: number, proposal: v9340.Call, lengthBound: number} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Council.propose') === '546041b4a7d2787f39f47b6c5533e3f05829f3c58c33edc6b45cffe46ea9ace1'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9350(): {threshold: number, proposal: v9350.Call, lengthBound: number} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Council.propose') === '54b6347b1f98cfc052d855b25ddfb9b5f86c484cd2356ad3e5cd0319aa44c075'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9370(): {threshold: number, proposal: v9370.Call, lengthBound: number} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilSetMembersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.set_members')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the collective's membership manually to `new_members`. Be nice to the chain and
     *  provide it pre-sorted.
     * 
     *  Requires root origin.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Council.set_members') === '03fec7f5be686ca7cc3fd5b0b1c734db606d398a0df652a8f6616373ca22b16d'
    }

    /**
     *  Set the collective's membership manually to `new_members`. Be nice to the chain and
     *  provide it pre-sorted.
     * 
     *  Requires root origin.
     */
    get asV1020(): {newMembers: Uint8Array[]} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set the collective's membership.
     * 
     *  - `new_members`: The new member list. Be nice to the chain and
     *  - `prime`: The prime member whose vote sets the default.
     * 
     *  Requires root origin.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Council.set_members') === '02ef632f438c777250038911ea2704e117cd9e01f7dd93874a32d835cfbf2057'
    }

    /**
     *  Set the collective's membership.
     * 
     *  - `new_members`: The new member list. Be nice to the chain and
     *  - `prime`: The prime member whose vote sets the default.
     * 
     *  Requires root origin.
     */
    get asV1050(): {newMembers: Uint8Array[], prime: (Uint8Array | undefined)} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set the collective's membership.
     * 
     *  - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     *  - `prime`: The prime member whose vote sets the default.
     *  - `old_count`: The upper bound for the previous number of members in storage.
     *                 Used for weight estimation.
     * 
     *  Requires root origin.
     * 
     *  NOTE: Does not enforce the expected `MAX_MEMBERS` limit on the amount of members, but
     *        the weight estimations rely on it to estimate dispatchable weight.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(MP + N)` where:
     *    - `M` old-members-count (code- and governance-bounded)
     *    - `N` new-members-count (code- and governance-bounded)
     *    - `P` proposals-count (code-bounded)
     *  - DB:
     *    - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members
     *    - 1 storage read (codec `O(P)`) for reading the proposals
     *    - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
     *    - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Council.set_members') === '71b7fcb1d8a62eff96a9ef006517578ce9189e6d931948a256a04ca75ff68d4a'
    }

    /**
     *  Set the collective's membership.
     * 
     *  - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     *  - `prime`: The prime member whose vote sets the default.
     *  - `old_count`: The upper bound for the previous number of members in storage.
     *                 Used for weight estimation.
     * 
     *  Requires root origin.
     * 
     *  NOTE: Does not enforce the expected `MAX_MEMBERS` limit on the amount of members, but
     *        the weight estimations rely on it to estimate dispatchable weight.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(MP + N)` where:
     *    - `M` old-members-count (code- and governance-bounded)
     *    - `N` new-members-count (code- and governance-bounded)
     *    - `P` proposals-count (code-bounded)
     *  - DB:
     *    - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members
     *    - 1 storage read (codec `O(P)`) for reading the proposals
     *    - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
     *    - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
     *  # </weight>
     */
    get asV2005(): {newMembers: Uint8Array[], prime: (Uint8Array | undefined), oldCount: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class CouncilVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Council.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  # <weight>
     *  - Bounded storage read and writes.
     *  - Will be slightly heavier if the proposal is approved / disapproved after the vote.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Council.vote') === 'f8a1069a57f7b721f47c086d08b6838ae1a0c08f58caddb82428ba5f1407540f'
    }

    /**
     *  # <weight>
     *  - Bounded storage read and writes.
     *  - Will be slightly heavier if the proposal is approved / disapproved after the vote.
     *  # </weight>
     */
    get asV1020(): {proposal: Uint8Array, index: number, approve: boolean} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanAddMemoCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.add_memo')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add an optional memo to an existing crowdloan contribution.
     * 
     *  Origin must be Signed, and the user must have contributed to the crowdloan.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Crowdloan.add_memo') === 'd6cb52d8c86e57166a333b4d42b2009bcfa3453e4607b97f850eeb1a96f78389'
    }

    /**
     *  Add an optional memo to an existing crowdloan contribution.
     * 
     *  Origin must be Signed, and the user must have contributed to the crowdloan.
     */
    get asV9010(): {index: number, memo: Uint8Array} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanContributeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.contribute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Contribute to a crowd sale. This will transfer some balance over to fund a parachain
     *  slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Crowdloan.contribute') === 'c85a49d78a97667f6d8d7cdda206ad3ba38bd873ab2e82a42135a31c48152a6c'
    }

    /**
     *  Contribute to a crowd sale. This will transfer some balance over to fund a parachain
     *  slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
     */
    get asV9010(): {index: number, value: bigint, signature: (v9010.MultiSignature | undefined)} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanContributeAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.contribute_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Contribute your entire balance to a crowd sale. This will transfer the entire balance of a user over to fund a parachain
     * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Crowdloan.contribute_all') === '321aa21eccdd4e2a7dd0dbf8127848aa93dbaa207ef379b0f6f21d3d57327f71'
    }

    /**
     * Contribute your entire balance to a crowd sale. This will transfer the entire balance of a user over to fund a parachain
     * slot. It will be withdrawable when the crowdloan has ended and the funds are unused.
     */
    get asV9160(): {index: number, signature: (v9160.MultiSignature | undefined)} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanCreateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.create')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Create a new crowdloaning campaign for a parachain slot with the given lease period range.
     * 
     *  This applies a lock to your parachain configuration, ensuring that it cannot be changed
     *  by the parachain manager.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Crowdloan.create') === '9d0529ac9fb92b6a7eca157299243acd0d2eb82a352509475556c79f78f47aa3'
    }

    /**
     *  Create a new crowdloaning campaign for a parachain slot with the given lease period range.
     * 
     *  This applies a lock to your parachain configuration, ensuring that it cannot be changed
     *  by the parachain manager.
     */
    get asV9010(): {index: number, cap: bigint, firstPeriod: number, lastPeriod: number, end: number, verifier: (v9010.MultiSigner | undefined)} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanDissolveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.dissolve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a fund after the retirement period has ended and all funds have been returned.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Crowdloan.dissolve') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    /**
     *  Remove a fund after the retirement period has ended and all funds have been returned.
     */
    get asV9010(): {index: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanEditCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.edit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Edit the configuration for an in-progress crowdloan.
     * 
     *  Can only be called by Root origin.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Crowdloan.edit') === '9d0529ac9fb92b6a7eca157299243acd0d2eb82a352509475556c79f78f47aa3'
    }

    /**
     *  Edit the configuration for an in-progress crowdloan.
     * 
     *  Can only be called by Root origin.
     */
    get asV9010(): {index: number, cap: bigint, firstPeriod: number, lastPeriod: number, end: number, verifier: (v9010.MultiSigner | undefined)} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanPokeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.poke')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Poke the fund into NewRaise
     * 
     *  Origin must be Signed, and the fund has non-zero raise.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Crowdloan.poke') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     *  Poke the fund into NewRaise
     * 
     *  Origin must be Signed, and the fund has non-zero raise.
     */
    get asV9010(): {index: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanRefundCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.refund')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Automatically refund contributors of an ended crowdloan.
     *  Due to weight restrictions, this function may need to be called multiple
     *  times to fully refund all users. We will refund `RemoveKeysLimit` users at a time.
     * 
     *  Origin must be signed, but can come from anyone.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Crowdloan.refund') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    /**
     *  Automatically refund contributors of an ended crowdloan.
     *  Due to weight restrictions, this function may need to be called multiple
     *  times to fully refund all users. We will refund `RemoveKeysLimit` users at a time.
     * 
     *  Origin must be signed, but can come from anyone.
     */
    get asV9010(): {index: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class CrowdloanWithdrawCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Crowdloan.withdraw')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Withdraw full balance of a specific contributor.
     * 
     *  Origin must be signed, but can come from anyone.
     * 
     *  The fund must be either in, or ready for, retirement. For a fund to be *in* retirement, then the retirement
     *  flag must be set. For a fund to be ready for retirement, then:
     *  - it must not already be in retirement;
     *  - the amount of raised funds must be bigger than the _free_ balance of the account;
     *  - and either:
     *    - the block number must be at least `end`; or
     *    - the current lease period must be greater than the fund's `last_period`.
     * 
     *  In this case, the fund's retirement flag is set and its `end` is reset to the current block
     *  number.
     * 
     *  - `who`: The account whose contribution should be withdrawn.
     *  - `index`: The parachain to whose crowdloan the contribution was made.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Crowdloan.withdraw') === '02cd16eba62d1217d4cb6a31d6568e8ad8fdc99a88200e787453e7eba24cad9e'
    }

    /**
     *  Withdraw full balance of a specific contributor.
     * 
     *  Origin must be signed, but can come from anyone.
     * 
     *  The fund must be either in, or ready for, retirement. For a fund to be *in* retirement, then the retirement
     *  flag must be set. For a fund to be ready for retirement, then:
     *  - it must not already be in retirement;
     *  - the amount of raised funds must be bigger than the _free_ balance of the account;
     *  - and either:
     *    - the block number must be at least `end`; or
     *    - the current lease period must be greater than the fund's `last_period`.
     * 
     *  In this case, the fund's retirement flag is set and its `end` is reset to the current block
     *  number.
     * 
     *  - `who`: The account whose contribution should be withdrawn.
     *  - `index`: The parachain to whose crowdloan the contribution was made.
     */
    get asV9010(): {who: Uint8Array, index: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyActivateProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.activate_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Specify a proxy that is already open to us. Called by the stash.
     * 
     *  NOTE: Used to be called `set_proxy`.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `proxy`: The account that will be activated as proxy.
     * 
     *  # <weight>
     *  - One extra DB entry.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Democracy.activate_proxy') === 'fe013346080a3f49a16b6b1cbf1131446bdf3e43e05d0df93b3e1998ab56e194'
    }

    /**
     *  Specify a proxy that is already open to us. Called by the stash.
     * 
     *  NOTE: Used to be called `set_proxy`.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `proxy`: The account that will be activated as proxy.
     * 
     *  # <weight>
     *  - One extra DB entry.
     *  # </weight>
     */
    get asV1050(): {proxy: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyBlacklistCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.blacklist')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Permanently place a proposal into the blacklist. This prevents it from ever being
     *  proposed again.
     * 
     *  If called on a queued public or external proposal, then this will result in it being
     *  removed. If the `ref_index` supplied is an active referendum with the proposal hash,
     *  then it will be cancelled.
     * 
     *  The dispatch origin of this call must be `BlacklistOrigin`.
     * 
     *  - `proposal_hash`: The proposal hash to blacklist permanently.
     *  - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
     *  cancelled.
     * 
     *  Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
     *    reasonable value).
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Democracy.blacklist') === '8d8922c0775adfb1df719211ab4fc6fb40b6cc8864038bcb1b544d9cf039b30a'
    }

    /**
     *  Permanently place a proposal into the blacklist. This prevents it from ever being
     *  proposed again.
     * 
     *  If called on a queued public or external proposal, then this will result in it being
     *  removed. If the `ref_index` supplied is an active referendum with the proposal hash,
     *  then it will be cancelled.
     * 
     *  The dispatch origin of this call must be `BlacklistOrigin`.
     * 
     *  - `proposal_hash`: The proposal hash to blacklist permanently.
     *  - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
     *  cancelled.
     * 
     *  Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
     *    reasonable value).
     */
    get asV2025(): {proposalHash: Uint8Array, maybeRefIndex: (number | undefined)} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyCancelProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.cancel_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a proposal.
     * 
     *  The dispatch origin of this call must be `CancelProposalOrigin`.
     * 
     *  - `prop_index`: The index of the proposal to cancel.
     * 
     *  Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Democracy.cancel_proposal') === '0e50c7564a4a7f4e6a09a0abcc8022f4445c064144d2318ed086e6080bee800d'
    }

    /**
     *  Remove a proposal.
     * 
     *  The dispatch origin of this call must be `CancelProposalOrigin`.
     * 
     *  - `prop_index`: The index of the proposal to cancel.
     * 
     *  Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
     */
    get asV2025(): {propIndex: number} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyCancelQueuedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.cancel_queued')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel a proposal queued for enactment.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.cancel_queued') === 'b47f8ea6454f359c9660198c4a414af338ac9585c655566075a28e9141e57328'
    }

    /**
     *  Cancel a proposal queued for enactment.
     */
    get asV1020(): {when: number, which: number, what: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Cancel a proposal queued for enactment.
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Democracy.cancel_queued') === '60780274011857b5305b5413b2b4742e5d41eb58a0948049d0672e81af198cb7'
    }

    /**
     *  Cancel a proposal queued for enactment.
     */
    get asV1030(): {which: number} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyCancelReferendumCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.cancel_referendum')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a referendum.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.cancel_referendum') === 'efe4ecff834678ca8b73ea6e2f38e514997eb402e82da2ce4cf036008844a857'
    }

    /**
     *  Remove a referendum.
     */
    get asV1020(): {refIndex: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyClearPublicProposalsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.clear_public_proposals')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Veto and blacklist the proposal hash. Must be from Root origin.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Democracy.clear_public_proposals') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Veto and blacklist the proposal hash. Must be from Root origin.
     */
    get asV1022(): null {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyCloseProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.close_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Clear the proxy. Called by the proxy.
     * 
     *  NOTE: Used to be called `resign_proxy`.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  # <weight>
     *  - One DB clear.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Democracy.close_proxy') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Clear the proxy. Called by the proxy.
     * 
     *  NOTE: Used to be called `resign_proxy`.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  # <weight>
     *  - One DB clear.
     *  # </weight>
     */
    get asV1050(): null {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyDeactivateProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.deactivate_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Deactivate the proxy, but leave open to this account. Called by the stash.
     * 
     *  The proxy must already be active.
     * 
     *  NOTE: Used to be called `remove_proxy`.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `proxy`: The account that will be deactivated as proxy.
     * 
     *  # <weight>
     *  - One DB clear.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Democracy.deactivate_proxy') === 'fe013346080a3f49a16b6b1cbf1131446bdf3e43e05d0df93b3e1998ab56e194'
    }

    /**
     *  Deactivate the proxy, but leave open to this account. Called by the stash.
     * 
     *  The proxy must already be active.
     * 
     *  NOTE: Used to be called `remove_proxy`.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `proxy`: The account that will be deactivated as proxy.
     * 
     *  # <weight>
     *  - One DB clear.
     *  # </weight>
     */
    get asV1050(): {proxy: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyDelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.delegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Delegate vote.
     * 
     *  # <weight>
     *  - One extra DB entry.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.delegate') === 'd9417a632105aca765ccf10b89de97fe97492311af7c953010fed5edc4ea50ec'
    }

    /**
     *  Delegate vote.
     * 
     *  # <weight>
     *  - One extra DB entry.
     *  # </weight>
     */
    get asV1020(): {to: Uint8Array, conviction: v1020.Conviction} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Delegate the voting power (with some given conviction) of the sending account.
     * 
     *  The balance delegated is locked for as long as it's delegated, and thereafter for the
     *  time appropriate for the conviction's lock period.
     * 
     *  The dispatch origin of this call must be _Signed_, and the signing account must either:
     *    - be delegating already; or
     *    - have no voting activity (if there is, then it will need to be removed/consolidated
     *      through `reap_vote` or `unvote`).
     * 
     *  - `to`: The account whose voting the `target` account's voting power will follow.
     *  - `conviction`: The conviction that will be attached to the delegated votes. When the
     *    account is undelegated, the funds will be locked for the corresponding period.
     *  - `balance`: The amount of the account's balance to be used in delegating. This must
     *    not be more than the account's current balance.
     * 
     *  Emits `Delegated`.
     * 
     *  # <weight>
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Democracy.delegate') === '719d303e364256b757876a8d1b18c8d62a96223d68ffc6f6c1bf18240e8d9793'
    }

    /**
     *  Delegate the voting power (with some given conviction) of the sending account.
     * 
     *  The balance delegated is locked for as long as it's delegated, and thereafter for the
     *  time appropriate for the conviction's lock period.
     * 
     *  The dispatch origin of this call must be _Signed_, and the signing account must either:
     *    - be delegating already; or
     *    - have no voting activity (if there is, then it will need to be removed/consolidated
     *      through `reap_vote` or `unvote`).
     * 
     *  - `to`: The account whose voting the `target` account's voting power will follow.
     *  - `conviction`: The conviction that will be attached to the delegated votes. When the
     *    account is undelegated, the funds will be locked for the corresponding period.
     *  - `balance`: The amount of the account's balance to be used in delegating. This must
     *    not be more than the account's current balance.
     * 
     *  Emits `Delegated`.
     * 
     *  # <weight>
     *  # </weight>
     */
    get asV1055(): {to: Uint8Array, conviction: v1055.Conviction, balance: bigint} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Delegate the voting power (with some given conviction) of the sending account.
     * 
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     * 
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     *   - be delegating already; or
     *   - have no voting activity (if there is, then it will need to be removed/consolidated
     *     through `reap_vote` or `unvote`).
     * 
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     *   account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     *   be more than the account's current balance.
     * 
     * Emits `Delegated`.
     * 
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     *   voted on. Weight is charged as if maximum votes.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Democracy.delegate') === '789db36a1c43e1ffdad52288f8573a492f529890632f51821e7bd1d74ba6cffc'
    }

    /**
     * Delegate the voting power (with some given conviction) of the sending account.
     * 
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     * 
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     *   - be delegating already; or
     *   - have no voting activity (if there is, then it will need to be removed/consolidated
     *     through `reap_vote` or `unvote`).
     * 
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     *   account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     *   be more than the account's current balance.
     * 
     * Emits `Delegated`.
     * 
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     *   voted on. Weight is charged as if maximum votes.
     */
    get asV9291(): {to: v9291.MultiAddress, conviction: v9291.Conviction, balance: bigint} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyEmergencyCancelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.emergency_cancel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
     *  referendum.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.emergency_cancel') === '8a84371403a09e2f8fc2aac80f5a8a53229b346c4b3859069867b8e656b13450'
    }

    /**
     *  Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
     *  referendum.
     */
    get asV1020(): {refIndex: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyEnactProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.enact_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Enact a proposal from a referendum. For now we just make the weight be the maximum.
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('Democracy.enact_proposal') === 'de192ab0f058d1fb7eacc523bf0e05128d16509ec21bf445f0eefa47c89e60bf'
    }

    /**
     *  Enact a proposal from a referendum. For now we just make the weight be the maximum.
     */
    get asV1058(): {proposalHash: Uint8Array, index: number} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyExternalProposeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.external_propose')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule a referendum to be tabled once it is legal to schedule an external
     *  referendum.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.external_propose') === 'd293bf72755f74e0a3c41405c24364f91ece4ae9f9232bac11a6f5affc83e757'
    }

    /**
     *  Schedule a referendum to be tabled once it is legal to schedule an external
     *  referendum.
     */
    get asV1020(): {proposal: v1020.Proposal} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a referendum to be tabled once it is legal to schedule an external
     *  referendum.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Democracy.external_propose') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Schedule a referendum to be tabled once it is legal to schedule an external
     *  referendum.
     */
    get asV1022(): {proposalHash: Uint8Array} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a referendum to be tabled once it is legal to schedule an external
     * referendum.
     * 
     * The dispatch origin of this call must be `ExternalOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Democracy.external_propose') === 'e44fb402f80afe0e08cb6de5a4ed457a1a66e080379319fd281acd81eaf457ac'
    }

    /**
     * Schedule a referendum to be tabled once it is legal to schedule an external
     * referendum.
     * 
     * The dispatch origin of this call must be `ExternalOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     */
    get asV9320(): {proposal: v9320.Bounded} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyExternalProposeDefaultCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.external_propose_default')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     *  schedule an external referendum.
     * 
     *  Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     *  pre-scheduled `external_propose` call.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.external_propose_default') === 'd293bf72755f74e0a3c41405c24364f91ece4ae9f9232bac11a6f5affc83e757'
    }

    /**
     *  Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     *  schedule an external referendum.
     * 
     *  Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     *  pre-scheduled `external_propose` call.
     */
    get asV1020(): {proposal: v1020.Proposal} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     *  schedule an external referendum.
     * 
     *  Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     *  pre-scheduled `external_propose` call.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Democracy.external_propose_default') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     *  schedule an external referendum.
     * 
     *  Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     *  pre-scheduled `external_propose` call.
     */
    get asV1022(): {proposalHash: Uint8Array} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     * schedule an external referendum.
     * 
     * The dispatch of this call must be `ExternalDefaultOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     * 
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     * 
     * Weight: `O(1)`
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Democracy.external_propose_default') === 'e44fb402f80afe0e08cb6de5a4ed457a1a66e080379319fd281acd81eaf457ac'
    }

    /**
     * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     * schedule an external referendum.
     * 
     * The dispatch of this call must be `ExternalDefaultOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     * 
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     * 
     * Weight: `O(1)`
     */
    get asV9320(): {proposal: v9320.Bounded} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyExternalProposeMajorityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.external_propose_majority')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     *  an external referendum.
     * 
     *  Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     *  pre-scheduled `external_propose` call.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.external_propose_majority') === 'd293bf72755f74e0a3c41405c24364f91ece4ae9f9232bac11a6f5affc83e757'
    }

    /**
     *  Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     *  an external referendum.
     * 
     *  Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     *  pre-scheduled `external_propose` call.
     */
    get asV1020(): {proposal: v1020.Proposal} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     *  an external referendum.
     * 
     *  Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     *  pre-scheduled `external_propose` call.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Democracy.external_propose_majority') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     *  an external referendum.
     * 
     *  Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     *  pre-scheduled `external_propose` call.
     */
    get asV1022(): {proposalHash: Uint8Array} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     * an external referendum.
     * 
     * The dispatch of this call must be `ExternalMajorityOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     * 
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     * 
     * Weight: `O(1)`
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Democracy.external_propose_majority') === 'e44fb402f80afe0e08cb6de5a4ed457a1a66e080379319fd281acd81eaf457ac'
    }

    /**
     * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     * an external referendum.
     * 
     * The dispatch of this call must be `ExternalMajorityOrigin`.
     * 
     * - `proposal_hash`: The preimage hash of the proposal.
     * 
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     * 
     * Weight: `O(1)`
     */
    get asV9320(): {proposal: v9320.Bounded} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyFastTrackCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.fast_track')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule the currently externally-proposed majority-carries referendum to be tabled
     *  immediately. If there is no externally-proposed referendum currently, or if there is one
     *  but it is not a majority-carries referendum then it fails.
     * 
     *  - `proposal_hash`: The hash of the current external proposal.
     *  - `voting_period`: The period that is allowed for voting on this proposal. Increased to
     *    `EmergencyVotingPeriod` if too low.
     *  - `delay`: The number of block after voting has ended in approval and this should be
     *    enacted. This doesn't have a minimum amount.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.fast_track') === '27cb200e922e485b41e3150b3d7bf5e8624346f6ff1d78601373ba3d80689c89'
    }

    /**
     *  Schedule the currently externally-proposed majority-carries referendum to be tabled
     *  immediately. If there is no externally-proposed referendum currently, or if there is one
     *  but it is not a majority-carries referendum then it fails.
     * 
     *  - `proposal_hash`: The hash of the current external proposal.
     *  - `voting_period`: The period that is allowed for voting on this proposal. Increased to
     *    `EmergencyVotingPeriod` if too low.
     *  - `delay`: The number of block after voting has ended in approval and this should be
     *    enacted. This doesn't have a minimum amount.
     */
    get asV1020(): {proposalHash: Uint8Array, votingPeriod: number, delay: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyNoteImminentPreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.note_imminent_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register the preimage for an upcoming proposal. This requires the proposal to be
     *  in the dispatch queue. No deposit is needed.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Democracy.note_imminent_preimage') === 'e20578c0446b35dbd4ad86aca1c9ed88d1aea185102fee32cbba7639a06830df'
    }

    /**
     *  Register the preimage for an upcoming proposal. This requires the proposal to be
     *  in the dispatch queue. No deposit is needed.
     */
    get asV1022(): {encodedProposal: Uint8Array, when: number, which: number} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register the preimage for an upcoming proposal. This requires the proposal to be
     *  in the dispatch queue. No deposit is needed.
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Democracy.note_imminent_preimage') === 'bc60303cdd91077cf965a8aec4728ff7f49fea4055259a274e22145314e7c9eb'
    }

    /**
     *  Register the preimage for an upcoming proposal. This requires the proposal to be
     *  in the dispatch queue. No deposit is needed.
     */
    get asV1030(): {encodedProposal: Uint8Array} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyNoteImminentPreimageOperationalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.note_imminent_preimage_operational')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`.
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Democracy.note_imminent_preimage_operational') === 'bc60303cdd91077cf965a8aec4728ff7f49fea4055259a274e22145314e7c9eb'
    }

    /**
     *  Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`.
     */
    get asV2005(): {encodedProposal: Uint8Array} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyNotePreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.note_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register the preimage for an upcoming proposal. This doesn't require the proposal to be
     *  in the dispatch queue but does require a deposit, returned once enacted.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Democracy.note_preimage') === 'bc60303cdd91077cf965a8aec4728ff7f49fea4055259a274e22145314e7c9eb'
    }

    /**
     *  Register the preimage for an upcoming proposal. This doesn't require the proposal to be
     *  in the dispatch queue but does require a deposit, returned once enacted.
     */
    get asV1022(): {encodedProposal: Uint8Array} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyNotePreimageOperationalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.note_preimage_operational')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Same as `note_preimage` but origin is `OperationalPreimageOrigin`.
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Democracy.note_preimage_operational') === 'bc60303cdd91077cf965a8aec4728ff7f49fea4055259a274e22145314e7c9eb'
    }

    /**
     *  Same as `note_preimage` but origin is `OperationalPreimageOrigin`.
     */
    get asV2005(): {encodedProposal: Uint8Array} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyOpenProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.open_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Become a proxy.
     * 
     *  This must be called prior to a later `activate_proxy`.
     * 
     *  Origin must be a Signed.
     * 
     *  - `target`: The account whose votes will later be proxied.
     * 
     *  `close_proxy` must be called before the account can be destroyed.
     * 
     *  # <weight>
     *  - One extra DB entry.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Democracy.open_proxy') === '66d8abf7976ff596d8d614948b9d84cb24f0b898d88d24eb2cc035ae5e93c7b8'
    }

    /**
     *  Become a proxy.
     * 
     *  This must be called prior to a later `activate_proxy`.
     * 
     *  Origin must be a Signed.
     * 
     *  - `target`: The account whose votes will later be proxied.
     * 
     *  `close_proxy` must be called before the account can be destroyed.
     * 
     *  # <weight>
     *  - One extra DB entry.
     *  # </weight>
     */
    get asV1050(): {target: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyProposeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.propose')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Propose a sensitive action to be taken.
     * 
     *  # <weight>
     *  - O(1).
     *  - Two DB changes, one DB entry.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.propose') === '23c318c34e140d80e1d8ee8fec1cc739c1d3457677384a34d2d8ca2aa8298131'
    }

    /**
     *  Propose a sensitive action to be taken.
     * 
     *  # <weight>
     *  - O(1).
     *  - Two DB changes, one DB entry.
     *  # </weight>
     */
    get asV1020(): {proposal: v1020.Proposal, value: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Propose a sensitive action to be taken.
     * 
     *  # <weight>
     *  - O(1).
     *  - Two DB changes, one DB entry.
     *  # </weight>
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Democracy.propose') === '99f964e94c86db2029fab3e54a9230e36fe7533d252b5ecbc36f16c06e11f18b'
    }

    /**
     *  Propose a sensitive action to be taken.
     * 
     *  # <weight>
     *  - O(1).
     *  - Two DB changes, one DB entry.
     *  # </weight>
     */
    get asV1022(): {proposalHash: Uint8Array, value: bigint} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Propose a sensitive action to be taken.
     * 
     * The dispatch origin of this call must be _Signed_ and the sender must
     * have funds to cover the deposit.
     * 
     * - `proposal_hash`: The hash of the proposal preimage.
     * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
     * 
     * Emits `Proposed`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Democracy.propose') === 'db924825c9fd40cb04a839b510db55dcdd425c7b06116ccd22d4834d1201e8db'
    }

    /**
     * Propose a sensitive action to be taken.
     * 
     * The dispatch origin of this call must be _Signed_ and the sender must
     * have funds to cover the deposit.
     * 
     * - `proposal_hash`: The hash of the proposal preimage.
     * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
     * 
     * Emits `Proposed`.
     */
    get asV9320(): {proposal: v9320.Bounded, value: bigint} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyProxyDelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.proxy_delegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Delegate the voting power (with some given conviction) of a proxied account.
     * 
     *  The balance delegated is locked for as long as it's delegated, and thereafter for the
     *  time appropriate for the conviction's lock period.
     * 
     *  The dispatch origin of this call must be _Signed_, and the signing account must have
     *  been set as the proxy account for `target`.
     * 
     *  - `target`: The account whole voting power shall be delegated and whose balance locked.
     *    This account must either:
     *    - be delegating already; or
     *    - have no voting activity (if there is, then it will need to be removed/consolidated
     *      through `reap_vote` or `unvote`).
     *  - `to`: The account whose voting the `target` account's voting power will follow.
     *  - `conviction`: The conviction that will be attached to the delegated votes. When the
     *    account is undelegated, the funds will be locked for the corresponding period.
     *  - `balance`: The amount of the account's balance to be used in delegating. This must
     *    not be more than the account's current balance.
     * 
     *  Emits `Delegated`.
     * 
     *  # <weight>
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Democracy.proxy_delegate') === '719d303e364256b757876a8d1b18c8d62a96223d68ffc6f6c1bf18240e8d9793'
    }

    /**
     *  Delegate the voting power (with some given conviction) of a proxied account.
     * 
     *  The balance delegated is locked for as long as it's delegated, and thereafter for the
     *  time appropriate for the conviction's lock period.
     * 
     *  The dispatch origin of this call must be _Signed_, and the signing account must have
     *  been set as the proxy account for `target`.
     * 
     *  - `target`: The account whole voting power shall be delegated and whose balance locked.
     *    This account must either:
     *    - be delegating already; or
     *    - have no voting activity (if there is, then it will need to be removed/consolidated
     *      through `reap_vote` or `unvote`).
     *  - `to`: The account whose voting the `target` account's voting power will follow.
     *  - `conviction`: The conviction that will be attached to the delegated votes. When the
     *    account is undelegated, the funds will be locked for the corresponding period.
     *  - `balance`: The amount of the account's balance to be used in delegating. This must
     *    not be more than the account's current balance.
     * 
     *  Emits `Delegated`.
     * 
     *  # <weight>
     *  # </weight>
     */
    get asV1055(): {to: Uint8Array, conviction: v1055.Conviction, balance: bigint} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyProxyRemoveVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.proxy_remove_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a proxied vote for a referendum.
     * 
     *  Exactly equivalent to `remove_vote` except that it operates on the account that the
     *  sender is a proxy for.
     * 
     *  The dispatch origin of this call must be _Signed_ and the signing account must be a
     *  proxy for some other account which has a registered vote for the referendum of `index`.
     * 
     *  - `index`: The index of referendum of the vote to be removed.
     * 
     *  # <weight>
     *  - `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Democracy.proxy_remove_vote') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     *  Remove a proxied vote for a referendum.
     * 
     *  Exactly equivalent to `remove_vote` except that it operates on the account that the
     *  sender is a proxy for.
     * 
     *  The dispatch origin of this call must be _Signed_ and the signing account must be a
     *  proxy for some other account which has a registered vote for the referendum of `index`.
     * 
     *  - `index`: The index of referendum of the vote to be removed.
     * 
     *  # <weight>
     *  - `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *  # </weight>
     */
    get asV1055(): {index: number} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyProxyUndelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.proxy_undelegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Undelegate the voting power of a proxied account.
     * 
     *  Tokens may be unlocked following once an amount of time consistent with the lock period
     *  of the conviction with which the delegation was issued.
     * 
     *  The dispatch origin of this call must be _Signed_ and the signing account must be a
     *  proxy for some other account which is currently delegating.
     * 
     *  Emits `Undelegated`.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Democracy.proxy_undelegate') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Undelegate the voting power of a proxied account.
     * 
     *  Tokens may be unlocked following once an amount of time consistent with the lock period
     *  of the conviction with which the delegation was issued.
     * 
     *  The dispatch origin of this call must be _Signed_ and the signing account must be a
     *  proxy for some other account which is currently delegating.
     * 
     *  Emits `Undelegated`.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV1055(): null {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyProxyVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.proxy_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Vote in a referendum on behalf of a stash. If `vote.is_aye()`, the vote is to enact
     *  the proposal;  otherwise it is a vote to keep the status quo.
     * 
     *  # <weight>
     *  - O(1).
     *  - One DB change, one DB entry.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.proxy_vote') === '3a01fd8d5e95145a311b99cf21decce5be8578650f311f3a6091395407f5efe9'
    }

    /**
     *  Vote in a referendum on behalf of a stash. If `vote.is_aye()`, the vote is to enact
     *  the proposal;  otherwise it is a vote to keep the status quo.
     * 
     *  # <weight>
     *  - O(1).
     *  - One DB change, one DB entry.
     *  # </weight>
     */
    get asV1020(): {refIndex: number, vote: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Vote in a referendum on behalf of a stash. If `vote.is_aye()`, the vote is to enact
     *  the proposal; otherwise it is a vote to keep the status quo.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `ref_index`: The index of the referendum to proxy vote for.
     *  - `vote`: The vote configuration.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One DB change, one DB entry.
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Democracy.proxy_vote') === '6cdb35b5ffcb74405cdf222b0cc0bf7ad7025d59f676bea6712d77bcc9aff1db'
    }

    /**
     *  Vote in a referendum on behalf of a stash. If `vote.is_aye()`, the vote is to enact
     *  the proposal; otherwise it is a vote to keep the status quo.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `ref_index`: The index of the referendum to proxy vote for.
     *  - `vote`: The vote configuration.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One DB change, one DB entry.
     *  # </weight>
     */
    get asV1055(): {refIndex: number, vote: v1055.AccountVote} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyReapPreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.reap_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove an expired proposal preimage and collect the deposit.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Democracy.reap_preimage') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Remove an expired proposal preimage and collect the deposit.
     */
    get asV1022(): {proposalHash: Uint8Array} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Remove an expired proposal preimage and collect the deposit.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `proposal_hash`: The preimage hash of a proposal.
     *  - `proposal_length_upper_bound`: an upper bound on length of the proposal.
     *    Extrinsic is weighted according to this value with no refund.
     * 
     *  This will only work after `VotingPeriod` blocks from the time that the preimage was
     *  noted, if it's the same account doing it. If it's a different account, then it'll only
     *  work an additional `EnactmentPeriod` later.
     * 
     *  Emits `PreimageReaped`.
     * 
     *  # <weight>
     *  - Complexity: `O(D)` where D is length of proposal.
     *  - Db reads: `Preimages`
     *  - Db writes: `Preimages`
     *  - Base Weight: 39.31 + .003 * b µs
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Democracy.reap_preimage') === '23573ffc912e8a31889875352d3543e4538e2f3beb6a89ef86d10cf1cb8b7aca'
    }

    /**
     *  Remove an expired proposal preimage and collect the deposit.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `proposal_hash`: The preimage hash of a proposal.
     *  - `proposal_length_upper_bound`: an upper bound on length of the proposal.
     *    Extrinsic is weighted according to this value with no refund.
     * 
     *  This will only work after `VotingPeriod` blocks from the time that the preimage was
     *  noted, if it's the same account doing it. If it's a different account, then it'll only
     *  work an additional `EnactmentPeriod` later.
     * 
     *  Emits `PreimageReaped`.
     * 
     *  # <weight>
     *  - Complexity: `O(D)` where D is length of proposal.
     *  - Db reads: `Preimages`
     *  - Db writes: `Preimages`
     *  - Base Weight: 39.31 + .003 * b µs
     *  # </weight>
     */
    get asV2005(): {proposalHash: Uint8Array, proposalLenUpperBound: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyRemoveOtherVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.remove_other_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a vote for a referendum.
     * 
     *  If the `target` is equal to the signer, then this function is exactly equivalent to
     *  `remove_vote`. If not equal to the signer, then the vote must have expired,
     *  either because the referendum was cancelled, because the voter lost the referendum or
     *  because the conviction period is over.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `target`: The account of the vote to be removed; this account must have voted for
     *    referendum `index`.
     *  - `index`: The index of referendum of the vote to be removed.
     * 
     *  # <weight>
     *  - `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Democracy.remove_other_vote') === '57db819150acc73e380a9908a05d4f777cd3af825527d7ad88560426e1d0f652'
    }

    /**
     *  Remove a vote for a referendum.
     * 
     *  If the `target` is equal to the signer, then this function is exactly equivalent to
     *  `remove_vote`. If not equal to the signer, then the vote must have expired,
     *  either because the referendum was cancelled, because the voter lost the referendum or
     *  because the conviction period is over.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `target`: The account of the vote to be removed; this account must have voted for
     *    referendum `index`.
     *  - `index`: The index of referendum of the vote to be removed.
     * 
     *  # <weight>
     *  - `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *  # </weight>
     */
    get asV1055(): {target: Uint8Array, index: number} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove a vote for a referendum.
     * 
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the referendum was cancelled, because the voter lost the referendum or
     * because the conviction period is over.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account of the vote to be removed; this account must have voted for
     *   referendum `index`.
     * - `index`: The index of referendum of the vote to be removed.
     * 
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Democracy.remove_other_vote') === '43d317508cc3ba04dcadb411eb6499f25532d64ab5a169b27410116c72f40a26'
    }

    /**
     * Remove a vote for a referendum.
     * 
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the referendum was cancelled, because the voter lost the referendum or
     * because the conviction period is over.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account of the vote to be removed; this account must have voted for
     *   referendum `index`.
     * - `index`: The index of referendum of the vote to be removed.
     * 
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *   Weight is calculated for the maximum number of vote.
     */
    get asV9291(): {target: v9291.MultiAddress, index: number} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyRemoveProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.remove_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Clear the proxy. Called by the stash.
     * 
     *  # <weight>
     *  - One DB clear.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.remove_proxy') === 'fe013346080a3f49a16b6b1cbf1131446bdf3e43e05d0df93b3e1998ab56e194'
    }

    /**
     *  Clear the proxy. Called by the stash.
     * 
     *  # <weight>
     *  - One DB clear.
     *  # </weight>
     */
    get asV1020(): {proxy: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyRemoveVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.remove_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a vote for a referendum.
     * 
     *  If:
     *  - the referendum was cancelled, or
     *  - the referendum is ongoing, or
     *  - the referendum has ended such that
     *    - the vote of the account was in opposition to the result; or
     *    - there was no conviction to the account's vote; or
     *    - the account made a split vote
     *  ...then the vote is removed cleanly and a following call to `unlock` may result in more
     *  funds being available.
     * 
     *  If, however, the referendum has ended and:
     *  - it finished corresponding to the vote of the account, and
     *  - the account made a standard vote with conviction, and
     *  - the lock period of the conviction is not over
     *  ...then the lock will be aggregated into the overall account's lock, which may involve
     *  *overlocking* (where the two locks are combined into a single lock that is the maximum
     *  of both the amount locked and the time is it locked for).
     * 
     *  The dispatch origin of this call must be _Signed_, and the signer must have a vote
     *  registered for referendum `index`.
     * 
     *  - `index`: The index of referendum of the vote to be removed.
     * 
     *  # <weight>
     *  - `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Democracy.remove_vote') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     *  Remove a vote for a referendum.
     * 
     *  If:
     *  - the referendum was cancelled, or
     *  - the referendum is ongoing, or
     *  - the referendum has ended such that
     *    - the vote of the account was in opposition to the result; or
     *    - there was no conviction to the account's vote; or
     *    - the account made a split vote
     *  ...then the vote is removed cleanly and a following call to `unlock` may result in more
     *  funds being available.
     * 
     *  If, however, the referendum has ended and:
     *  - it finished corresponding to the vote of the account, and
     *  - the account made a standard vote with conviction, and
     *  - the lock period of the conviction is not over
     *  ...then the lock will be aggregated into the overall account's lock, which may involve
     *  *overlocking* (where the two locks are combined into a single lock that is the maximum
     *  of both the amount locked and the time is it locked for).
     * 
     *  The dispatch origin of this call must be _Signed_, and the signer must have a vote
     *  registered for referendum `index`.
     * 
     *  - `index`: The index of referendum of the vote to be removed.
     * 
     *  # <weight>
     *  - `O(R + log R)` where R is the number of referenda that `target` has voted on.
     *  # </weight>
     */
    get asV1055(): {index: number} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyResignProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.resign_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Clear the proxy. Called by the proxy.
     * 
     *  # <weight>
     *  - One DB clear.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.resign_proxy') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Clear the proxy. Called by the proxy.
     * 
     *  # <weight>
     *  - One DB clear.
     *  # </weight>
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracySecondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.second')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Propose a sensitive action to be taken.
     * 
     *  # <weight>
     *  - O(1).
     *  - One DB entry.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.second') === '7ac80a800d6686f21181e7b5b45c8949dc5b807bc6ec111188c7c6850a21b898'
    }

    /**
     *  Propose a sensitive action to be taken.
     * 
     *  # <weight>
     *  - O(1).
     *  - One DB entry.
     *  # </weight>
     */
    get asV1020(): {proposal: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Signals agreement with a particular proposal.
     * 
     *  The dispatch origin of this call must be _Signed_ and the sender
     *  must have funds to cover the deposit, equal to the original deposit.
     * 
     *  - `proposal`: The index of the proposal to second.
     *  - `seconds_upper_bound`: an upper bound on the current number of seconds on this
     *    proposal. Extrinsic is weighted according to this value with no refund.
     * 
     *  # <weight>
     *  - Complexity: `O(S)` where S is the number of seconds a proposal already has.
     *  - Db reads: `DepositOf`
     *  - Db writes: `DepositOf`
     *  ---------
     *  - Base Weight: 22.28 + .229 * S µs
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Democracy.second') === 'abe1357aae784eefd21f6999076deb6cfbc92fcb9e80c21e93a944ceb739423c'
    }

    /**
     *  Signals agreement with a particular proposal.
     * 
     *  The dispatch origin of this call must be _Signed_ and the sender
     *  must have funds to cover the deposit, equal to the original deposit.
     * 
     *  - `proposal`: The index of the proposal to second.
     *  - `seconds_upper_bound`: an upper bound on the current number of seconds on this
     *    proposal. Extrinsic is weighted according to this value with no refund.
     * 
     *  # <weight>
     *  - Complexity: `O(S)` where S is the number of seconds a proposal already has.
     *  - Db reads: `DepositOf`
     *  - Db writes: `DepositOf`
     *  ---------
     *  - Base Weight: 22.28 + .229 * S µs
     *  # </weight>
     */
    get asV2005(): {proposal: number, secondsUpperBound: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Signals agreement with a particular proposal.
     * 
     * The dispatch origin of this call must be _Signed_ and the sender
     * must have funds to cover the deposit, equal to the original deposit.
     * 
     * - `proposal`: The index of the proposal to second.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Democracy.second') === '7ac80a800d6686f21181e7b5b45c8949dc5b807bc6ec111188c7c6850a21b898'
    }

    /**
     * Signals agreement with a particular proposal.
     * 
     * The dispatch origin of this call must be _Signed_ and the sender
     * must have funds to cover the deposit, equal to the original deposit.
     * 
     * - `proposal`: The index of the proposal to second.
     */
    get asV9320(): {proposal: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracySetProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.set_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Specify a proxy. Called by the stash.
     * 
     *  # <weight>
     *  - One extra DB entry.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.set_proxy') === 'fe013346080a3f49a16b6b1cbf1131446bdf3e43e05d0df93b3e1998ab56e194'
    }

    /**
     *  Specify a proxy. Called by the stash.
     * 
     *  # <weight>
     *  - One extra DB entry.
     *  # </weight>
     */
    get asV1020(): {proxy: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyUndelegateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.undelegate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Undelegate vote.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.undelegate') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Undelegate vote.
     * 
     *  # <weight>
     *  - O(1).
     *  # </weight>
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyUnlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.unlock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unlock tokens that have an expired lock.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `target`: The account to remove the lock on.
     * 
     *  Emits `Unlocked`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Democracy.unlock') === '66d8abf7976ff596d8d614948b9d84cb24f0b898d88d24eb2cc035ae5e93c7b8'
    }

    /**
     *  Unlock tokens that have an expired lock.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `target`: The account to remove the lock on.
     * 
     *  Emits `Unlocked`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  # </weight>
     */
    get asV1050(): {target: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Unlock tokens that have an expired lock.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account to remove the lock on.
     * 
     * Weight: `O(R)` with R number of vote of target.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Democracy.unlock') === '8142da248a3023c20f65ce8f6287f9eaf75336ab8815cb15537149abcdd0c20c'
    }

    /**
     * Unlock tokens that have an expired lock.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `target`: The account to remove the lock on.
     * 
     * Weight: `O(R)` with R number of vote of target.
     */
    get asV9291(): {target: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyVetoExternalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.veto_external')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Veto and blacklist the external proposal hash.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.veto_external') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Veto and blacklist the external proposal hash.
     */
    get asV1020(): {proposalHash: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class DemocracyVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Democracy.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     *  otherwise it is a vote to keep the status quo.
     * 
     *  # <weight>
     *  - O(1).
     *  - One DB change, one DB entry.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Democracy.vote') === '3a01fd8d5e95145a311b99cf21decce5be8578650f311f3a6091395407f5efe9'
    }

    /**
     *  Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     *  otherwise it is a vote to keep the status quo.
     * 
     *  # <weight>
     *  - O(1).
     *  - One DB change, one DB entry.
     *  # </weight>
     */
    get asV1020(): {refIndex: number, vote: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     *  otherwise it is a vote to keep the status quo.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `ref_index`: The index of the referendum to vote for.
     *  - `vote`: The vote configuration.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One DB change, one DB entry.
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Democracy.vote') === '6cdb35b5ffcb74405cdf222b0cc0bf7ad7025d59f676bea6712d77bcc9aff1db'
    }

    /**
     *  Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     *  otherwise it is a vote to keep the status quo.
     * 
     *  The dispatch origin of this call must be _Signed_.
     * 
     *  - `ref_index`: The index of the referendum to vote for.
     *  - `vote`: The vote configuration.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One DB change, one DB entry.
     *  # </weight>
     */
    get asV1055(): {refIndex: number, vote: v1055.AccountVote} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `ref_index`: The index of the referendum to vote for.
     * - `vote`: The vote configuration.
     * 
     * Weight: `O(R)` where R is the number of referendums the voter has voted on.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Democracy.vote') === '3936a4cb49f77280bd94142d4ec458afcf5cb8a5e5b0d602b1b1530928021e28'
    }

    /**
     * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     * 
     * The dispatch origin of this call must be _Signed_.
     * 
     * - `ref_index`: The index of the referendum to vote for.
     * - `vote`: The vote configuration.
     * 
     * Weight: `O(R)` where R is the number of referendums the voter has voted on.
     */
    get asV9111(): {refIndex: number, vote: v9111.AccountVote} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionProviderMultiPhaseGovernanceFallbackCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionProviderMultiPhase.governance_fallback')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Trigger the governance fallback.
     * 
     * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
     * calling [`Call::set_emergency_election_result`].
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.governance_fallback') === 'f3179fd0f0529838d5758e1e919a1900aa58425b96768e9648bf806ee9c9b1ae'
    }

    /**
     * Trigger the governance fallback.
     * 
     * This can only be called when [`Phase::Emergency`] is enabled, as an alternative to
     * calling [`Call::set_emergency_election_result`].
     */
    get asV9170(): {maybeMaxVoters: (number | undefined), maybeMaxTargets: (number | undefined)} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionProviderMultiPhaseSetEmergencyElectionResultCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionProviderMultiPhase.set_emergency_election_result')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set a solution in the queue, to be handed out to the client of this pallet in the next
     *  call to `ElectionProvider::elect`.
     * 
     *  This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
     * 
     *  The solution is not checked for any feasibility and is assumed to be trustworthy, as any
     *  feasibility check itself can in principle cause the election process to fail (due to
     *  memory/weight constrains).
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.set_emergency_election_result') === '1366356a941ed9a9d255517cff6facb3dbc5c2bbd54c7617c2f064d33118ca6c'
    }

    /**
     *  Set a solution in the queue, to be handed out to the client of this pallet in the next
     *  call to `ElectionProvider::elect`.
     * 
     *  This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
     * 
     *  The solution is not checked for any feasibility and is assumed to be trustworthy, as any
     *  feasibility check itself can in principle cause the election process to fail (due to
     *  memory/weight constrains).
     */
    get asV9050(): {solution: v9050.ReadySolution} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set a solution in the queue, to be handed out to the client of this pallet in the next
     *  call to `ElectionProvider::elect`.
     * 
     *  This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
     * 
     *  The solution is not checked for any feasibility and is assumed to be trustworthy, as any
     *  feasibility check itself can in principle cause the election process to fail (due to
     *  memory/weight constrains).
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.set_emergency_election_result') === '976eeea3dee9ad3c2d95e30c6751a49c4ae6a755a0448d0d6f282625dd92e539'
    }

    /**
     *  Set a solution in the queue, to be handed out to the client of this pallet in the next
     *  call to `ElectionProvider::elect`.
     * 
     *  This can only be set by `T::ForceOrigin`, and only when the phase is `Emergency`.
     * 
     *  The solution is not checked for any feasibility and is assumed to be trustworthy, as any
     *  feasibility check itself can in principle cause the election process to fail (due to
     *  memory/weight constrains).
     */
    get asV9090(): {supports: [Uint8Array, v9090.SolutionSupport][]} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionProviderMultiPhaseSetMinimumUntrustedScoreCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionProviderMultiPhase.set_minimum_untrusted_score')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set a new value for `MinimumUntrustedScore`.
     * 
     *  Dispatch origin must be aligned with `T::ForceOrigin`.
     * 
     *  This check can be turned off by setting the value to `None`.
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.set_minimum_untrusted_score') === '79798adfdd93f0c5b4f66cbd34416ae29fdf7567e8cab8085c67b259049e3921'
    }

    /**
     *  Set a new value for `MinimumUntrustedScore`.
     * 
     *  Dispatch origin must be aligned with `T::ForceOrigin`.
     * 
     *  This check can be turned off by setting the value to `None`.
     */
    get asV9040(): {maybeNextScore: (bigint[] | undefined)} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set a new value for `MinimumUntrustedScore`.
     * 
     * Dispatch origin must be aligned with `T::ForceOrigin`.
     * 
     * This check can be turned off by setting the value to `None`.
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.set_minimum_untrusted_score') === '4b6d16ae537aca5ce887c10c25d838413bb18639efa0829f62aa6b722837c206'
    }

    /**
     * Set a new value for `MinimumUntrustedScore`.
     * 
     * Dispatch origin must be aligned with `T::ForceOrigin`.
     * 
     * This check can be turned off by setting the value to `None`.
     */
    get asV9180(): {maybeNextScore: (v9180.ElectionScore | undefined)} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionProviderMultiPhaseSubmitCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionProviderMultiPhase.submit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Submit a solution for the signed phase.
     * 
     *  The dispatch origin fo this call must be __signed__.
     * 
     *  The solution is potentially queued, based on the claimed score and processed at the end
     *  of the signed phase.
     * 
     *  A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     *  might be rewarded, slashed, or get all or a part of the deposit back.
     * 
     *  # <weight>
     *  Queue size must be provided as witness data.
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.submit') === '94003e4e41682e0d9b28d2718aecbf3231ffabcf24ec84676dde7424d1a08af1'
    }

    /**
     *  Submit a solution for the signed phase.
     * 
     *  The dispatch origin fo this call must be __signed__.
     * 
     *  The solution is potentially queued, based on the claimed score and processed at the end
     *  of the signed phase.
     * 
     *  A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     *  might be rewarded, slashed, or get all or a part of the deposit back.
     * 
     *  # <weight>
     *  Queue size must be provided as witness data.
     *  # </weight>
     */
    get asV9080(): {solution: v9080.RawSolution, numSignedSubmissions: number} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Submit a solution for the signed phase.
     * 
     *  The dispatch origin fo this call must be __signed__.
     * 
     *  The solution is potentially queued, based on the claimed score and processed at the end
     *  of the signed phase.
     * 
     *  A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     *  might be rewarded, slashed, or get all or a part of the deposit back.
     * 
     *  # <weight>
     *  Queue size must be provided as witness data.
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.submit') === '251021ba62a20a74013f34cf8b72839cea395a4cdb9ca71156e8c5a7a181cd98'
    }

    /**
     *  Submit a solution for the signed phase.
     * 
     *  The dispatch origin fo this call must be __signed__.
     * 
     *  The solution is potentially queued, based on the claimed score and processed at the end
     *  of the signed phase.
     * 
     *  A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     *  might be rewarded, slashed, or get all or a part of the deposit back.
     * 
     *  # <weight>
     *  Queue size must be provided as witness data.
     *  # </weight>
     */
    get asV9100(): {rawSolution: v9100.RawSolution, numSignedSubmissions: number} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Submit a solution for the signed phase.
     * 
     * The dispatch origin fo this call must be __signed__.
     * 
     * The solution is potentially queued, based on the claimed score and processed at the end
     * of the signed phase.
     * 
     * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     * might be rewarded, slashed, or get all or a part of the deposit back.
     * 
     * # <weight>
     * Queue size must be provided as witness data.
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.submit') === '61aa92ecfe0c540b354191793c8cdb60e49bae77d854610c8660073a7816201c'
    }

    /**
     * Submit a solution for the signed phase.
     * 
     * The dispatch origin fo this call must be __signed__.
     * 
     * The solution is potentially queued, based on the claimed score and processed at the end
     * of the signed phase.
     * 
     * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     * might be rewarded, slashed, or get all or a part of the deposit back.
     * 
     * # <weight>
     * Queue size must be provided as witness data.
     * # </weight>
     */
    get asV9111(): {rawSolution: v9111.RawSolution, numSignedSubmissions: number} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Submit a solution for the signed phase.
     * 
     * The dispatch origin fo this call must be __signed__.
     * 
     * The solution is potentially queued, based on the claimed score and processed at the end
     * of the signed phase.
     * 
     * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     * might be rewarded, slashed, or get all or a part of the deposit back.
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.submit') === '3509bddc2e290e5056bab6adf0639cb780d40f3dc978c7478ef35f06da346d87'
    }

    /**
     * Submit a solution for the signed phase.
     * 
     * The dispatch origin fo this call must be __signed__.
     * 
     * The solution is potentially queued, based on the claimed score and processed at the end
     * of the signed phase.
     * 
     * A deposit is reserved and recorded for the solution. Based on the outcome, the solution
     * might be rewarded, slashed, or get all or a part of the deposit back.
     */
    get asV9180(): {rawSolution: v9180.RawSolution} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionProviderMultiPhaseSubmitUnsignedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionProviderMultiPhase.submit_unsigned')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Submit a solution for the unsigned phase.
     * 
     *  The dispatch origin fo this call must be __none__.
     * 
     *  This submission is checked on the fly. Moreover, this unsigned solution is only
     *  validated when submitted to the pool from the **local** node. Effectively, this means
     *  that only active validators can submit this transaction when authoring a block (similar
     *  to an inherent).
     * 
     *  To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     *  panic if the solution submitted by the validator is invalid in any way, effectively
     *  putting their authoring reward at risk.
     * 
     *  No deposit or reward is associated with this submission.
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.submit_unsigned') === '646d8d6731047b10cc00c12a4a5d73841b109354179e0446808aed09178f31c0'
    }

    /**
     *  Submit a solution for the unsigned phase.
     * 
     *  The dispatch origin fo this call must be __none__.
     * 
     *  This submission is checked on the fly. Moreover, this unsigned solution is only
     *  validated when submitted to the pool from the **local** node. Effectively, this means
     *  that only active validators can submit this transaction when authoring a block (similar
     *  to an inherent).
     * 
     *  To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     *  panic if the solution submitted by the validator is invalid in any way, effectively
     *  putting their authoring reward at risk.
     * 
     *  No deposit or reward is associated with this submission.
     */
    get asV2029(): {solution: v2029.RawSolution, witness: v2029.SolutionOrSnapshotSize} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Submit a solution for the unsigned phase.
     * 
     *  The dispatch origin fo this call must be __none__.
     * 
     *  This submission is checked on the fly. Moreover, this unsigned solution is only
     *  validated when submitted to the pool from the **local** node. Effectively, this means
     *  that only active validators can submit this transaction when authoring a block (similar
     *  to an inherent).
     * 
     *  To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     *  panic if the solution submitted by the validator is invalid in any way, effectively
     *  putting their authoring reward at risk.
     * 
     *  No deposit or reward is associated with this submission.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.submit_unsigned') === 'fca1d95736617c836f55e42da376cfea1d9d4aa2e4f61e2146c793640493d4ca'
    }

    /**
     *  Submit a solution for the unsigned phase.
     * 
     *  The dispatch origin fo this call must be __none__.
     * 
     *  This submission is checked on the fly. Moreover, this unsigned solution is only
     *  validated when submitted to the pool from the **local** node. Effectively, this means
     *  that only active validators can submit this transaction when authoring a block (similar
     *  to an inherent).
     * 
     *  To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     *  panic if the solution submitted by the validator is invalid in any way, effectively
     *  putting their authoring reward at risk.
     * 
     *  No deposit or reward is associated with this submission.
     */
    get asV9010(): {solution: v9010.RawSolution, witness: v9010.SolutionOrSnapshotSize} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Submit a solution for the unsigned phase.
     * 
     *  The dispatch origin fo this call must be __none__.
     * 
     *  This submission is checked on the fly. Moreover, this unsigned solution is only
     *  validated when submitted to the pool from the **local** node. Effectively, this means
     *  that only active validators can submit this transaction when authoring a block (similar
     *  to an inherent).
     * 
     *  To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     *  panic if the solution submitted by the validator is invalid in any way, effectively
     *  putting their authoring reward at risk.
     * 
     *  No deposit or reward is associated with this submission.
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.submit_unsigned') === '76cefeeb0eed9d9ee4b7e485b439f314e2ac99757f8bbc195c6307459af1a43e'
    }

    /**
     *  Submit a solution for the unsigned phase.
     * 
     *  The dispatch origin fo this call must be __none__.
     * 
     *  This submission is checked on the fly. Moreover, this unsigned solution is only
     *  validated when submitted to the pool from the **local** node. Effectively, this means
     *  that only active validators can submit this transaction when authoring a block (similar
     *  to an inherent).
     * 
     *  To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     *  panic if the solution submitted by the validator is invalid in any way, effectively
     *  putting their authoring reward at risk.
     * 
     *  No deposit or reward is associated with this submission.
     */
    get asV9100(): {rawSolution: v9100.RawSolution, witness: v9100.SolutionOrSnapshotSize} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Submit a solution for the unsigned phase.
     * 
     * The dispatch origin fo this call must be __none__.
     * 
     * This submission is checked on the fly. Moreover, this unsigned solution is only
     * validated when submitted to the pool from the **local** node. Effectively, this means
     * that only active validators can submit this transaction when authoring a block (similar
     * to an inherent).
     * 
     * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     * panic if the solution submitted by the validator is invalid in any way, effectively
     * putting their authoring reward at risk.
     * 
     * No deposit or reward is associated with this submission.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.submit_unsigned') === 'f07124eee1bb683b9e611486e21611dbd0592de5fa958ac2c3f432f9cd7df224'
    }

    /**
     * Submit a solution for the unsigned phase.
     * 
     * The dispatch origin fo this call must be __none__.
     * 
     * This submission is checked on the fly. Moreover, this unsigned solution is only
     * validated when submitted to the pool from the **local** node. Effectively, this means
     * that only active validators can submit this transaction when authoring a block (similar
     * to an inherent).
     * 
     * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     * panic if the solution submitted by the validator is invalid in any way, effectively
     * putting their authoring reward at risk.
     * 
     * No deposit or reward is associated with this submission.
     */
    get asV9111(): {rawSolution: v9111.RawSolution, witness: v9111.SolutionOrSnapshotSize} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Submit a solution for the unsigned phase.
     * 
     * The dispatch origin fo this call must be __none__.
     * 
     * This submission is checked on the fly. Moreover, this unsigned solution is only
     * validated when submitted to the pool from the **local** node. Effectively, this means
     * that only active validators can submit this transaction when authoring a block (similar
     * to an inherent).
     * 
     * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     * panic if the solution submitted by the validator is invalid in any way, effectively
     * putting their authoring reward at risk.
     * 
     * No deposit or reward is associated with this submission.
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('ElectionProviderMultiPhase.submit_unsigned') === '206a863dac73f7a4a92672c4e078897cac93dcb27517573adca2f9193acd8f5e'
    }

    /**
     * Submit a solution for the unsigned phase.
     * 
     * The dispatch origin fo this call must be __none__.
     * 
     * This submission is checked on the fly. Moreover, this unsigned solution is only
     * validated when submitted to the pool from the **local** node. Effectively, this means
     * that only active validators can submit this transaction when authoring a block (similar
     * to an inherent).
     * 
     * To prevent any incorrect solution (and thus wasted time/weight), this transaction will
     * panic if the solution submitted by the validator is invalid in any way, effectively
     * putting their authoring reward at risk.
     * 
     * No deposit or reward is associated with this submission.
     */
    get asV9180(): {rawSolution: v9180.RawSolution, witness: v9180.SolutionOrSnapshotSize} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionsPhragmenCleanDefunctVotersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionsPhragmen.clean_defunct_voters')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
     *  deposit of the removed voters are returned.
     * 
     *  This is an root function to be used only for cleaning the state.
     * 
     *  The dispatch origin of this call must be root.
     * 
     *  # <weight>
     *  The total number of voters and those that are defunct must be provided as witness data.
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.clean_defunct_voters') === '8279e35309d0c9a5d36cd12cce19e58fef95829d4096e23fe93a055a47afd8a0'
    }

    /**
     *  Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
     *  deposit of the removed voters are returned.
     * 
     *  This is an root function to be used only for cleaning the state.
     * 
     *  The dispatch origin of this call must be root.
     * 
     *  # <weight>
     *  The total number of voters and those that are defunct must be provided as witness data.
     *  # </weight>
     */
    get asV2028(): {numVoters: number, numDefunct: number} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionsPhragmenRemoveMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionsPhragmen.remove_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a particular member from the set. This is effective immediately and the bond of
     *  the outgoing member is slashed.
     * 
     *  If a runner-up is available, then the best runner-up will be removed and replaces the
     *  outgoing member. Otherwise, a new phragmen round is started.
     * 
     *  Note that this does not affect the designated block number of the next election.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(do_phragmen)
     *  Writes: O(do_phragmen)
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.remove_member') === '117b5f5492df8dba6b0ef0e5c8afcea59acec18fe646792886f4a218cab299b1'
    }

    /**
     *  Remove a particular member from the set. This is effective immediately and the bond of
     *  the outgoing member is slashed.
     * 
     *  If a runner-up is available, then the best runner-up will be removed and replaces the
     *  outgoing member. Otherwise, a new phragmen round is started.
     * 
     *  Note that this does not affect the designated block number of the next election.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(do_phragmen)
     *  Writes: O(do_phragmen)
     *  # </weight>
     */
    get asV1020(): {who: v1020.LookupSource} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Remove a particular member from the set. This is effective immediately and the bond of
     *  the outgoing member is slashed.
     * 
     *  If a runner-up is available, then the best runner-up will be removed and replaces the
     *  outgoing member. Otherwise, a new phragmen round is started.
     * 
     *  Note that this does not affect the designated block number of the next election.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(do_phragmen)
     *  Writes: O(do_phragmen)
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.remove_member') === 'b8a0d2208835f6ada60dd21cd93533d703777b3779109a7c6a2f26bad68c2f3b'
    }

    /**
     *  Remove a particular member from the set. This is effective immediately and the bond of
     *  the outgoing member is slashed.
     * 
     *  If a runner-up is available, then the best runner-up will be removed and replaces the
     *  outgoing member. Otherwise, a new phragmen round is started.
     * 
     *  Note that this does not affect the designated block number of the next election.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(do_phragmen)
     *  Writes: O(do_phragmen)
     *  # </weight>
     */
    get asV1050(): {who: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Remove a particular member from the set. This is effective immediately and the bond of
     *  the outgoing member is slashed.
     * 
     *  If a runner-up is available, then the best runner-up will be removed and replaces the
     *  outgoing member. Otherwise, a new phragmen election is started.
     * 
     *  Note that this does not affect the designated block number of the next election.
     * 
     *  # <weight>
     *  If we have a replacement:
     *  	- Base weight: 50.93 µs
     *  	- State reads:
     *  		- RunnersUp.len()
     *  		- Members, RunnersUp (remove_and_replace_member)
     *  	- State writes:
     *  		- Members, RunnersUp (remove_and_replace_member)
     *  Else, since this is a root call and will go into phragmen, we assume full block for now.
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.remove_member') === 'cc43d536f862eb65fab1d583cca3ea302b95423702ae1dac84b75df432320893'
    }

    /**
     *  Remove a particular member from the set. This is effective immediately and the bond of
     *  the outgoing member is slashed.
     * 
     *  If a runner-up is available, then the best runner-up will be removed and replaces the
     *  outgoing member. Otherwise, a new phragmen election is started.
     * 
     *  Note that this does not affect the designated block number of the next election.
     * 
     *  # <weight>
     *  If we have a replacement:
     *  	- Base weight: 50.93 µs
     *  	- State reads:
     *  		- RunnersUp.len()
     *  		- Members, RunnersUp (remove_and_replace_member)
     *  	- State writes:
     *  		- Members, RunnersUp (remove_and_replace_member)
     *  Else, since this is a root call and will go into phragmen, we assume full block for now.
     *  # </weight>
     */
    get asV2005(): {who: Uint8Array, hasReplacement: boolean} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Remove a particular member from the set. This is effective immediately and the bond of
     *  the outgoing member is slashed.
     * 
     *  If a runner-up is available, then the best runner-up will be removed and replaces the
     *  outgoing member. Otherwise, a new phragmen election is started.
     * 
     *  The dispatch origin of this call must be root.
     * 
     *  Note that this does not affect the designated block number of the next election.
     * 
     *  # <weight>
     *  If we have a replacement, we use a small weight. Else, since this is a root call and
     *  will go into phragmen, we assume full block for now.
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.remove_member') === '8f953115e82b1180527569f88641e39ddd7c750a04a3e0ab23cb9466f32e4a9b'
    }

    /**
     *  Remove a particular member from the set. This is effective immediately and the bond of
     *  the outgoing member is slashed.
     * 
     *  If a runner-up is available, then the best runner-up will be removed and replaces the
     *  outgoing member. Otherwise, a new phragmen election is started.
     * 
     *  The dispatch origin of this call must be root.
     * 
     *  Note that this does not affect the designated block number of the next election.
     * 
     *  # <weight>
     *  If we have a replacement, we use a small weight. Else, since this is a root call and
     *  will go into phragmen, we assume full block for now.
     *  # </weight>
     */
    get asV2028(): {who: v2028.LookupSource, hasReplacement: boolean} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionsPhragmenRemoveVoterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionsPhragmen.remove_voter')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove `origin` as a voter. This removes the lock and returns the bond.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(1)
     *  Writes: O(1)
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.remove_voter') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Remove `origin` as a voter. This removes the lock and returns the bond.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(1)
     *  Writes: O(1)
     *  # </weight>
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionsPhragmenRenounceCandidacyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionsPhragmen.renounce_candidacy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Renounce one's intention to be a candidate for the next election round. 3 potential
     *  outcomes exist:
     *  - `origin` is a candidate and not elected in any set. In this case, the bond is
     *    unreserved, returned and origin is removed as a candidate.
     *  - `origin` is a current runner up. In this case, the bond is unreserved, returned and
     *    origin is removed as a runner.
     *  - `origin` is a current member. In this case, the bond is unreserved and origin is
     *    removed as a member, consequently not being a candidate for the next round anymore.
     *    Similar to [`remove_voter`], if replacement runners exists, they are immediately used.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.renounce_candidacy') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Renounce one's intention to be a candidate for the next election round. 3 potential
     *  outcomes exist:
     *  - `origin` is a candidate and not elected in any set. In this case, the bond is
     *    unreserved, returned and origin is removed as a candidate.
     *  - `origin` is a current runner up. In this case, the bond is unreserved, returned and
     *    origin is removed as a runner.
     *  - `origin` is a current member. In this case, the bond is unreserved and origin is
     *    removed as a member, consequently not being a candidate for the next round anymore.
     *    Similar to [`remove_voter`], if replacement runners exists, they are immediately used.
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Renounce one's intention to be a candidate for the next election round. 3 potential
     *  outcomes exist:
     *  - `origin` is a candidate and not elected in any set. In this case, the bond is
     *    unreserved, returned and origin is removed as a candidate.
     *  - `origin` is a current runner-up. In this case, the bond is unreserved, returned and
     *    origin is removed as a runner-up.
     *  - `origin` is a current member. In this case, the bond is unreserved and origin is
     *    removed as a member, consequently not being a candidate for the next round anymore.
     *    Similar to [`remove_voter`], if replacement runners exists, they are immediately used.
     *  <weight>
     *  If a candidate is renouncing:
     *  	Base weight: 17.28 µs
     *  	Complexity of candidate_count: 0.235 µs
     *  	State reads:
     *  		- Candidates
     *  		- [AccountBalance(who) (unreserve)]
     *  	State writes:
     *  		- Candidates
     *  		- [AccountBalance(who) (unreserve)]
     *  If member is renouncing:
     *  	Base weight: 46.25 µs
     *  	State reads:
     *  		- Members, RunnersUp (remove_and_replace_member),
     *  		- [AccountData(who) (unreserve)]
     *  	State writes:
     *  		- Members, RunnersUp (remove_and_replace_member),
     *  		- [AccountData(who) (unreserve)]
     *  If runner is renouncing:
     *  	Base weight: 46.25 µs
     *  	State reads:
     *  		- RunnersUp (remove_and_replace_member),
     *  		- [AccountData(who) (unreserve)]
     *  	State writes:
     *  		- RunnersUp (remove_and_replace_member),
     *  		- [AccountData(who) (unreserve)]
     * 
     *  Weight note: The call into changeMembers need to be accounted for.
     *  </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.renounce_candidacy') === '891a3ff219ab8817cfffbcd0ed48578a0fd96440dc2292a0cde84a40439f7fbe'
    }

    /**
     *  Renounce one's intention to be a candidate for the next election round. 3 potential
     *  outcomes exist:
     *  - `origin` is a candidate and not elected in any set. In this case, the bond is
     *    unreserved, returned and origin is removed as a candidate.
     *  - `origin` is a current runner-up. In this case, the bond is unreserved, returned and
     *    origin is removed as a runner-up.
     *  - `origin` is a current member. In this case, the bond is unreserved and origin is
     *    removed as a member, consequently not being a candidate for the next round anymore.
     *    Similar to [`remove_voter`], if replacement runners exists, they are immediately used.
     *  <weight>
     *  If a candidate is renouncing:
     *  	Base weight: 17.28 µs
     *  	Complexity of candidate_count: 0.235 µs
     *  	State reads:
     *  		- Candidates
     *  		- [AccountBalance(who) (unreserve)]
     *  	State writes:
     *  		- Candidates
     *  		- [AccountBalance(who) (unreserve)]
     *  If member is renouncing:
     *  	Base weight: 46.25 µs
     *  	State reads:
     *  		- Members, RunnersUp (remove_and_replace_member),
     *  		- [AccountData(who) (unreserve)]
     *  	State writes:
     *  		- Members, RunnersUp (remove_and_replace_member),
     *  		- [AccountData(who) (unreserve)]
     *  If runner is renouncing:
     *  	Base weight: 46.25 µs
     *  	State reads:
     *  		- RunnersUp (remove_and_replace_member),
     *  		- [AccountData(who) (unreserve)]
     *  	State writes:
     *  		- RunnersUp (remove_and_replace_member),
     *  		- [AccountData(who) (unreserve)]
     * 
     *  Weight note: The call into changeMembers need to be accounted for.
     *  </weight>
     */
    get asV2005(): {renouncing: v2005.Renouncing} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionsPhragmenReportDefunctVoterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionsPhragmen.report_defunct_voter')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Report `target` for being an defunct voter. In case of a valid report, the reporter is
     *  rewarded by the bond amount of `target`. Otherwise, the reporter itself is removed and
     *  their bond is slashed.
     * 
     *  A defunct voter is defined to be:
     *    - a voter whose current submitted votes are all invalid. i.e. all of them are no
     *      longer a candidate nor an active member.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(NLogM) given M current candidates and N votes for `target`.
     *  Writes: O(1)
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.report_defunct_voter') === 'cd19c54875d335772c471b877903ed3a260a7316fd1d201b12e013ae0a7dfe2d'
    }

    /**
     *  Report `target` for being an defunct voter. In case of a valid report, the reporter is
     *  rewarded by the bond amount of `target`. Otherwise, the reporter itself is removed and
     *  their bond is slashed.
     * 
     *  A defunct voter is defined to be:
     *    - a voter whose current submitted votes are all invalid. i.e. all of them are no
     *      longer a candidate nor an active member.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(NLogM) given M current candidates and N votes for `target`.
     *  Writes: O(1)
     *  # </weight>
     */
    get asV1020(): {target: v1020.LookupSource} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Report `target` for being an defunct voter. In case of a valid report, the reporter is
     *  rewarded by the bond amount of `target`. Otherwise, the reporter itself is removed and
     *  their bond is slashed.
     * 
     *  A defunct voter is defined to be:
     *    - a voter whose current submitted votes are all invalid. i.e. all of them are no
     *      longer a candidate nor an active member.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(NLogM) given M current candidates and N votes for `target`.
     *  Writes: O(1)
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.report_defunct_voter') === '66d8abf7976ff596d8d614948b9d84cb24f0b898d88d24eb2cc035ae5e93c7b8'
    }

    /**
     *  Report `target` for being an defunct voter. In case of a valid report, the reporter is
     *  rewarded by the bond amount of `target`. Otherwise, the reporter itself is removed and
     *  their bond is slashed.
     * 
     *  A defunct voter is defined to be:
     *    - a voter whose current submitted votes are all invalid. i.e. all of them are no
     *      longer a candidate nor an active member.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(NLogM) given M current candidates and N votes for `target`.
     *  Writes: O(1)
     *  # </weight>
     */
    get asV1050(): {target: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Report `target` for being an defunct voter. In case of a valid report, the reporter is
     *  rewarded by the bond amount of `target`. Otherwise, the reporter itself is removed and
     *  their bond is slashed.
     * 
     *  A defunct voter is defined to be:
     *    - a voter whose current submitted votes are all invalid. i.e. all of them are no
     *      longer a candidate nor an active member or a runner-up.
     * 
     * 
     *  The origin must provide the number of current candidates and votes of the reported target
     *  for the purpose of accurate weight calculation.
     * 
     *  # <weight>
     *  No Base weight based on min square analysis.
     *  Complexity of candidate_count: 1.755 µs
     *  Complexity of vote_count: 18.51 µs
     *  State reads:
     *   	- Voting(reporter)
     *   	- Candidate.len()
     *   	- Voting(Target)
     *   	- Candidates, Members, RunnersUp (is_defunct_voter)
     *  State writes:
     *  	- Lock(reporter || target)
     *  	- [AccountBalance(reporter)] + AccountBalance(target)
     *  	- Voting(reporter || target)
     *  Note: the db access is worse with respect to db, which is when the report is correct.
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.report_defunct_voter') === '06b6bca7c2f25b5dc00e07d653b298043f1152bc6501f837c134bde3c14f1fab'
    }

    /**
     *  Report `target` for being an defunct voter. In case of a valid report, the reporter is
     *  rewarded by the bond amount of `target`. Otherwise, the reporter itself is removed and
     *  their bond is slashed.
     * 
     *  A defunct voter is defined to be:
     *    - a voter whose current submitted votes are all invalid. i.e. all of them are no
     *      longer a candidate nor an active member or a runner-up.
     * 
     * 
     *  The origin must provide the number of current candidates and votes of the reported target
     *  for the purpose of accurate weight calculation.
     * 
     *  # <weight>
     *  No Base weight based on min square analysis.
     *  Complexity of candidate_count: 1.755 µs
     *  Complexity of vote_count: 18.51 µs
     *  State reads:
     *   	- Voting(reporter)
     *   	- Candidate.len()
     *   	- Voting(Target)
     *   	- Candidates, Members, RunnersUp (is_defunct_voter)
     *  State writes:
     *  	- Lock(reporter || target)
     *  	- [AccountBalance(reporter)] + AccountBalance(target)
     *  	- Voting(reporter || target)
     *  Note: the db access is worse with respect to db, which is when the report is correct.
     *  # </weight>
     */
    get asV2005(): {defunct: v2005.DefunctVoter} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionsPhragmenSubmitCandidacyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionsPhragmen.submit_candidacy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Submit oneself for candidacy.
     * 
     *  A candidate will either:
     *    - Lose at the end of the term and forfeit their deposit.
     *    - Win and become a member. Members will eventually get their stash back.
     *    - Become a runner-up. Runners-ups are reserved members in case one gets forcefully
     *      removed.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(LogN) Given N candidates.
     *  Writes: O(1)
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.submit_candidacy') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Submit oneself for candidacy.
     * 
     *  A candidate will either:
     *    - Lose at the end of the term and forfeit their deposit.
     *    - Win and become a member. Members will eventually get their stash back.
     *    - Become a runner-up. Runners-ups are reserved members in case one gets forcefully
     *      removed.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(LogN) Given N candidates.
     *  Writes: O(1)
     *  # </weight>
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Submit oneself for candidacy.
     * 
     *  A candidate will either:
     *    - Lose at the end of the term and forfeit their deposit.
     *    - Win and become a member. Members will eventually get their stash back.
     *    - Become a runner-up. Runners-ups are reserved members in case one gets forcefully
     *      removed.
     * 
     *  # <weight>
     *  Base weight = 33.33 µs
     *  Complexity of candidate_count: 0.375 µs
     *  State reads:
     *  	- Candidates.len()
     *  	- Candidates
     *  	- Members
     *  	- RunnersUp
     *  	- [AccountBalance(who)]
     *  State writes:
     *  	- [AccountBalance(who)]
     *  	- Candidates
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.submit_candidacy') === 'f9d2bc9f755e33c27d34db4c3b063daa9e2490111d35f89ea1995d74e59b1819'
    }

    /**
     *  Submit oneself for candidacy.
     * 
     *  A candidate will either:
     *    - Lose at the end of the term and forfeit their deposit.
     *    - Win and become a member. Members will eventually get their stash back.
     *    - Become a runner-up. Runners-ups are reserved members in case one gets forcefully
     *      removed.
     * 
     *  # <weight>
     *  Base weight = 33.33 µs
     *  Complexity of candidate_count: 0.375 µs
     *  State reads:
     *  	- Candidates.len()
     *  	- Candidates
     *  	- Members
     *  	- RunnersUp
     *  	- [AccountBalance(who)]
     *  State writes:
     *  	- [AccountBalance(who)]
     *  	- Candidates
     *  # </weight>
     */
    get asV2005(): {candidateCount: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class ElectionsPhragmenVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ElectionsPhragmen.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Vote for a set of candidates for the upcoming round of election.
     * 
     *  The `votes` should:
     *    - not be empty.
     *    - be less than the number of candidates.
     * 
     *  Upon voting, `value` units of `who`'s balance is locked and a bond amount is reserved.
     *  It is the responsibility of the caller to not place all of their balance into the lock
     *  and keep some for further transactions.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(1)
     *  Writes: O(V) given `V` votes. V is bounded by 16.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('ElectionsPhragmen.vote') === '75939c25de1c96145b5d2d4bc8627a3fc22299f0e1f1f6f0709e54e884796bda'
    }

    /**
     *  Vote for a set of candidates for the upcoming round of election.
     * 
     *  The `votes` should:
     *    - not be empty.
     *    - be less than the number of candidates.
     * 
     *  Upon voting, `value` units of `who`'s balance is locked and a bond amount is reserved.
     *  It is the responsibility of the caller to not place all of their balance into the lock
     *  and keep some for further transactions.
     * 
     *  # <weight>
     *  #### State
     *  Reads: O(1)
     *  Writes: O(V) given `V` votes. V is bounded by 16.
     *  # </weight>
     */
    get asV1020(): {votes: Uint8Array[], value: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class FastUnstakeControlCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FastUnstake.control')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Control the operation of this pallet.
     * 
     * Dispatch origin must be signed by the [`Config::ControlOrigin`].
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('FastUnstake.control') === 'fba6d3249ebe11bdfcd30ffbc4ac9ab928994503f624c610a6b6b66b78a663ba'
    }

    /**
     * Control the operation of this pallet.
     * 
     * Dispatch origin must be signed by the [`Config::ControlOrigin`].
     */
    get asV9300(): {uncheckedErasToCheck: number} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }
}

export class FastUnstakeDeregisterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FastUnstake.deregister')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Deregister oneself from the fast-unstake.
     * 
     * This is useful if one is registered, they are still waiting, and they change their mind.
     * 
     * Note that the associated stash is still fully unbonded and chilled as a consequence of
     * calling `register_fast_unstake`. This should probably be followed by a call to
     * `Staking::rebond`.
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('FastUnstake.deregister') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Deregister oneself from the fast-unstake.
     * 
     * This is useful if one is registered, they are still waiting, and they change their mind.
     * 
     * Note that the associated stash is still fully unbonded and chilled as a consequence of
     * calling `register_fast_unstake`. This should probably be followed by a call to
     * `Staking::rebond`.
     */
    get asV9300(): null {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }
}

export class FastUnstakeRegisterFastUnstakeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FastUnstake.register_fast_unstake')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Register oneself for fast-unstake.
     * 
     * The dispatch origin of this call must be signed by the controller account, similar to
     * `staking::unbond`.
     * 
     * The stash associated with the origin must have no ongoing unlocking chunks. If
     * successful, this will fully unbond and chill the stash. Then, it will enqueue the stash
     * to be checked in further blocks.
     * 
     * If by the time this is called, the stash is actually eligible for fast-unstake, then
     * they are guaranteed to remain eligible, because the call will chill them as well.
     * 
     * If the check works, the entire staking data is removed, i.e. the stash is fully
     * unstaked.
     * 
     * If the check fails, the stash remains chilled and waiting for being unbonded as in with
     * the normal staking system, but they lose part of their unbonding chunks due to consuming
     * the chain's resources.
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('FastUnstake.register_fast_unstake') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Register oneself for fast-unstake.
     * 
     * The dispatch origin of this call must be signed by the controller account, similar to
     * `staking::unbond`.
     * 
     * The stash associated with the origin must have no ongoing unlocking chunks. If
     * successful, this will fully unbond and chill the stash. Then, it will enqueue the stash
     * to be checked in further blocks.
     * 
     * If by the time this is called, the stash is actually eligible for fast-unstake, then
     * they are guaranteed to remain eligible, because the call will chill them as well.
     * 
     * If the check works, the entire staking data is removed, i.e. the stash is fully
     * unstaked.
     * 
     * If the check fails, the stash remains chilled and waiting for being unbonded as in with
     * the normal staking system, but they lose part of their unbonding chunks due to consuming
     * the chain's resources.
     */
    get asV9300(): null {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipCollectiveAddMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipCollective.add_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Introduce a new member.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of non-member which will become a member.
     * - `rank`: The rank to give the new member.
     * 
     * Weight: `O(1)`
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipCollective.add_member') === '1642934df325db16ad3ad3f83bb2200cdde93b508c653dc7b78049e7e8d67223'
    }

    /**
     * Introduce a new member.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of non-member which will become a member.
     * - `rank`: The rank to give the new member.
     * 
     * Weight: `O(1)`
     */
    get asV9320(): {who: v9320.MultiAddress} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipCollectiveCleanupPollCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipCollective.cleanup_poll')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove votes from the given poll. It must have ended.
     * 
     * - `origin`: Must be `Signed` by any account.
     * - `poll_index`: Index of a poll which is completed and for which votes continue to
     *   exist.
     * - `max`: Maximum number of vote items from remove in this call.
     * 
     * Transaction fees are waived if the operation is successful.
     * 
     * Weight `O(max)` (less if there are fewer items to remove than `max`).
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipCollective.cleanup_poll') === '615caab6c9d00e9434a2a62bdbb08a0eb77297b001692b7d050ea0ec818af5a7'
    }

    /**
     * Remove votes from the given poll. It must have ended.
     * 
     * - `origin`: Must be `Signed` by any account.
     * - `poll_index`: Index of a poll which is completed and for which votes continue to
     *   exist.
     * - `max`: Maximum number of vote items from remove in this call.
     * 
     * Transaction fees are waived if the operation is successful.
     * 
     * Weight `O(max)` (less if there are fewer items to remove than `max`).
     */
    get asV9320(): {pollIndex: number, max: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipCollectiveDemoteMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipCollective.demote_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Decrement the rank of an existing member by one. If the member is already at rank zero,
     * then they are removed entirely.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     * 
     * Weight: `O(1)`, less if the member's index is highest in its rank.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipCollective.demote_member') === '1642934df325db16ad3ad3f83bb2200cdde93b508c653dc7b78049e7e8d67223'
    }

    /**
     * Decrement the rank of an existing member by one. If the member is already at rank zero,
     * then they are removed entirely.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     * 
     * Weight: `O(1)`, less if the member's index is highest in its rank.
     */
    get asV9320(): {who: v9320.MultiAddress} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipCollectivePromoteMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipCollective.promote_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Increment the rank of an existing member by one.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of existing member.
     * 
     * Weight: `O(1)`
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipCollective.promote_member') === '1642934df325db16ad3ad3f83bb2200cdde93b508c653dc7b78049e7e8d67223'
    }

    /**
     * Increment the rank of an existing member by one.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of existing member.
     * 
     * Weight: `O(1)`
     */
    get asV9320(): {who: v9320.MultiAddress} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipCollectiveRemoveMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipCollective.remove_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the member entirely.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     * - `min_rank`: The rank of the member or greater.
     * 
     * Weight: `O(min_rank)`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipCollective.remove_member') === '5848311fd06c03b30fa0c3e38db7f30b932bfcf1c54417fb40a23a7aa5690f18'
    }

    /**
     * Remove the member entirely.
     * 
     * - `origin`: Must be the `AdminOrigin`.
     * - `who`: Account of existing member of rank greater than zero.
     * - `min_rank`: The rank of the member or greater.
     * 
     * Weight: `O(min_rank)`.
     */
    get asV9320(): {who: v9320.MultiAddress, minRank: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipCollectiveVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipCollective.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     * 
     * - `origin`: Must be `Signed` by a member account.
     * - `poll`: Index of a poll which is ongoing.
     * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
     * 
     * Transaction fees are be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * 
     * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipCollective.vote') === '3b92ae59b712230cb36e2d4be01eaefb25ea0777001bbd698d8598221faca7d3'
    }

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     * 
     * - `origin`: Must be `Signed` by a member account.
     * - `poll`: Index of a poll which is ongoing.
     * - `aye`: `true` if the vote is to approve the proposal, `false` otherwise.
     * 
     * Transaction fees are be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * 
     * Weight: `O(1)`, less if there was no previous vote on the poll by the member.
     */
    get asV9320(): {poll: number, aye: boolean} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaCancelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.cancel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel an ongoing referendum.
     * 
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Cancelled`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.cancel') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Cancel an ongoing referendum.
     * 
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Cancelled`.
     */
    get asV9320(): {index: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaKillCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.kill')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel an ongoing referendum and slash the deposits.
     * 
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Killed` and `DepositSlashed`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.kill') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Cancel an ongoing referendum and slash the deposits.
     * 
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Killed` and `DepositSlashed`.
     */
    get asV9320(): {index: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaNudgeReferendumCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.nudge_referendum')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.nudge_referendum') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     */
    get asV9320(): {index: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaOneFewerDecidingCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.one_fewer_deciding')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Advance a track onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     * 
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.one_fewer_deciding') === '75d849d1c0275ad91cee68e888f612b619530fe1a9f1955df3cd6d91e4d4ed1d'
    }

    /**
     * Advance a track onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     * 
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     */
    get asV9320(): {track: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaPlaceDecisionDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.place_decision_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Post the Decision Deposit for a referendum.
     * 
     * - `origin`: must be `Signed` and the account must have funds available for the
     *   referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     *   posted.
     * 
     * Emits `DecisionDepositPlaced`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.place_decision_deposit') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Post the Decision Deposit for a referendum.
     * 
     * - `origin`: must be `Signed` and the account must have funds available for the
     *   referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     *   posted.
     * 
     * Emits `DecisionDepositPlaced`.
     */
    get asV9320(): {index: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaRefundDecisionDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.refund_decision_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     *   refunded.
     * 
     * Emits `DecisionDepositRefunded`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.refund_decision_deposit') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     *   refunded.
     * 
     * Emits `DecisionDepositRefunded`.
     */
    get asV9320(): {index: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaRefundSubmissionDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.refund_submission_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     *   refunded.
     * 
     * Emits `SubmissionDepositRefunded`.
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.refund_submission_deposit') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     *   refunded.
     * 
     * Emits `SubmissionDepositRefunded`.
     */
    get asV9350(): {index: number} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }
}

export class FellowshipReferendaSubmitCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FellowshipReferenda.submit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.submit') === '6973d34a693667744def0a5715cbdd4f9e5f021d58a5384675436ddb19fbb30d'
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get asV9320(): {proposalOrigin: v9320.OriginCaller, proposal: v9320.Bounded, enactmentMoment: v9320.DispatchTime} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('FellowshipReferenda.submit') === '864072fcea84d418733365bbf1c6b2afb718972174993b29cfec79274651ab29'
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get asV9370(): {proposalOrigin: v9370.OriginCaller, proposal: v9370.Bounded, enactmentMoment: v9370.DispatchTime} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class FinalityTrackerFinalHintCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'FinalityTracker.final_hint')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Hint that the author of this block thinks the best finalized
     *  block is the given number.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('FinalityTracker.final_hint') === '541316e9dd221458a29c70b9141157a89712cd3c223b2d3041ad734dd708dfe8'
    }

    /**
     *  Hint that the author of this block thinks the best finalized
     *  block is the given number.
     */
    get asV1020(): {hint: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class GiltPlaceBidCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Gilt.place_bid')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Place a bid for a gilt to be issued.
     * 
     *  Origin must be Signed, and account must have at least `amount` in free balance.
     * 
     *  - `amount`: The amount of the bid; these funds will be reserved. If the bid is
     *  successfully elevated into an issued gilt, then these funds will continue to be
     *  reserved until the gilt expires. Must be at least `MinFreeze`.
     *  - `duration`: The number of periods for which the funds will be locked if the gilt is
     *  issued. It will expire only after this period has elapsed after the point of issuance.
     *  Must be greater than 1 and no more than `QueueCount`.
     * 
     *  Complexities:
     *  - `Queues[duration].len()` (just take max).
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Gilt.place_bid') === 'a3c04aee6fb2869525c82baa3cce1aa56677672cb0687b0ebdf99955755806a3'
    }

    /**
     *  Place a bid for a gilt to be issued.
     * 
     *  Origin must be Signed, and account must have at least `amount` in free balance.
     * 
     *  - `amount`: The amount of the bid; these funds will be reserved. If the bid is
     *  successfully elevated into an issued gilt, then these funds will continue to be
     *  reserved until the gilt expires. Must be at least `MinFreeze`.
     *  - `duration`: The number of periods for which the funds will be locked if the gilt is
     *  issued. It will expire only after this period has elapsed after the point of issuance.
     *  Must be greater than 1 and no more than `QueueCount`.
     * 
     *  Complexities:
     *  - `Queues[duration].len()` (just take max).
     */
    get asV9010(): {amount: bigint, duration: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class GiltRetractBidCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Gilt.retract_bid')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Retract a previously placed bid.
     * 
     *  Origin must be Signed, and the account should have previously issued a still-active bid
     *  of `amount` for `duration`.
     * 
     *  - `amount`: The amount of the previous bid.
     *  - `duration`: The duration of the previous bid.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Gilt.retract_bid') === 'a3c04aee6fb2869525c82baa3cce1aa56677672cb0687b0ebdf99955755806a3'
    }

    /**
     *  Retract a previously placed bid.
     * 
     *  Origin must be Signed, and the account should have previously issued a still-active bid
     *  of `amount` for `duration`.
     * 
     *  - `amount`: The amount of the previous bid.
     *  - `duration`: The duration of the previous bid.
     */
    get asV9010(): {amount: bigint, duration: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class GiltSetTargetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Gilt.set_target')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set target proportion of gilt-funds.
     * 
     *  Origin must be `AdminOrigin`.
     * 
     *  - `target`: The target proportion of effective issued funds that should be under gilts
     *  at any one time.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Gilt.set_target') === '2e027e3600f85685d81d212c5c93cce493cc8a6bcf0c71379270b50c3ac08975'
    }

    /**
     *  Set target proportion of gilt-funds.
     * 
     *  Origin must be `AdminOrigin`.
     * 
     *  - `target`: The target proportion of effective issued funds that should be under gilts
     *  at any one time.
     */
    get asV9010(): {target: bigint} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class GiltThawCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Gilt.thaw')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove an active but expired gilt. Reserved funds under gilt are freed and balance is
     *  adjusted to ensure that the funds grow or shrink to maintain the equivalent proportion
     *  of effective total issued funds.
     * 
     *  Origin must be Signed and the account must be the owner of the gilt of the given index.
     * 
     *  - `index`: The index of the gilt to be thawed.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Gilt.thaw') === 'bd48b3528cf076be92c4c1f55a0268722184f1034de8ccfa09ac565bef81fa17'
    }

    /**
     *  Remove an active but expired gilt. Reserved funds under gilt are freed and balance is
     *  adjusted to ensure that the funds grow or shrink to maintain the equivalent proportion
     *  of effective total issued funds.
     * 
     *  Origin must be Signed and the account must be the owner of the gilt of the given index.
     * 
     *  - `index`: The index of the gilt to be thawed.
     */
    get asV9010(): {index: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class GrandpaNoteStalledCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Grandpa.note_stalled')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Note that the current authority set of the GRANDPA finality gadget has
     *  stalled. This will trigger a forced authority set change at the beginning
     *  of the next session, to be enacted `delay` blocks after that. The delay
     *  should be high enough to safely assume that the block signalling the
     *  forced change will not be re-orged (e.g. 1000 blocks). The GRANDPA voters
     *  will start the new authority set using the given finalized block as base.
     *  Only callable by root.
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('Grandpa.note_stalled') === '6bb454c2ae9db6ee64dc7f433f0fd3b839727f70c6c835943383346896272c40'
    }

    /**
     *  Note that the current authority set of the GRANDPA finality gadget has
     *  stalled. This will trigger a forced authority set change at the beginning
     *  of the next session, to be enacted `delay` blocks after that. The delay
     *  should be high enough to safely assume that the block signalling the
     *  forced change will not be re-orged (e.g. 1000 blocks). The GRANDPA voters
     *  will start the new authority set using the given finalized block as base.
     *  Only callable by root.
     */
    get asV2022(): {delay: number, bestFinalizedBlockNumber: number} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }
}

export class GrandpaReportEquivocationCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Grandpa.report_equivocation')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Report voter equivocation/misbehavior. This method will verify the
     *  equivocation proof and validate the given key ownership proof
     *  against the extracted offender. If both are valid, the offence
     *  will be reported.
     * 
     *  Since the weight of the extrinsic is 0, in order to avoid DoS by
     *  submission of invalid equivocation reports, a mandatory pre-validation of
     *  the extrinsic is implemented in a `SignedExtension`.
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Grandpa.report_equivocation') === '2c17e0cc8689d3a9ff22e793f8bfe646fd06a870bc9abcba005b8b772edc8677'
    }

    /**
     *  Report voter equivocation/misbehavior. This method will verify the
     *  equivocation proof and validate the given key ownership proof
     *  against the extracted offender. If both are valid, the offence
     *  will be reported.
     * 
     *  Since the weight of the extrinsic is 0, in order to avoid DoS by
     *  submission of invalid equivocation reports, a mandatory pre-validation of
     *  the extrinsic is implemented in a `SignedExtension`.
     */
    get asV2005(): {equivocationProof: v2005.GrandpaEquivocationProof, keyOwnerProof: v2005.KeyOwnerProof} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class GrandpaReportEquivocationUnsignedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Grandpa.report_equivocation_unsigned')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Report voter equivocation/misbehavior. This method will verify the
     *  equivocation proof and validate the given key ownership proof
     *  against the extracted offender. If both are valid, the offence
     *  will be reported.
     * 
     *  This extrinsic must be called unsigned and it is expected that only
     *  block authors will call it (validated in `ValidateUnsigned`), as such
     *  if the block author is defined it will be defined as the equivocation
     *  reporter.
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Grandpa.report_equivocation_unsigned') === '2c17e0cc8689d3a9ff22e793f8bfe646fd06a870bc9abcba005b8b772edc8677'
    }

    /**
     *  Report voter equivocation/misbehavior. This method will verify the
     *  equivocation proof and validate the given key ownership proof
     *  against the extracted offender. If both are valid, the offence
     *  will be reported.
     * 
     *  This extrinsic must be called unsigned and it is expected that only
     *  block authors will call it (validated in `ValidateUnsigned`), as such
     *  if the block author is defined it will be defined as the equivocation
     *  reporter.
     */
    get asV2015(): {equivocationProof: v2015.GrandpaEquivocationProof, keyOwnerProof: v2015.KeyOwnerProof} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }
}

export class GrandpaReportMisbehaviorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Grandpa.report_misbehavior')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Report some misbehavior.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Grandpa.report_misbehavior') === '4d309aa0bc23cb024a30b51638974c01a0e9527e63bd54e9f2a250ba41489f2f'
    }

    /**
     *  Report some misbehavior.
     */
    get asV1020(): {report: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpForceCleanHrmpCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.force_clean_hrmp')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  This extrinsic triggers the cleanup of all the HRMP storage items that
     *  a para may have. Normally this happens once per session, but this allows
     *  you to trigger the cleanup immediately for a specific parachain.
     * 
     *  Origin must be Root.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Hrmp.force_clean_hrmp') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     *  This extrinsic triggers the cleanup of all the HRMP storage items that
     *  a para may have. Normally this happens once per session, but this allows
     *  you to trigger the cleanup immediately for a specific parachain.
     * 
     *  Origin must be Root.
     */
    get asV9090(): {para: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     * This extrinsic triggers the cleanup of all the HRMP storage items that
     * a para may have. Normally this happens once per session, but this allows
     * you to trigger the cleanup immediately for a specific parachain.
     * 
     * Origin must be Root.
     * 
     * Number of inbound and outbound channels for `para` must be provided as witness data of weighing.
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Hrmp.force_clean_hrmp') === '6d445266a2edc9bbe1d2186a1974f7f3f588ab7369e71b81eff7ef89b2fd7a57'
    }

    /**
     * This extrinsic triggers the cleanup of all the HRMP storage items that
     * a para may have. Normally this happens once per session, but this allows
     * you to trigger the cleanup immediately for a specific parachain.
     * 
     * Origin must be Root.
     * 
     * Number of inbound and outbound channels for `para` must be provided as witness data of weighing.
     */
    get asV9170(): {para: number, inbound: number, outbound: number} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpForceOpenHrmpChannelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.force_open_hrmp_channel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Open a channel from a `sender` to a `recipient` `ParaId` using the Root origin. Although
     * opened by Root, the `max_capacity` and `max_message_size` are still subject to the Relay
     * Chain's configured limits.
     * 
     * Expected use is when one of the `ParaId`s involved in the channel is governed by the
     * Relay Chain, e.g. a common good parachain.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Hrmp.force_open_hrmp_channel') === '1d371021acfdf0ba68e1334173a7b34a1c083269c2b7e3f6024692dbd7118650'
    }

    /**
     * Open a channel from a `sender` to a `recipient` `ParaId` using the Root origin. Although
     * opened by Root, the `max_capacity` and `max_message_size` are still subject to the Relay
     * Chain's configured limits.
     * 
     * Expected use is when one of the `ParaId`s involved in the channel is governed by the
     * Relay Chain, e.g. a common good parachain.
     */
    get asV9320(): {sender: number, recipient: number, maxCapacity: number, maxMessageSize: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpForceProcessHrmpCloseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.force_process_hrmp_close')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force process HRMP close channel requests.
     * 
     *  If there are pending HRMP close channel requests, you can use this
     *  function process all of those requests immediately.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Hrmp.force_process_hrmp_close') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Force process HRMP close channel requests.
     * 
     *  If there are pending HRMP close channel requests, you can use this
     *  function process all of those requests immediately.
     */
    get asV9090(): null {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force process HRMP close channel requests.
     * 
     * If there are pending HRMP close channel requests, you can use this
     * function process all of those requests immediately.
     * 
     * Total number of closing channels must be provided as witness data of weighing.
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Hrmp.force_process_hrmp_close') === 'bbff5b4312625000db819c8e43a5a33d24b00331be3f9e0e32c792eca6dd854c'
    }

    /**
     * Force process HRMP close channel requests.
     * 
     * If there are pending HRMP close channel requests, you can use this
     * function process all of those requests immediately.
     * 
     * Total number of closing channels must be provided as witness data of weighing.
     */
    get asV9170(): {channels: number} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpForceProcessHrmpOpenCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.force_process_hrmp_open')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force process HRMP open channel requests.
     * 
     *  If there are pending HRMP open channel requests, you can use this
     *  function process all of those requests immediately.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Hrmp.force_process_hrmp_open') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Force process HRMP open channel requests.
     * 
     *  If there are pending HRMP open channel requests, you can use this
     *  function process all of those requests immediately.
     */
    get asV9090(): null {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force process HRMP open channel requests.
     * 
     * If there are pending HRMP open channel requests, you can use this
     * function process all of those requests immediately.
     * 
     * Total number of opening channels must be provided as witness data of weighing.
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Hrmp.force_process_hrmp_open') === 'bbff5b4312625000db819c8e43a5a33d24b00331be3f9e0e32c792eca6dd854c'
    }

    /**
     * Force process HRMP open channel requests.
     * 
     * If there are pending HRMP open channel requests, you can use this
     * function process all of those requests immediately.
     * 
     * Total number of opening channels must be provided as witness data of weighing.
     */
    get asV9170(): {channels: number} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpHrmpAcceptOpenChannelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.hrmp_accept_open_channel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Accept a pending open channel request from the given sender.
     * 
     *  The channel will be opened only on the next session boundary.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Hrmp.hrmp_accept_open_channel') === 'df73c5e1f40e14fb4e0ca9c4be4018d011ed0be4cb058df95899088220820d15'
    }

    /**
     *  Accept a pending open channel request from the given sender.
     * 
     *  The channel will be opened only on the next session boundary.
     */
    get asV9090(): {sender: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpHrmpCancelOpenRequestCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.hrmp_cancel_open_request')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  This cancels a pending open channel request. It can be canceled be either of the sender
     *  or the recipient for that request. The origin must be either of those.
     * 
     *  The cancelling happens immediately. It is not possible to cancel the request if it is
     *  already accepted.
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Hrmp.hrmp_cancel_open_request') === 'ad63c6e3452e8fbd9217f4fa7da9bc6efe307038eb9b4e5dc3f784e1d597ee1f'
    }

    /**
     *  This cancels a pending open channel request. It can be canceled be either of the sender
     *  or the recipient for that request. The origin must be either of those.
     * 
     *  The cancelling happens immediately. It is not possible to cancel the request if it is
     *  already accepted.
     */
    get asV9100(): {channelId: v9100.HrmpChannelId} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * This cancels a pending open channel request. It can be canceled be either of the sender
     * or the recipient for that request. The origin must be either of those.
     * 
     * The cancelling happens immediately. It is not possible to cancel the request if it is
     * already accepted.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Hrmp.hrmp_cancel_open_request') === '275d8119c62cb1d6786e5fa90c24e50e47fd498185b8f9c73010e74bdbd984cd'
    }

    /**
     * This cancels a pending open channel request. It can be canceled be either of the sender
     * or the recipient for that request. The origin must be either of those.
     * 
     * The cancelling happens immediately. It is not possible to cancel the request if it is
     * already accepted.
     */
    get asV9111(): {channelId: v9111.HrmpChannelId} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * This cancels a pending open channel request. It can be canceled by either of the sender
     * or the recipient for that request. The origin must be either of those.
     * 
     * The cancellation happens immediately. It is not possible to cancel the request if it is
     * already accepted.
     * 
     * Total number of open requests (i.e. `HrmpOpenChannelRequestsList`) must be provided as
     * witness data.
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Hrmp.hrmp_cancel_open_request') === '1a7a633e43ca10d6015d9e560d206e2f2add06f22aae354dda82e8d74806ff9b'
    }

    /**
     * This cancels a pending open channel request. It can be canceled by either of the sender
     * or the recipient for that request. The origin must be either of those.
     * 
     * The cancellation happens immediately. It is not possible to cancel the request if it is
     * already accepted.
     * 
     * Total number of open requests (i.e. `HrmpOpenChannelRequestsList`) must be provided as
     * witness data.
     */
    get asV9170(): {channelId: v9170.HrmpChannelId, openRequests: number} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpHrmpCloseChannelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.hrmp_close_channel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Initiate unilateral closing of a channel. The origin must be either the sender or the
     *  recipient in the channel being closed.
     * 
     *  The closure can only happen on a session change.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Hrmp.hrmp_close_channel') === 'ad63c6e3452e8fbd9217f4fa7da9bc6efe307038eb9b4e5dc3f784e1d597ee1f'
    }

    /**
     *  Initiate unilateral closing of a channel. The origin must be either the sender or the
     *  recipient in the channel being closed.
     * 
     *  The closure can only happen on a session change.
     */
    get asV9090(): {channelId: v9090.HrmpChannelId} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Initiate unilateral closing of a channel. The origin must be either the sender or the
     * recipient in the channel being closed.
     * 
     * The closure can only happen on a session change.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Hrmp.hrmp_close_channel') === '275d8119c62cb1d6786e5fa90c24e50e47fd498185b8f9c73010e74bdbd984cd'
    }

    /**
     * Initiate unilateral closing of a channel. The origin must be either the sender or the
     * recipient in the channel being closed.
     * 
     * The closure can only happen on a session change.
     */
    get asV9111(): {channelId: v9111.HrmpChannelId} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class HrmpHrmpInitOpenChannelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Hrmp.hrmp_init_open_channel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Initiate opening a channel from a parachain to a given recipient with given channel
     *  parameters.
     * 
     *  - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
     *  - `proposed_max_message_size` - specifies the maximum size of any of the messages.
     * 
     *  These numbers are a subject to the relay-chain configuration limits.
     * 
     *  The channel can be opened only after the recipient confirms it and only on a session
     *  change.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Hrmp.hrmp_init_open_channel') === 'c78d4e6da3f70d8bb4c2c00861e72fb4233df808203d0f148f572b5e16e04f71'
    }

    /**
     *  Initiate opening a channel from a parachain to a given recipient with given channel
     *  parameters.
     * 
     *  - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
     *  - `proposed_max_message_size` - specifies the maximum size of any of the messages.
     * 
     *  These numbers are a subject to the relay-chain configuration limits.
     * 
     *  The channel can be opened only after the recipient confirms it and only on a session
     *  change.
     */
    get asV9090(): {recipient: number, proposedMaxCapacity: number, proposedMaxMessageSize: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityAddRegistrarCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.add_registrar')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add a registrar to the system.
     * 
     *  The dispatch origin for this call must be `RegistrarOrigin` or `Root`.
     * 
     *  - `account`: the account of the registrar.
     * 
     *  Emits `RegistrarAdded` if successful.
     * 
     *  # <weight>
     *  - `O(R)` where `R` registrar-count (governance-bounded).
     *  - One storage mutation (codec `O(R)`).
     *  - One event.
     *  # </weight>
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Identity.add_registrar') === '7fb7672b764b0a4f0c4910fddefec0709628843df7ad0073a97eede13c53ca92'
    }

    /**
     *  Add a registrar to the system.
     * 
     *  The dispatch origin for this call must be `RegistrarOrigin` or `Root`.
     * 
     *  - `account`: the account of the registrar.
     * 
     *  Emits `RegistrarAdded` if successful.
     * 
     *  # <weight>
     *  - `O(R)` where `R` registrar-count (governance-bounded).
     *  - One storage mutation (codec `O(R)`).
     *  - One event.
     *  # </weight>
     */
    get asV1030(): {account: Uint8Array} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a registrar to the system.
     * 
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     * 
     * - `account`: the account of the registrar.
     * 
     * Emits `RegistrarAdded` if successful.
     * 
     * # <weight>
     * - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
     * - One storage mutation (codec `O(R)`).
     * - One event.
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Identity.add_registrar') === '2842be90a4599435dbefe83c28be9576bf64e6ff14aa9fa87c5fdb6255ef27b2'
    }

    /**
     * Add a registrar to the system.
     * 
     * The dispatch origin for this call must be `T::RegistrarOrigin`.
     * 
     * - `account`: the account of the registrar.
     * 
     * Emits `RegistrarAdded` if successful.
     * 
     * # <weight>
     * - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).
     * - One storage mutation (codec `O(R)`).
     * - One event.
     * # </weight>
     */
    get asV9291(): {account: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityAddSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.add_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add the given account to the sender's subs.
     * 
     *  Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     *  to the sender.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  sub identity of `sub`.
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Identity.add_sub') === '3a44789cb2db1c330353e6200ca05fb21d197f103560aec42b25fed99b8ede6d'
    }

    /**
     *  Add the given account to the sender's subs.
     * 
     *  Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     *  to the sender.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  sub identity of `sub`.
     */
    get asV2015(): {sub: Uint8Array, data: v2015.Data} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add the given account to the sender's subs.
     * 
     *  Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     *  to the sender.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  sub identity of `sub`.
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Identity.add_sub') === 'ef8fb13f5dc864a3db268a8f01b166d2deee87052a98309538fe8961be9020a9'
    }

    /**
     *  Add the given account to the sender's subs.
     * 
     *  Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     *  to the sender.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  sub identity of `sub`.
     */
    get asV2028(): {sub: v2028.LookupSource, data: v2028.Data} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add the given account to the sender's subs.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Identity.add_sub') === 'b7d02496580d984a1a588630bfbf580f423f08a761006f8706b057ac73069a38'
    }

    /**
     * Add the given account to the sender's subs.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get asV9111(): {sub: v9111.MultiAddress, data: v9111.Data} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityCancelRequestCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.cancel_request')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel a previous request.
     * 
     *  Payment: A previously reserved deposit is returned on success.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a
     *  registered identity.
     * 
     *  - `reg_index`: The index of the registrar whose judgement is no longer requested.
     * 
     *  Emits `JudgementUnrequested` if successful.
     * 
     *  # <weight>
     *  - `O(R + X)`.
     *  - One balance-reserve operation.
     *  - One storage mutation `O(R + X)`.
     *  - One event.
     *  # </weight>
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Identity.cancel_request') === '89d659d6a17ba36d0dfc7c90a7f043581d7fe980043895169d7dda1416ff7e5b'
    }

    /**
     *  Cancel a previous request.
     * 
     *  Payment: A previously reserved deposit is returned on success.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a
     *  registered identity.
     * 
     *  - `reg_index`: The index of the registrar whose judgement is no longer requested.
     * 
     *  Emits `JudgementUnrequested` if successful.
     * 
     *  # <weight>
     *  - `O(R + X)`.
     *  - One balance-reserve operation.
     *  - One storage mutation `O(R + X)`.
     *  - One event.
     *  # </weight>
     */
    get asV1030(): {regIndex: number} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityClearIdentityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.clear_identity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Clear an account's identity info and all sub-account and return all deposits.
     * 
     *  Payment: All reserved balances on the account are returned.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  identity.
     * 
     *  Emits `IdentityCleared` if successful.
     * 
     *  # <weight>
     *  - `O(R + S + X)`.
     *  - One balance-reserve operation.
     *  - Two storage mutations.
     *  - One event.
     *  # </weight>
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Identity.clear_identity') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Clear an account's identity info and all sub-account and return all deposits.
     * 
     *  Payment: All reserved balances on the account are returned.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  identity.
     * 
     *  Emits `IdentityCleared` if successful.
     * 
     *  # <weight>
     *  - `O(R + S + X)`.
     *  - One balance-reserve operation.
     *  - Two storage mutations.
     *  - One event.
     *  # </weight>
     */
    get asV1030(): null {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityKillIdentityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.kill_identity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove an account's identity and sub-account information and slash the deposits.
     * 
     *  Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     *  `Slash`. Verification request deposits are not returned; they should be cancelled
     *  manually using `cancel_request`.
     * 
     *  The dispatch origin for this call must be _Root_ or match `T::ForceOrigin`.
     * 
     *  - `target`: the account whose identity the judgement is upon. This must be an account
     *    with a registered identity.
     * 
     *  Emits `IdentityKilled` if successful.
     * 
     *  # <weight>
     *  - `O(R + S + X)`.
     *  - One balance-reserve operation.
     *  - Two storage mutations.
     *  - One event.
     *  # </weight>
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Identity.kill_identity') === 'cd19c54875d335772c471b877903ed3a260a7316fd1d201b12e013ae0a7dfe2d'
    }

    /**
     *  Remove an account's identity and sub-account information and slash the deposits.
     * 
     *  Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     *  `Slash`. Verification request deposits are not returned; they should be cancelled
     *  manually using `cancel_request`.
     * 
     *  The dispatch origin for this call must be _Root_ or match `T::ForceOrigin`.
     * 
     *  - `target`: the account whose identity the judgement is upon. This must be an account
     *    with a registered identity.
     * 
     *  Emits `IdentityKilled` if successful.
     * 
     *  # <weight>
     *  - `O(R + S + X)`.
     *  - One balance-reserve operation.
     *  - Two storage mutations.
     *  - One event.
     *  # </weight>
     */
    get asV1030(): {target: v1030.LookupSource} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Remove an account's identity and sub-account information and slash the deposits.
     * 
     *  Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     *  `Slash`. Verification request deposits are not returned; they should be cancelled
     *  manually using `cancel_request`.
     * 
     *  The dispatch origin for this call must be _Root_ or match `T::ForceOrigin`.
     * 
     *  - `target`: the account whose identity the judgement is upon. This must be an account
     *    with a registered identity.
     * 
     *  Emits `IdentityKilled` if successful.
     * 
     *  # <weight>
     *  - `O(R + S + X)`.
     *  - One balance-reserve operation.
     *  - `S + 2` storage mutations.
     *  - One event.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Identity.kill_identity') === '66d8abf7976ff596d8d614948b9d84cb24f0b898d88d24eb2cc035ae5e93c7b8'
    }

    /**
     *  Remove an account's identity and sub-account information and slash the deposits.
     * 
     *  Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     *  `Slash`. Verification request deposits are not returned; they should be cancelled
     *  manually using `cancel_request`.
     * 
     *  The dispatch origin for this call must be _Root_ or match `T::ForceOrigin`.
     * 
     *  - `target`: the account whose identity the judgement is upon. This must be an account
     *    with a registered identity.
     * 
     *  Emits `IdentityKilled` if successful.
     * 
     *  # <weight>
     *  - `O(R + S + X)`.
     *  - One balance-reserve operation.
     *  - `S + 2` storage mutations.
     *  - One event.
     *  # </weight>
     */
    get asV1050(): {target: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Remove an account's identity and sub-account information and slash the deposits.
     * 
     *  Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     *  `Slash`. Verification request deposits are not returned; they should be cancelled
     *  manually using `cancel_request`.
     * 
     *  The dispatch origin for this call must match `T::ForceOrigin`.
     * 
     *  - `target`: the account whose identity the judgement is upon. This must be an account
     *    with a registered identity.
     * 
     *  Emits `IdentityKilled` if successful.
     * 
     *  # <weight>
     *  - `O(R + S + X)`.
     *  - One balance-reserve operation.
     *  - `S + 2` storage mutations.
     *  - One event.
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Identity.kill_identity') === 'b473bcbba83335e310f2f681307dcf6b16b8d79ec99a4fb2202c34bed7de3b65'
    }

    /**
     *  Remove an account's identity and sub-account information and slash the deposits.
     * 
     *  Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     *  `Slash`. Verification request deposits are not returned; they should be cancelled
     *  manually using `cancel_request`.
     * 
     *  The dispatch origin for this call must match `T::ForceOrigin`.
     * 
     *  - `target`: the account whose identity the judgement is upon. This must be an account
     *    with a registered identity.
     * 
     *  Emits `IdentityKilled` if successful.
     * 
     *  # <weight>
     *  - `O(R + S + X)`.
     *  - One balance-reserve operation.
     *  - `S + 2` storage mutations.
     *  - One event.
     *  # </weight>
     */
    get asV2028(): {target: v2028.LookupSource} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     * 
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     * 
     * The dispatch origin for this call must match `T::ForceOrigin`.
     * 
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * 
     * Emits `IdentityKilled` if successful.
     * 
     * # <weight>
     * - `O(R + S + X)`.
     * - One balance-reserve operation.
     * - `S + 2` storage mutations.
     * - One event.
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Identity.kill_identity') === '8142da248a3023c20f65ce8f6287f9eaf75336ab8815cb15537149abcdd0c20c'
    }

    /**
     * Remove an account's identity and sub-account information and slash the deposits.
     * 
     * Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by
     * `Slash`. Verification request deposits are not returned; they should be cancelled
     * manually using `cancel_request`.
     * 
     * The dispatch origin for this call must match `T::ForceOrigin`.
     * 
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * 
     * Emits `IdentityKilled` if successful.
     * 
     * # <weight>
     * - `O(R + S + X)`.
     * - One balance-reserve operation.
     * - `S + 2` storage mutations.
     * - One event.
     * # </weight>
     */
    get asV9111(): {target: v9111.MultiAddress} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityProvideJudgementCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.provide_judgement')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Provide a judgement for an account's identity.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must be the account
     *  of the registrar whose index is `reg_index`.
     * 
     *  - `reg_index`: the index of the registrar whose judgement is being made.
     *  - `target`: the account whose identity the judgement is upon. This must be an account
     *    with a registered identity.
     *  - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * 
     *  Emits `JudgementGiven` if successful.
     * 
     *  # <weight>
     *  - `O(R + X)`.
     *  - One balance-transfer operation.
     *  - Up to one account-lookup operation.
     *  - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     *  - One event.
     *  # </weight>
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Identity.provide_judgement') === '8921aacefaea850d12d833946f2249c69867ed2c34eaedbfc09510053a096876'
    }

    /**
     *  Provide a judgement for an account's identity.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must be the account
     *  of the registrar whose index is `reg_index`.
     * 
     *  - `reg_index`: the index of the registrar whose judgement is being made.
     *  - `target`: the account whose identity the judgement is upon. This must be an account
     *    with a registered identity.
     *  - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * 
     *  Emits `JudgementGiven` if successful.
     * 
     *  # <weight>
     *  - `O(R + X)`.
     *  - One balance-transfer operation.
     *  - Up to one account-lookup operation.
     *  - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     *  - One event.
     *  # </weight>
     */
    get asV1030(): {regIndex: number, target: v1030.LookupSource, judgement: v1030.IdentityJudgement} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Provide a judgement for an account's identity.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must be the account
     *  of the registrar whose index is `reg_index`.
     * 
     *  - `reg_index`: the index of the registrar whose judgement is being made.
     *  - `target`: the account whose identity the judgement is upon. This must be an account
     *    with a registered identity.
     *  - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * 
     *  Emits `JudgementGiven` if successful.
     * 
     *  # <weight>
     *  - `O(R + X)`.
     *  - One balance-transfer operation.
     *  - Up to one account-lookup operation.
     *  - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     *  - One event.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Identity.provide_judgement') === '791c0e6b8f05476998f8aaac88c6d48f65d1a8c2670bcbd045a3ca694c679bd7'
    }

    /**
     *  Provide a judgement for an account's identity.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must be the account
     *  of the registrar whose index is `reg_index`.
     * 
     *  - `reg_index`: the index of the registrar whose judgement is being made.
     *  - `target`: the account whose identity the judgement is upon. This must be an account
     *    with a registered identity.
     *  - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * 
     *  Emits `JudgementGiven` if successful.
     * 
     *  # <weight>
     *  - `O(R + X)`.
     *  - One balance-transfer operation.
     *  - Up to one account-lookup operation.
     *  - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     *  - One event.
     *  # </weight>
     */
    get asV1050(): {regIndex: number, target: Uint8Array, judgement: v1050.IdentityJudgement} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Provide a judgement for an account's identity.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must be the account
     *  of the registrar whose index is `reg_index`.
     * 
     *  - `reg_index`: the index of the registrar whose judgement is being made.
     *  - `target`: the account whose identity the judgement is upon. This must be an account
     *    with a registered identity.
     *  - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * 
     *  Emits `JudgementGiven` if successful.
     * 
     *  # <weight>
     *  - `O(R + X)`.
     *  - One balance-transfer operation.
     *  - Up to one account-lookup operation.
     *  - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     *  - One event.
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Identity.provide_judgement') === 'abdb42b954610658025900cff996632ccf91d9ab5409152108d45ed12cca332b'
    }

    /**
     *  Provide a judgement for an account's identity.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must be the account
     *  of the registrar whose index is `reg_index`.
     * 
     *  - `reg_index`: the index of the registrar whose judgement is being made.
     *  - `target`: the account whose identity the judgement is upon. This must be an account
     *    with a registered identity.
     *  - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * 
     *  Emits `JudgementGiven` if successful.
     * 
     *  # <weight>
     *  - `O(R + X)`.
     *  - One balance-transfer operation.
     *  - Up to one account-lookup operation.
     *  - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     *  - One event.
     *  # </weight>
     */
    get asV2028(): {regIndex: number, target: v2028.LookupSource, judgement: v2028.IdentityJudgement} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Provide a judgement for an account's identity.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     * 
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * 
     * Emits `JudgementGiven` if successful.
     * 
     * # <weight>
     * - `O(R + X)`.
     * - One balance-transfer operation.
     * - Up to one account-lookup operation.
     * - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     * - One event.
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Identity.provide_judgement') === 'abe9fadae40ed65e9f7ddf86c0556a4a577958e2dc507fbb3f459268e87e7b6c'
    }

    /**
     * Provide a judgement for an account's identity.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     * 
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * 
     * Emits `JudgementGiven` if successful.
     * 
     * # <weight>
     * - `O(R + X)`.
     * - One balance-transfer operation.
     * - Up to one account-lookup operation.
     * - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     * - One event.
     * # </weight>
     */
    get asV9111(): {regIndex: number, target: v9111.MultiAddress, judgement: v9111.Judgement} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Provide a judgement for an account's identity.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     * 
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided.
     * 
     * Emits `JudgementGiven` if successful.
     * 
     * # <weight>
     * - `O(R + X)`.
     * - One balance-transfer operation.
     * - Up to one account-lookup operation.
     * - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     * - One event.
     * # </weight>
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Identity.provide_judgement') === '293a16f5e8f521553f92204e3de7063fafc7905d71ca7812337b8bc6e200bcf9'
    }

    /**
     * Provide a judgement for an account's identity.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `reg_index`.
     * 
     * - `reg_index`: the index of the registrar whose judgement is being made.
     * - `target`: the account whose identity the judgement is upon. This must be an account
     *   with a registered identity.
     * - `judgement`: the judgement of the registrar of index `reg_index` about `target`.
     * - `identity`: The hash of the [`IdentityInfo`] for that the judgement is provided.
     * 
     * Emits `JudgementGiven` if successful.
     * 
     * # <weight>
     * - `O(R + X)`.
     * - One balance-transfer operation.
     * - Up to one account-lookup operation.
     * - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.
     * - One event.
     * # </weight>
     */
    get asV9300(): {regIndex: number, target: v9300.MultiAddress, judgement: v9300.Judgement, identity: Uint8Array} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityQuitSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.quit_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove the sender as a sub-account.
     * 
     *  Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     *  to the sender (*not* the original depositor).
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  super-identity.
     * 
     *  NOTE: This should not normally be used, but is provided in the case that the non-
     *  controller of an account is maliciously registered as a sub-account.
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Identity.quit_sub') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Remove the sender as a sub-account.
     * 
     *  Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     *  to the sender (*not* the original depositor).
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  super-identity.
     * 
     *  NOTE: This should not normally be used, but is provided in the case that the non-
     *  controller of an account is maliciously registered as a sub-account.
     */
    get asV2015(): null {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityRemoveSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.remove_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove the given account from the sender's subs.
     * 
     *  Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     *  to the sender.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  sub identity of `sub`.
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Identity.remove_sub') === '38b23c3d326211a5d1355a68469ac48b2d3b137ed03e1feb95bb1da67e04c022'
    }

    /**
     *  Remove the given account from the sender's subs.
     * 
     *  Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     *  to the sender.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  sub identity of `sub`.
     */
    get asV2015(): {sub: Uint8Array} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Remove the given account from the sender's subs.
     * 
     *  Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     *  to the sender.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  sub identity of `sub`.
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Identity.remove_sub') === 'da8ee0ac4ebb51ed9fe85fbeb08186e79fab7cd448e7811d7ec80b60406fcee5'
    }

    /**
     *  Remove the given account from the sender's subs.
     * 
     *  Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     *  to the sender.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  sub identity of `sub`.
     */
    get asV2028(): {sub: v2028.LookupSource} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove the given account from the sender's subs.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Identity.remove_sub') === 'e2fd2e12228143db75d1c9482d7788894e6f224b6c362b650b73ac996f701805'
    }

    /**
     * Remove the given account from the sender's subs.
     * 
     * Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated
     * to the sender.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get asV9111(): {sub: v9111.MultiAddress} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityRenameSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.rename_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Alter the associated name of the given sub-account.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  sub identity of `sub`.
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Identity.rename_sub') === '3a44789cb2db1c330353e6200ca05fb21d197f103560aec42b25fed99b8ede6d'
    }

    /**
     *  Alter the associated name of the given sub-account.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  sub identity of `sub`.
     */
    get asV2015(): {sub: Uint8Array, data: v2015.Data} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Alter the associated name of the given sub-account.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  sub identity of `sub`.
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Identity.rename_sub') === 'ef8fb13f5dc864a3db268a8f01b166d2deee87052a98309538fe8961be9020a9'
    }

    /**
     *  Alter the associated name of the given sub-account.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  sub identity of `sub`.
     */
    get asV2028(): {sub: v2028.LookupSource, data: v2028.Data} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Alter the associated name of the given sub-account.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Identity.rename_sub') === 'b7d02496580d984a1a588630bfbf580f423f08a761006f8706b057ac73069a38'
    }

    /**
     * Alter the associated name of the given sub-account.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must have a registered
     * sub identity of `sub`.
     */
    get asV9111(): {sub: v9111.MultiAddress, data: v9111.Data} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentityRequestJudgementCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.request_judgement')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Request a judgement from a registrar.
     * 
     *  Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     *  given.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a
     *  registered identity.
     * 
     *  - `reg_index`: The index of the registrar whose judgement is requested.
     *  - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     * 
     *  ```nocompile
     *  Self::registrars(reg_index).uwnrap().fee
     *  ```
     * 
     *  Emits `JudgementRequested` if successful.
     * 
     *  # <weight>
     *  - `O(R + X)`.
     *  - One balance-reserve operation.
     *  - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.
     *  - One event.
     *  # </weight>
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Identity.request_judgement') === 'c6336282cbe5b8ccf3769cc13c92f532be2499335e3d52ebf566a888e92b5b7c'
    }

    /**
     *  Request a judgement from a registrar.
     * 
     *  Payment: At most `max_fee` will be reserved for payment to the registrar if judgement
     *  given.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a
     *  registered identity.
     * 
     *  - `reg_index`: The index of the registrar whose judgement is requested.
     *  - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:
     * 
     *  ```nocompile
     *  Self::registrars(reg_index).uwnrap().fee
     *  ```
     * 
     *  Emits `JudgementRequested` if successful.
     * 
     *  # <weight>
     *  - `O(R + X)`.
     *  - One balance-reserve operation.
     *  - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.
     *  - One event.
     *  # </weight>
     */
    get asV1030(): {regIndex: number, maxFee: bigint} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetAccountIdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_account_id')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Change the account associated with a registrar.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must be the account
     *  of the registrar whose index is `index`.
     * 
     *  - `index`: the index of the registrar whose fee is to be set.
     *  - `new`: the new account ID.
     * 
     *  # <weight>
     *  - `O(R)`.
     *  - One storage mutation `O(R)`.
     *  # </weight>
     */
    get isV1031(): boolean {
        return this._chain.getCallHash('Identity.set_account_id') === 'a333bb3ce3e314d48fcf93f14155097760db6249022181f1eb923c1343af6813'
    }

    /**
     *  Change the account associated with a registrar.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must be the account
     *  of the registrar whose index is `index`.
     * 
     *  - `index`: the index of the registrar whose fee is to be set.
     *  - `new`: the new account ID.
     * 
     *  # <weight>
     *  - `O(R)`.
     *  - One storage mutation `O(R)`.
     *  # </weight>
     */
    get asV1031(): {index: number, new: Uint8Array} {
        assert(this.isV1031)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Change the account associated with a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     * 
     * # <weight>
     * - `O(R)`.
     * - One storage mutation `O(R)`.
     * - Benchmark: 8.823 + R * 0.32 µs (min squares analysis)
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Identity.set_account_id') === '7c569a09ae3438c742df387f66c9e012ebdf2af1dfe1befa9aba3df316cee1aa'
    }

    /**
     * Change the account associated with a registrar.
     * 
     * The dispatch origin for this call must be _Signed_ and the sender must be the account
     * of the registrar whose index is `index`.
     * 
     * - `index`: the index of the registrar whose fee is to be set.
     * - `new`: the new account ID.
     * 
     * # <weight>
     * - `O(R)`.
     * - One storage mutation `O(R)`.
     * - Benchmark: 8.823 + R * 0.32 µs (min squares analysis)
     * # </weight>
     */
    get asV9291(): {index: number, new: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetFeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_fee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the fee required for a judgement to be requested from a registrar.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must be the account
     *  of the registrar whose index is `index`.
     * 
     *  - `index`: the index of the registrar whose fee is to be set.
     *  - `fee`: the new fee.
     * 
     *  # <weight>
     *  - `O(R)`.
     *  - One storage mutation `O(R)`.
     *  # </weight>
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Identity.set_fee') === '6418458414c3cef3d5c80c88232d781e76733c675303b2937b9cd30ae58d0fe4'
    }

    /**
     *  Set the fee required for a judgement to be requested from a registrar.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must be the account
     *  of the registrar whose index is `index`.
     * 
     *  - `index`: the index of the registrar whose fee is to be set.
     *  - `fee`: the new fee.
     * 
     *  # <weight>
     *  - `O(R)`.
     *  - One storage mutation `O(R)`.
     *  # </weight>
     */
    get asV1030(): {index: number, fee: bigint} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetFieldsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_fields')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the field information for a registrar.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must be the account
     *  of the registrar whose index is `index`.
     * 
     *  - `index`: the index of the registrar whose fee is to be set.
     *  - `fields`: the fields that the registrar concerns themselves with.
     * 
     *  # <weight>
     *  - `O(R)`.
     *  - One storage mutation `O(R)`.
     *  # </weight>
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Identity.set_fields') === 'b2c8998acd304e28e4f4a78e6a07f5bf7caf587532734dbd94b85c01a31c3e13'
    }

    /**
     *  Set the field information for a registrar.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must be the account
     *  of the registrar whose index is `index`.
     * 
     *  - `index`: the index of the registrar whose fee is to be set.
     *  - `fields`: the fields that the registrar concerns themselves with.
     * 
     *  # <weight>
     *  - `O(R)`.
     *  - One storage mutation `O(R)`.
     *  # </weight>
     */
    get asV1030(): {index: number, fields: bigint} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetIdentityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_identity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set an account's identity information and reserve the appropriate deposit.
     * 
     *  If the account already has identity information, the deposit is taken as part payment
     *  for the new deposit.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  identity.
     * 
     *  - `info`: The identity information.
     * 
     *  Emits `IdentitySet` if successful.
     * 
     *  # <weight>
     *  - `O(X + R)` where `X` additional-field-count (deposit-bounded).
     *  - At most two balance operations.
     *  - One storage mutation (codec `O(X + R)`).
     *  - One event.
     *  # </weight>
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Identity.set_identity') === '0a4b1e421517b2dbf295654a2c6c617cd7631b9de55c4fe17ff5e236ccdc7bdc'
    }

    /**
     *  Set an account's identity information and reserve the appropriate deposit.
     * 
     *  If the account already has identity information, the deposit is taken as part payment
     *  for the new deposit.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  identity.
     * 
     *  - `info`: The identity information.
     * 
     *  Emits `IdentitySet` if successful.
     * 
     *  # <weight>
     *  - `O(X + R)` where `X` additional-field-count (deposit-bounded).
     *  - At most two balance operations.
     *  - One storage mutation (codec `O(X + R)`).
     *  - One event.
     *  # </weight>
     */
    get asV1030(): {info: v1030.IdentityInfo} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set an account's identity information and reserve the appropriate deposit.
     * 
     *  If the account already has identity information, the deposit is taken as part payment
     *  for the new deposit.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  identity.
     * 
     *  - `info`: The identity information.
     * 
     *  Emits `IdentitySet` if successful.
     * 
     *  # <weight>
     *  - `O(X + R)` where `X` additional-field-count (deposit-bounded).
     *  - At most two balance operations.
     *  - One storage mutation (codec `O(X + R)`).
     *  - One event.
     *  # </weight>
     */
    get isV1032(): boolean {
        return this._chain.getCallHash('Identity.set_identity') === 'ab457704fd8cda5fee32e84ab7782778f4117cd54400c364cf7597eee5bc60ca'
    }

    /**
     *  Set an account's identity information and reserve the appropriate deposit.
     * 
     *  If the account already has identity information, the deposit is taken as part payment
     *  for the new deposit.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  identity.
     * 
     *  - `info`: The identity information.
     * 
     *  Emits `IdentitySet` if successful.
     * 
     *  # <weight>
     *  - `O(X + R)` where `X` additional-field-count (deposit-bounded).
     *  - At most two balance operations.
     *  - One storage mutation (codec `O(X + R)`).
     *  - One event.
     *  # </weight>
     */
    get asV1032(): {info: v1032.IdentityInfo} {
        assert(this.isV1032)
        return this._chain.decodeCall(this.call)
    }
}

export class IdentitySetSubsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Identity.set_subs')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the sub-accounts of the sender.
     * 
     *  Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     *  and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  identity.
     * 
     *  - `subs`: The identity's sub-accounts.
     * 
     *  # <weight>
     *  - `O(S)` where `S` subs-count (hard- and deposit-bounded).
     *  - At most two balance operations.
     *  - One storage mutation (codec `O(S)`); one storage-exists.
     *  # </weight>
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('Identity.set_subs') === 'f156a100857e71b9e1eab839801795e8569b63b49f6c30333c5bf12811cbbe73'
    }

    /**
     *  Set the sub-accounts of the sender.
     * 
     *  Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned
     *  and an amount `SubAccountDeposit` will be reserved for each item in `subs`.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have a registered
     *  identity.
     * 
     *  - `subs`: The identity's sub-accounts.
     * 
     *  # <weight>
     *  - `O(S)` where `S` subs-count (hard- and deposit-bounded).
     *  - At most two balance operations.
     *  - One storage mutation (codec `O(S)`); one storage-exists.
     *  # </weight>
     */
    get asV1030(): {subs: [Uint8Array, v1030.Data][]} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }
}

export class ImOnlineHeartbeatCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ImOnline.heartbeat')
        this._chain = ctx._chain
        this.call = call
    }

    get isV1020(): boolean {
        return this._chain.getCallHash('ImOnline.heartbeat') === '9074d299a1f94d61da5f8a14229fd31565347b61622aaefe47eb5ff1a1c721a3'
    }

    get asV1020(): {heartbeat: v1020.Heartbeat, signature: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Complexity: `O(K + E)` where K is length of `Keys` and E is length of
     *    `Heartbeat.network_state.external_address`
     * 
     *    - `O(K)`: decoding of length `K`
     *    - `O(E)`: decoding/encoding of length `E`
     *  - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,
     *    `ReceivedHeartbeats`
     *  - DbWrites: `ReceivedHeartbeats`
     *  # </weight>
     */
    get isV1062(): boolean {
        return this._chain.getCallHash('ImOnline.heartbeat') === 'ceb066f24cc1efdb862584018e591b1046da22acdc1c7daf8270a6f6f31baffe'
    }

    /**
     *  # <weight>
     *  - Complexity: `O(K + E)` where K is length of `Keys` and E is length of
     *    `Heartbeat.network_state.external_address`
     * 
     *    - `O(K)`: decoding of length `K`
     *    - `O(E)`: decoding/encoding of length `E`
     *  - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,
     *    `ReceivedHeartbeats`
     *  - DbWrites: `ReceivedHeartbeats`
     *  # </weight>
     */
    get asV1062(): {heartbeat: v1062.Heartbeat, signature: Uint8Array} {
        assert(this.isV1062)
        return this._chain.decodeCall(this.call)
    }
}

export class IndicesClaimCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Indices.claim')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Assign an previously unassigned index.
     * 
     *  Payment: `Deposit` is reserved from the sender account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `index`: the index to be claimed. This must not be in use.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - One reserve operation.
     *  - One event.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Indices.claim') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     *  Assign an previously unassigned index.
     * 
     *  Payment: `Deposit` is reserved from the sender account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `index`: the index to be claimed. This must not be in use.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - One reserve operation.
     *  - One event.
     *  # </weight>
     */
    get asV1050(): {index: number} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class IndicesForceTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Indices.force_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force an index to an account. This doesn't require a deposit. If the index is already
     *  held, then any deposit is reimbursed to its current owner.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `index`: the index to be (re-)assigned.
     *  - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - Up to one reserve operation.
     *  - One event.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Indices.force_transfer') === 'fb7b2e881b4e1febd039cce6ff2d158ae42a8e4ab080ad01ff5d71477b8a690a'
    }

    /**
     *  Force an index to an account. This doesn't require a deposit. If the index is already
     *  held, then any deposit is reimbursed to its current owner.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `index`: the index to be (re-)assigned.
     *  - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - Up to one reserve operation.
     *  - One event.
     *  # </weight>
     */
    get asV1050(): {new: Uint8Array, index: number} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Force an index to an account. This doesn't require a deposit. If the index is already
     *  held, then any deposit is reimbursed to its current owner.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `index`: the index to be (re-)assigned.
     *  - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     *  - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - Up to one reserve operation.
     *  - One event.
     *  -------------------
     *  - Base Weight: 26.83 µs
     *  - DB Weight:
     *     - Reads: Indices Accounts, System Account (original owner)
     *     - Writes: Indices Accounts, System Account (original owner)
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('Indices.force_transfer') === 'c512e4f612c8bf235b4e49fd86b93323981d8379e84e47bd23e3718caf3df8b7'
    }

    /**
     *  Force an index to an account. This doesn't require a deposit. If the index is already
     *  held, then any deposit is reimbursed to its current owner.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `index`: the index to be (re-)assigned.
     *  - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     *  - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - Up to one reserve operation.
     *  - One event.
     *  -------------------
     *  - Base Weight: 26.83 µs
     *  - DB Weight:
     *     - Reads: Indices Accounts, System Account (original owner)
     *     - Writes: Indices Accounts, System Account (original owner)
     *  # </weight>
     */
    get asV2007(): {new: Uint8Array, index: number, freeze: boolean} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force an index to an account. This doesn't require a deposit. If the index is already
     * held, then any deposit is reimbursed to its current owner.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `index`: the index to be (re-)assigned.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
     * 
     * Emits `IndexAssigned` if successful.
     * 
     * # <weight>
     * - `O(1)`.
     * - One storage mutation (codec `O(1)`).
     * - Up to one reserve operation.
     * - One event.
     * -------------------
     * - DB Weight:
     *    - Reads: Indices Accounts, System Account (original owner)
     *    - Writes: Indices Accounts, System Account (original owner)
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Indices.force_transfer') === 'e61051df8d4f14c6b048e5350fce76049ca6bdcd7144bea9248526afc7efad04'
    }

    /**
     * Force an index to an account. This doesn't require a deposit. If the index is already
     * held, then any deposit is reimbursed to its current owner.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `index`: the index to be (re-)assigned.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.
     * 
     * Emits `IndexAssigned` if successful.
     * 
     * # <weight>
     * - `O(1)`.
     * - One storage mutation (codec `O(1)`).
     * - Up to one reserve operation.
     * - One event.
     * -------------------
     * - DB Weight:
     *    - Reads: Indices Accounts, System Account (original owner)
     *    - Writes: Indices Accounts, System Account (original owner)
     * # </weight>
     */
    get asV9291(): {new: v9291.MultiAddress, index: number, freeze: boolean} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class IndicesFreeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Indices.free')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Free up an index owned by the sender.
     * 
     *  Payment: Any previous deposit placed for the index is unreserved in the sender account.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must own the index.
     * 
     *  - `index`: the index to be freed. This must be owned by the sender.
     * 
     *  Emits `IndexFreed` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - One reserve operation.
     *  - One event.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Indices.free') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     *  Free up an index owned by the sender.
     * 
     *  Payment: Any previous deposit placed for the index is unreserved in the sender account.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must own the index.
     * 
     *  - `index`: the index to be freed. This must be owned by the sender.
     * 
     *  Emits `IndexFreed` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - One reserve operation.
     *  - One event.
     *  # </weight>
     */
    get asV1050(): {index: number} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class IndicesFreezeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Indices.freeze')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Freeze an index so it will always point to the sender account. This consumes the deposit.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must have a
     *  non-frozen account `index`.
     * 
     *  - `index`: the index to be frozen in place.
     * 
     *  Emits `IndexFrozen` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - Up to one slash operation.
     *  - One event.
     *  -------------------
     *  - Base Weight: 30.86 µs
     *  - DB Weight: 1 Read/Write (Accounts)
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('Indices.freeze') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     *  Freeze an index so it will always point to the sender account. This consumes the deposit.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must have a
     *  non-frozen account `index`.
     * 
     *  - `index`: the index to be frozen in place.
     * 
     *  Emits `IndexFrozen` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - Up to one slash operation.
     *  - One event.
     *  -------------------
     *  - Base Weight: 30.86 µs
     *  - DB Weight: 1 Read/Write (Accounts)
     *  # </weight>
     */
    get asV2007(): {index: number} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }
}

export class IndicesTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Indices.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Assign an index already owned by the sender to another account. The balance reservation
     *  is effectively transferred to the new account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `index`: the index to be re-assigned. This must be owned by the sender.
     *  - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - One transfer operation.
     *  - One event.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Indices.transfer') === 'fb7b2e881b4e1febd039cce6ff2d158ae42a8e4ab080ad01ff5d71477b8a690a'
    }

    /**
     *  Assign an index already owned by the sender to another account. The balance reservation
     *  is effectively transferred to the new account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `index`: the index to be re-assigned. This must be owned by the sender.
     *  - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * 
     *  Emits `IndexAssigned` if successful.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One storage mutation (codec `O(1)`).
     *  - One transfer operation.
     *  - One event.
     *  # </weight>
     */
    get asV1050(): {new: Uint8Array, index: number} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Assign an index already owned by the sender to another account. The balance reservation
     * is effectively transferred to the new account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `index`: the index to be re-assigned. This must be owned by the sender.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * 
     * Emits `IndexAssigned` if successful.
     * 
     * # <weight>
     * - `O(1)`.
     * - One storage mutation (codec `O(1)`).
     * - One transfer operation.
     * - One event.
     * -------------------
     * - DB Weight:
     *    - Reads: Indices Accounts, System Account (recipient)
     *    - Writes: Indices Accounts, System Account (recipient)
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Indices.transfer') === 'c77fd2a50503781496b2edd730058264c58263dc5c6bcc3ed1bbc824532517e4'
    }

    /**
     * Assign an index already owned by the sender to another account. The balance reservation
     * is effectively transferred to the new account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `index`: the index to be re-assigned. This must be owned by the sender.
     * - `new`: the new owner of the index. This function is a no-op if it is equal to sender.
     * 
     * Emits `IndexAssigned` if successful.
     * 
     * # <weight>
     * - `O(1)`.
     * - One storage mutation (codec `O(1)`).
     * - One transfer operation.
     * - One event.
     * -------------------
     * - DB Weight:
     *    - Reads: Indices Accounts, System Account (recipient)
     *    - Writes: Indices Accounts, System Account (recipient)
     * # </weight>
     */
    get asV9291(): {new: v9291.MultiAddress, index: number} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class InitializerForceApproveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Initializer.force_approve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Issue a signal to the consensus engine to forcibly act as though all parachain
     *  blocks in all relay chain blocks up to and including the given number in the current
     *  chain are valid and should be finalized.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Initializer.force_approve') === 'aa2b79ecc12cda7c6325357609f0dde737428c5b092dab0769d4e105b22bd955'
    }

    /**
     *  Issue a signal to the consensus engine to forcibly act as though all parachain
     *  blocks in all relay chain blocks up to and including the given number in the current
     *  chain are valid and should be finalized.
     */
    get asV9090(): {upTo: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class MultisigApproveAsMultiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Multisig.approve_as_multi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  ----------------------------------
     *  - Base Weight:
     *      - Create: 44.71 + 0.088 * S
     *      - Approve: 31.48 + 0.116 * S
     *  - DB Weight:
     *      - Read: Multisig Storage, [Caller Account]
     *      - Write: Multisig Storage, [Caller Account]
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Multisig.approve_as_multi') === '3c68db997397f75e3ae5e9c2d20a1518a8d503aa31785d4ef6db71bf1ecb0136'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  ----------------------------------
     *  - Base Weight:
     *      - Create: 44.71 + 0.088 * S
     *      - Approve: 31.48 + 0.116 * S
     *  - DB Weight:
     *      - Read: Multisig Storage, [Caller Account]
     *      - Write: Multisig Storage, [Caller Account]
     *  # </weight>
     */
    get asV2005(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v2005.Timepoint | undefined), callHash: Uint8Array} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  ----------------------------------
     *  - Base Weight:
     *      - Create: 44.71 + 0.088 * S
     *      - Approve: 31.48 + 0.116 * S
     *  - DB Weight:
     *      - Read: Multisig Storage, [Caller Account]
     *      - Write: Multisig Storage, [Caller Account]
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Multisig.approve_as_multi') === '615a5baaaa889f9e30839c70485b8c752e5eb050a85a23102b2f9f4c301be63a'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  ----------------------------------
     *  - Base Weight:
     *      - Create: 44.71 + 0.088 * S
     *      - Approve: 31.48 + 0.116 * S
     *  - DB Weight:
     *      - Read: Multisig Storage, [Caller Account]
     *      - Write: Multisig Storage, [Caller Account]
     *  # </weight>
     */
    get asV2011(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v2011.Timepoint | undefined), callHash: Uint8Array, maxWeight: bigint} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     * 
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     * # <weight>
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * ----------------------------------
     * - DB Weight:
     *     - Read: Multisig Storage, [Caller Account]
     *     - Write: Multisig Storage, [Caller Account]
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Multisig.approve_as_multi') === 'af4617697c04ce56b4748943a851b51ff5b80d64991c7ecf495a4651ff57debb'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     * 
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     * # <weight>
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * ----------------------------------
     * - DB Weight:
     *     - Read: Multisig Storage, [Caller Account]
     *     - Write: Multisig Storage, [Caller Account]
     * # </weight>
     */
    get asV9291(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v9291.Timepoint | undefined), callHash: Uint8Array, maxWeight: v9291.Weight} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     * 
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     * # <weight>
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * ----------------------------------
     * - DB Weight:
     *     - Read: Multisig Storage, [Caller Account]
     *     - Write: Multisig Storage, [Caller Account]
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Multisig.approve_as_multi') === '88561668497d8fdee3be21d28e6e68bc1cd9568f418501a4b294fe2b9803acb4'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     * 
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     * # <weight>
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * ----------------------------------
     * - DB Weight:
     *     - Read: Multisig Storage, [Caller Account]
     *     - Write: Multisig Storage, [Caller Account]
     * # </weight>
     */
    get asV9320(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v9320.Timepoint | undefined), callHash: Uint8Array, maxWeight: v9320.Weight} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class MultisigAsMultiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Multisig.as_multi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call. Calls must each fulfil the `IsCallable`
     *  filter.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  -------------------------------
     *  - Base Weight:
     *      - Create: 46.55 + 0.089 * S µs
     *      - Approve: 34.03 + .112 * S µs
     *      - Complete: 40.36 + .225 * S µs
     *  - DB Weight:
     *      - Reads: Multisig Storage, [Caller Account]
     *      - Writes: Multisig Storage, [Caller Account]
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '83b8a4cd738afb558ae6af75bfaabe8aa21605f7dff867b7019cea2247cfb2cc'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call. Calls must each fulfil the `IsCallable`
     *  filter.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  -------------------------------
     *  - Base Weight:
     *      - Create: 46.55 + 0.089 * S µs
     *      - Approve: 34.03 + .112 * S µs
     *      - Complete: 40.36 + .225 * S µs
     *  - DB Weight:
     *      - Reads: Multisig Storage, [Caller Account]
     *      - Writes: Multisig Storage, [Caller Account]
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2005(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v2005.Timepoint | undefined), call: v2005.Type_188} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call. Calls must each fulfil the `IsCallable`
     *  filter.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  -------------------------------
     *  - Base Weight:
     *      - Create: 46.55 + 0.089 * S µs
     *      - Approve: 34.03 + .112 * S µs
     *      - Complete: 40.36 + .225 * S µs
     *  - DB Weight:
     *      - Reads: Multisig Storage, [Caller Account]
     *      - Writes: Multisig Storage, [Caller Account]
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '8108c600a195194b5ae3a966aec86a8e46c8d3078437c5fc8b025fc5a7ee49d3'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call. Calls must each fulfil the `IsCallable`
     *  filter.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  -------------------------------
     *  - Base Weight:
     *      - Create: 46.55 + 0.089 * S µs
     *      - Approve: 34.03 + .112 * S µs
     *      - Complete: 40.36 + .225 * S µs
     *  - DB Weight:
     *      - Reads: Multisig Storage, [Caller Account]
     *      - Writes: Multisig Storage, [Caller Account]
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2007(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v2007.Timepoint | undefined), call: v2007.Type_189} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  -------------------------------
     *  - Base Weight:
     *      - Create:          41.89 + 0.118 * S + .002 * Z µs
     *      - Create w/ Store: 53.57 + 0.119 * S + .003 * Z µs
     *      - Approve:         31.39 + 0.136 * S + .002 * Z µs
     *      - Complete:        39.94 + 0.26  * S + .002 * Z µs
     *  - DB Weight:
     *      - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)
     *      - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '548dea53ff79fe99438cf591950a533c93f9772d03a3995ec72a80376fcae222'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `DepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `DepositBase + threshold * DepositFactor`.
     *  -------------------------------
     *  - Base Weight:
     *      - Create:          41.89 + 0.118 * S + .002 * Z µs
     *      - Create w/ Store: 53.57 + 0.119 * S + .003 * Z µs
     *      - Approve:         31.39 + 0.136 * S + .002 * Z µs
     *      - Complete:        39.94 + 0.26  * S + .002 * Z µs
     *  - DB Weight:
     *      - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)
     *      - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2011(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v2011.Timepoint | undefined), call: Uint8Array, storeCall: boolean, maxWeight: bigint} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)
     *     - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)
     * - Plus Call Weight
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === 'f62d383b8db5d9025f2e3e98181c8439346292d755afd9729e7168a703e7be01'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)
     *     - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)
     * - Plus Call Weight
     * # </weight>
     */
    get asV9291(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v9291.Timepoint | undefined), call: Uint8Array, storeCall: boolean, maxWeight: v9291.Weight} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '62046093aad39857248edfa9a55f850ca4b9d7d06a0edd8feb21de0b8c4ee938'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get asV9320(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v9320.Timepoint | undefined), call: v9320.Call, maxWeight: v9320.Weight} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '08665be02d53231962b2da1d7eb6c598270788b041e00c5b9d18e90496071ae1'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get asV9340(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v9340.Timepoint | undefined), call: v9340.Call, maxWeight: v9340.Weight} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '172ef69e0a0cf9e6fe5cee065e0698814363ec8f0257e3b93add6c94ef99fef1'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get asV9350(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v9350.Timepoint | undefined), call: v9350.Call, maxWeight: v9350.Weight} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Multisig.as_multi') === '441c2e108f47ccde3d39862b67093064e14101d5168f94873683870f6263ec1e'
    }

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     * 
     * If there are enough, then dispatch the call.
     * 
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     * 
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     * 
     * # <weight>
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     *   taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     * -------------------------------
     * - DB Weight:
     *     - Reads: Multisig Storage, [Caller Account]
     *     - Writes: Multisig Storage, [Caller Account]
     * - Plus Call Weight
     * # </weight>
     */
    get asV9370(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v9370.Timepoint | undefined), call: v9370.Call, maxWeight: v9370.Weight} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class MultisigAsMultiThreshold1Call {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Multisig.as_multi_threshold_1')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - Base Weight: 33.72 + 0.002 * Z µs
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'ce479bb677f859127310a54e24695add0037e1d870336f4ecf6c4b8e8213095d'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - Base Weight: 33.72 + 0.002 * Z µs
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2011(): {otherSignatories: Uint8Array[], call: v2011.Type_190} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - Base Weight: 33.72 + 0.002 * Z µs
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'f71f0b4d9e36f54c15d2720f72b2bd48253b3180a3d7a10304703c27ccf7fc70'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - Base Weight: 33.72 + 0.002 * Z µs
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2013(): {otherSignatories: Uint8Array[], call: v2013.Type_190} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - Base Weight: 33.72 + 0.002 * Z µs
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '51320eccfacaea5a349e9a9e9cc3b2b1b4e4d8b4f9209069354be4502023402f'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - Base Weight: 33.72 + 0.002 * Z µs
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2015(): {otherSignatories: Uint8Array[], call: v2015.Type_192} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - Base Weight: 33.72 + 0.002 * Z µs
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'f7f4ced48d60990a99ecc7cc0016217f124217f16389a93439430aefe9437a57'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - Base Weight: 33.72 + 0.002 * Z µs
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2022(): {otherSignatories: Uint8Array[], call: v2022.Type_192} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - Base Weight: 33.72 + 0.002 * Z µs
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '2f3914851e220214b073945429982a9afb82d5494b38a5ce6e16ddccd36afce3'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - Base Weight: 33.72 + 0.002 * Z µs
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2023(): {otherSignatories: Uint8Array[], call: v2023.Type_194} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - Base Weight: 33.72 + 0.002 * Z µs
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '01494657e1f208b151bbcca1261cc01c7af36f6b180266d312197cc10085b446'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - Base Weight: 33.72 + 0.002 * Z µs
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2024(): {otherSignatories: Uint8Array[], call: v2024.Type_194} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '666614f6df0172237e4dc9cf53915434803e1d000c5038c7912b519262fbcaa5'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2025(): {otherSignatories: Uint8Array[], call: v2025.Type_195} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'b2bd7646447a07d2a7530314bb8a89161701b017adbf62b7dce65aa567df4f9d'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2026(): {otherSignatories: Uint8Array[], call: v2026.Type_194} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '7c348b4d69f8096e1279b3a5f2e6a2b8c884fa028f8ebde97df5b586cfb5c55d'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2028(): {otherSignatories: Uint8Array[], call: v2028.Type_199} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'b5541b547aebb5b05e6a2102ac2aa43d14becf923d634e44fdf0fbeb279b4217'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2029(): {otherSignatories: Uint8Array[], call: v2029.Type_199} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'c5d97a22186107250247e7921433578a621f3dd8c1f8f3e75218d76a5af3617d'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV2030(): {otherSignatories: Uint8Array[], call: v2030.Type_138} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'b3c3cd6a81cc01a2285e76f75dfc2c3b27be806565e0772f84fc022734566854'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV9010(): {otherSignatories: Uint8Array[], call: v9010.Type_138} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '6b06624370f6da39b6d910a502af78d4f91cb6a6d3aa92b86b37a8c19f51c880'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV9030(): {otherSignatories: Uint8Array[], call: v9030.Type_138} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'd6772a39713c5e51d454de8e1313f5f398e3481987171463d96641a68e591cd5'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV9040(): {otherSignatories: Uint8Array[], call: v9040.Type_138} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'aaba84e98d2f1f8e6f989162f8b69e035265d93b68d535a55f60621dabc5dfe1'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV9050(): {otherSignatories: Uint8Array[], call: v9050.Type_139} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '4709e814e8de4d9979404776e0753953f6bc8777839f893d7b076bf10caf48f9'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV9080(): {otherSignatories: Uint8Array[], call: v9080.Type_138} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '866677b9ce301bf4f3762715acef55713cab150e5b5450cd63f7f31f599acaa0'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV9090(): {otherSignatories: Uint8Array[], call: v9090.Type_138} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '7e4b6f3d3e09785346ca91aa92ccdeb71c7471743199040f467126b558518d62'
    }

    /**
     *  Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `other_signatories`: The accounts (other than the sender) who are part of the
     *  multi-signature, but do not participate in the approval process.
     *  - `call`: The call to be executed.
     * 
     *  Result is equivalent to the dispatched result.
     * 
     *  # <weight>
     *  O(Z + C) where Z is the length of the call and C its execution weight.
     *  -------------------------------
     *  - DB Weight: None
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV9100(): {otherSignatories: Uint8Array[], call: v9100.Type_138} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '13858d93879a13104471019abfca58447629b55fe2053285cb064a0328ba42bf'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9111(): {otherSignatories: Uint8Array[], call: v9111.Call} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '99b4abb86dd7c18f10449374ad084dbae3a41c1c87ee08e9e1514158f2cad8ed'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9122(): {otherSignatories: Uint8Array[], call: v9122.Call} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '2425bdcc218bfe551cdd4b58f19c2875ec95c9d5d8e3516a279cf0c652399d4e'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9130(): {otherSignatories: Uint8Array[], call: v9130.Call} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'f89cc9be791e4471152b25c85c34a465c8cffa8ca92d435b47a71226782b3b12'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9160(): {otherSignatories: Uint8Array[], call: v9160.Call} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '571e8b385a7580d6d9d82bc6adde3513116647acda67c7e531a59cf26fc183bb'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9170(): {otherSignatories: Uint8Array[], call: v9170.Call} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '48f57b3ce6e3e04cacd731e159cd6adceda57654051a4b21b929d8ef10cc11c8'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9180(): {otherSignatories: Uint8Array[], call: v9180.Call} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'ce790bfebcdbc2e5a9473ab422f8bfa8f037b3b390d1091abf09cb4ee83099ab'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9190(): {otherSignatories: Uint8Array[], call: v9190.Call} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'd821c0b947db4ca2a35551dbc512027a3ae83f7bb1f8a8e0200fafb4e23c5237'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9220(): {otherSignatories: Uint8Array[], call: v9220.Call} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '96617a52e5298f6f775947a320a41fdd80ca2b3fc3272eb1e37a1d2c4e0fadaf'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9230(): {otherSignatories: Uint8Array[], call: v9230.Call} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '741115bed84cf339fcb56871198d1134ce6337760b09f313a436ac2d858dfcce'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9250(): {otherSignatories: Uint8Array[], call: v9250.Call} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'd4ea7f5cdd79f22f8f2f692bd7988df159690b1bf0d948741ddb2d265f456d4f'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9271(): {otherSignatories: Uint8Array[], call: v9271.Call} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '10efc022504508e6a68e7bdbab3fb16b02cadcf4f47a65df7e12dbd0e2ab9250'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9291(): {otherSignatories: Uint8Array[], call: v9291.Call} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '8ce160aed47109e71225e45953c60df2ea8257f14882e46d066d1e0b478ff039'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9300(): {otherSignatories: Uint8Array[], call: v9300.Call} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'c061206379873c7263a66619956f44de2518274e7eec4c7c7597e68999378a7b'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9320(): {otherSignatories: Uint8Array[], call: v9320.Call} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '1b9adbf29acee4f09adba3bdfea699a1c60186989cd0c314d2fab9a02e426f4b'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9340(): {otherSignatories: Uint8Array[], call: v9340.Call} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === 'd4f71b0dbbf267cab793a8a2432091afeb887d1f5d448e7b4c93420c0ae7ad47'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9350(): {otherSignatories: Uint8Array[], call: v9350.Call} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Multisig.as_multi_threshold_1') === '7bdd2975063d125f3963503a7f5fe0b5306fb5382bb1dd7fbbabdf0e26b382c5'
    }

    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     * 
     * Result is equivalent to the dispatched result.
     * 
     * # <weight>
     * O(Z + C) where Z is the length of the call and C its execution weight.
     * -------------------------------
     * - DB Weight: None
     * - Plus Call Weight
     * # </weight>
     */
    get asV9370(): {otherSignatories: Uint8Array[], call: v9370.Call} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class MultisigCancelAsMultiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Multisig.cancel_as_multi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     *  for this operation will be unreserved on success.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `timepoint`: The timepoint (block number and transaction index) of the first approval
     *  transaction for this dispatch.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - One event.
     *  - I/O: 1 read `O(S)`, one remove.
     *  - Storage: removes one item.
     *  ----------------------------------
     *  - Base Weight: 37.6 + 0.084 * S
     *  - DB Weight:
     *      - Read: Multisig Storage, [Caller Account]
     *      - Write: Multisig Storage, [Caller Account]
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Multisig.cancel_as_multi') === '4ccc75a4f739c659f177e3df98fba2ea59ddade74c4ebccd51b2fc4c52e923af'
    }

    /**
     *  Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     *  for this operation will be unreserved on success.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `timepoint`: The timepoint (block number and transaction index) of the first approval
     *  transaction for this dispatch.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - One event.
     *  - I/O: 1 read `O(S)`, one remove.
     *  - Storage: removes one item.
     *  ----------------------------------
     *  - Base Weight: 37.6 + 0.084 * S
     *  - DB Weight:
     *      - Read: Multisig Storage, [Caller Account]
     *      - Write: Multisig Storage, [Caller Account]
     *  # </weight>
     */
    get asV2005(): {threshold: number, otherSignatories: Uint8Array[], timepoint: v2005.Timepoint, callHash: Uint8Array} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class NicksClearNameCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Nicks.clear_name')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Clear an account's name and return the deposit. Fails if the account was not named.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - One balance operation.
     *  - One storage read/write.
     *  - One event.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Nicks.clear_name') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Clear an account's name and return the deposit. Fails if the account was not named.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - One balance operation.
     *  - One storage read/write.
     *  - One event.
     *  # </weight>
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class NicksForceNameCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Nicks.force_name')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set a third-party account's name with no deposit.
     * 
     *  No length checking is done on the name.
     * 
     *  The dispatch origin for this call must be _Root_ or match `T::ForceOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  - At most one balance operation.
     *  - One storage read/write.
     *  - One event.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Nicks.force_name') === 'fc75d79d94da141e6c844c00de03fdf00dfc4fe67e3d98a55524d75c8712a128'
    }

    /**
     *  Set a third-party account's name with no deposit.
     * 
     *  No length checking is done on the name.
     * 
     *  The dispatch origin for this call must be _Root_ or match `T::ForceOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  - At most one balance operation.
     *  - One storage read/write.
     *  - One event.
     *  # </weight>
     */
    get asV1020(): {target: v1020.LookupSource, name: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class NicksKillNameCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Nicks.kill_name')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove an account's name and take charge of the deposit.
     * 
     *  Fails if `who` has not been named. The deposit is dealt with through `T::Slashed`
     *  imbalance handler.
     * 
     *  The dispatch origin for this call must be _Root_ or match `T::ForceOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  - One unbalanced handler (probably a balance transfer)
     *  - One storage read/write.
     *  - One event.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Nicks.kill_name') === 'cd19c54875d335772c471b877903ed3a260a7316fd1d201b12e013ae0a7dfe2d'
    }

    /**
     *  Remove an account's name and take charge of the deposit.
     * 
     *  Fails if `who` has not been named. The deposit is dealt with through `T::Slashed`
     *  imbalance handler.
     * 
     *  The dispatch origin for this call must be _Root_ or match `T::ForceOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  - One unbalanced handler (probably a balance transfer)
     *  - One storage read/write.
     *  - One event.
     *  # </weight>
     */
    get asV1020(): {target: v1020.LookupSource} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class NicksSetNameCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Nicks.set_name')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set an account's name. The name should be a UTF-8-encoded string by convention, though
     *  we don't check it.
     * 
     *  The name may not be more than `T::MaxLength` bytes, nor less than `T::MinLength` bytes.
     * 
     *  If the account doesn't already have a name, then a fee of `ReservationFee` is reserved
     *  in the account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - At most one balance operation.
     *  - One storage read/write.
     *  - One event.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Nicks.set_name') === '208de23d9c973b8e20989bcd5c665f8f0228ecf503bffa200d5950e00a5c2f16'
    }

    /**
     *  Set an account's name. The name should be a UTF-8-encoded string by convention, though
     *  we don't check it.
     * 
     *  The name may not be more than `T::MaxLength` bytes, nor less than `T::MinLength` bytes.
     * 
     *  If the account doesn't already have a name, then a fee of `ReservationFee` is reserved
     *  in the account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - At most one balance operation.
     *  - One storage read/write.
     *  - One event.
     *  # </weight>
     */
    get asV1020(): {name: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class NisFundDeficitCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Nis.fund_deficit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Ensure we have sufficient funding for all potential payouts.
     * 
     * - `origin`: Must be accepted by `FundOrigin`.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Nis.fund_deficit') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * Ensure we have sufficient funding for all potential payouts.
     * 
     * - `origin`: Must be accepted by `FundOrigin`.
     */
    get asV9340(): null {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }
}

export class NisPlaceBidCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Nis.place_bid')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Place a bid.
     * 
     * Origin must be Signed, and account must have at least `amount` in free balance.
     * 
     * - `amount`: The amount of the bid; these funds will be reserved, and if/when
     *   consolidated, removed. Must be at least `MinBid`.
     * - `duration`: The number of periods before which the newly consolidated bid may be
     *   thawed. Must be greater than 1 and no more than `QueueCount`.
     * 
     * Complexities:
     * - `Queues[duration].len()` (just take max).
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Nis.place_bid') === 'a3c04aee6fb2869525c82baa3cce1aa56677672cb0687b0ebdf99955755806a3'
    }

    /**
     * Place a bid.
     * 
     * Origin must be Signed, and account must have at least `amount` in free balance.
     * 
     * - `amount`: The amount of the bid; these funds will be reserved, and if/when
     *   consolidated, removed. Must be at least `MinBid`.
     * - `duration`: The number of periods before which the newly consolidated bid may be
     *   thawed. Must be greater than 1 and no more than `QueueCount`.
     * 
     * Complexities:
     * - `Queues[duration].len()` (just take max).
     */
    get asV9340(): {amount: bigint, duration: number} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }
}

export class NisRetractBidCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Nis.retract_bid')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Retract a previously placed bid.
     * 
     * Origin must be Signed, and the account should have previously issued a still-active bid
     * of `amount` for `duration`.
     * 
     * - `amount`: The amount of the previous bid.
     * - `duration`: The duration of the previous bid.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Nis.retract_bid') === 'a3c04aee6fb2869525c82baa3cce1aa56677672cb0687b0ebdf99955755806a3'
    }

    /**
     * Retract a previously placed bid.
     * 
     * Origin must be Signed, and the account should have previously issued a still-active bid
     * of `amount` for `duration`.
     * 
     * - `amount`: The amount of the previous bid.
     * - `duration`: The duration of the previous bid.
     */
    get asV9340(): {amount: bigint, duration: number} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }
}

export class NisThawCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Nis.thaw')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Reduce or remove an outstanding receipt, placing the according proportion of funds into
     * the account of the owner.
     * 
     * - `origin`: Must be Signed and the account must be the owner of the receipt `index` as
     *   well as any fungible counterpart.
     * - `index`: The index of the receipt.
     * - `portion`: If `Some`, then only the given portion of the receipt should be thawed. If
     *   `None`, then all of it should be.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Nis.thaw') === '9cb0b40fa157e428896c1e55c9b30a1e6c7ef13d38157b2ef0c4c1b5a927dd59'
    }

    /**
     * Reduce or remove an outstanding receipt, placing the according proportion of funds into
     * the account of the owner.
     * 
     * - `origin`: Must be Signed and the account must be the owner of the receipt `index` as
     *   well as any fungible counterpart.
     * - `index`: The index of the receipt.
     * - `portion`: If `Some`, then only the given portion of the receipt should be thawed. If
     *   `None`, then all of it should be.
     */
    get asV9340(): {index: number, portion: (bigint | undefined)} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }
}

export class NisCounterpartBalancesForceTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NisCounterpartBalances.force_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source account may be
     * specified.
     * # <weight>
     * - Same as transfer, but additional read and write because the source account is not
     *   assumed to be in the overlay.
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('NisCounterpartBalances.force_transfer') === 'e5944fbe8224a17fe49f9c1d1d01efaf87fb1778fd39618512af54c9ba6f9dff'
    }

    /**
     * Exactly as `transfer`, except the origin must be root and the source account may be
     * specified.
     * # <weight>
     * - Same as transfer, but additional read and write because the source account is not
     *   assumed to be in the overlay.
     * # </weight>
     */
    get asV9340(): {source: v9340.MultiAddress, dest: v9340.MultiAddress, value: bigint} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }
}

export class NisCounterpartBalancesForceUnreserveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NisCounterpartBalances.force_unreserve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unreserve some balance from a user by force.
     * 
     * Can only be called by ROOT.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('NisCounterpartBalances.force_unreserve') === '30bc48977e2a7ad3fc8ac014948ded50fc54886bad9a1f65b02bb64f27d8a6be'
    }

    /**
     * Unreserve some balance from a user by force.
     * 
     * Can only be called by ROOT.
     */
    get asV9340(): {who: v9340.MultiAddress, amount: bigint} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }
}

export class NisCounterpartBalancesSetBalanceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NisCounterpartBalances.set_balance')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     * also alter the total issuance of the system (`TotalIssuance`) appropriately.
     * If the new free or reserved balance is below the existential deposit,
     * it will reset the account nonce (`frame_system::AccountNonce`).
     * 
     * The dispatch origin for this call is `root`.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('NisCounterpartBalances.set_balance') === 'beb82909d38c015bc075ff8b107e47a02f8772bf5cf681d6cd84ef685e448a8f'
    }

    /**
     * Set the balances of a given account.
     * 
     * This will alter `FreeBalance` and `ReservedBalance` in storage. it will
     * also alter the total issuance of the system (`TotalIssuance`) appropriately.
     * If the new free or reserved balance is below the existential deposit,
     * it will reset the account nonce (`frame_system::AccountNonce`).
     * 
     * The dispatch origin for this call is `root`.
     */
    get asV9340(): {who: v9340.MultiAddress, newFree: bigint, newReserved: bigint} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }
}

export class NisCounterpartBalancesTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NisCounterpartBalances.transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the transactor.
     * 
     * # <weight>
     * - Dependent on arguments but not critical, given proper implementations for input config
     *   types. See related functions below.
     * - It contains a limited number of reads and writes internally and no complex
     *   computation.
     * 
     * Related functions:
     * 
     *   - `ensure_can_withdraw` is always called internally but has a bounded complexity.
     *   - Transferring balances to accounts that did not exist before will cause
     *     `T::OnNewAccount::on_new_account` to be called.
     *   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
     *   - `transfer_keep_alive` works the same way as `transfer`, but has an additional check
     *     that the transfer will not kill the origin account.
     * ---------------------------------
     * - Origin account is already in memory, so no DB operations for them.
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('NisCounterpartBalances.transfer') === 'fc85bea9d0d171982f66e8a55667d58dc9a1612bcafe84309942bf47e23e3094'
    }

    /**
     * Transfer some liquid free balance to another account.
     * 
     * `transfer` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     * 
     * The dispatch origin for this call must be `Signed` by the transactor.
     * 
     * # <weight>
     * - Dependent on arguments but not critical, given proper implementations for input config
     *   types. See related functions below.
     * - It contains a limited number of reads and writes internally and no complex
     *   computation.
     * 
     * Related functions:
     * 
     *   - `ensure_can_withdraw` is always called internally but has a bounded complexity.
     *   - Transferring balances to accounts that did not exist before will cause
     *     `T::OnNewAccount::on_new_account` to be called.
     *   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.
     *   - `transfer_keep_alive` works the same way as `transfer`, but has an additional check
     *     that the transfer will not kill the origin account.
     * ---------------------------------
     * - Origin account is already in memory, so no DB operations for them.
     * # </weight>
     */
    get asV9340(): {dest: v9340.MultiAddress, value: bigint} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }
}

export class NisCounterpartBalancesTransferAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NisCounterpartBalances.transfer_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer the entire transferable balance from the caller account.
     * 
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     * 
     * The dispatch origin of this call must be Signed.
     * 
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     *   of the funds the account has, causing the sender account to be killed (false), or
     *   transfer everything except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true). # <weight>
     * - O(1). Just like transfer, but reading the user's transferable balance first.
     *   #</weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('NisCounterpartBalances.transfer_all') === '9c94c2ca9979f6551af6e123fb6b6ba14d026f862f9a023706f8f88c556b355f'
    }

    /**
     * Transfer the entire transferable balance from the caller account.
     * 
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     * 
     * The dispatch origin of this call must be Signed.
     * 
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     *   of the funds the account has, causing the sender account to be killed (false), or
     *   transfer everything except at least the existential deposit, which will guarantee to
     *   keep the sender account alive (true). # <weight>
     * - O(1). Just like transfer, but reading the user's transferable balance first.
     *   #</weight>
     */
    get asV9340(): {dest: v9340.MultiAddress, keepAlive: boolean} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }
}

export class NisCounterpartBalancesTransferKeepAliveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NisCounterpartBalances.transfer_keep_alive')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer will not kill the
     * origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * [`transfer`]: struct.Pallet.html#method.transfer
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('NisCounterpartBalances.transfer_keep_alive') === 'fc85bea9d0d171982f66e8a55667d58dc9a1612bcafe84309942bf47e23e3094'
    }

    /**
     * Same as the [`transfer`] call, but with a check that the transfer will not kill the
     * origin account.
     * 
     * 99% of the time you want [`transfer`] instead.
     * 
     * [`transfer`]: struct.Pallet.html#method.transfer
     */
    get asV9340(): {dest: v9340.MultiAddress, value: bigint} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsBondExtraCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.bond_extra')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Bond `extra` more funds from `origin` into the pool to which they already belong.
     * 
     * Additional funds can come from either the free balance of the account, of from the
     * accumulated rewards, see [`BondExtra`].
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('NominationPools.bond_extra') === '05132b5a0d57223501d01aba18d473f18b91a6655ee2b5af3d97be42f39138d9'
    }

    /**
     * Bond `extra` more funds from `origin` into the pool to which they already belong.
     * 
     * Additional funds can come from either the free balance of the account, of from the
     * accumulated rewards, see [`BondExtra`].
     */
    get asV9220(): {extra: v9220.BondExtra} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsChillCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.chill')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Chill on behalf of the pool.
     * 
     * The dispatch origin of this call must be signed by the pool nominator or the pool
     * root role, same as [`Pallet::nominate`].
     * 
     * This directly forward the call to the staking pallet, on behalf of the pool bonded
     * account.
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('NominationPools.chill') === 'a662258b1bdb045a915972ea29e9ec0b46cdd5598b0da37b0e70ac766e3735a0'
    }

    /**
     * Chill on behalf of the pool.
     * 
     * The dispatch origin of this call must be signed by the pool nominator or the pool
     * root role, same as [`Pallet::nominate`].
     * 
     * This directly forward the call to the staking pallet, on behalf of the pool bonded
     * account.
     */
    get asV9250(): {poolId: number} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsClaimPayoutCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.claim_payout')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * A bonded member can use this to claim their payout based on the rewards that the pool
     * has accumulated since their last claimed payout (OR since joining if this is there first
     * time claiming rewards). The payout will be transferred to the member's account.
     * 
     * The member will earn rewards pro rata based on the members stake vs the sum of the
     * members in the pools stake. Rewards do not "expire".
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('NominationPools.claim_payout') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     * A bonded member can use this to claim their payout based on the rewards that the pool
     * has accumulated since their last claimed payout (OR since joining if this is there first
     * time claiming rewards). The payout will be transferred to the member's account.
     * 
     * The member will earn rewards pro rata based on the members stake vs the sum of the
     * members in the pools stake. Rewards do not "expire".
     */
    get asV9220(): null {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsCreateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.create')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a new delegation pool.
     * 
     * # Arguments
     * 
     * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
     *   deposit since the pools creator cannot fully unbond funds until the pool is being
     *   destroyed.
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     *   creating multiple pools in the same extrinsic.
     * * `root` - The account to set as [`PoolRoles::root`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * * `state_toggler` - The account to set as the [`PoolRoles::state_toggler`].
     * 
     * # Note
     * 
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferrable.
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('NominationPools.create') === 'b2cf1e8f2d8c87739c0ffdf344d596812a5fa6c4b612c595e7ec59806b10e813'
    }

    /**
     * Create a new delegation pool.
     * 
     * # Arguments
     * 
     * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
     *   deposit since the pools creator cannot fully unbond funds until the pool is being
     *   destroyed.
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     *   creating multiple pools in the same extrinsic.
     * * `root` - The account to set as [`PoolRoles::root`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * * `state_toggler` - The account to set as the [`PoolRoles::state_toggler`].
     * 
     * # Note
     * 
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferrable.
     */
    get asV9220(): {amount: bigint, root: Uint8Array, nominator: Uint8Array, stateToggler: Uint8Array} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a new delegation pool.
     * 
     * # Arguments
     * 
     * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
     *   deposit since the pools creator cannot fully unbond funds until the pool is being
     *   destroyed.
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     *   creating multiple pools in the same extrinsic.
     * * `root` - The account to set as [`PoolRoles::root`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * * `state_toggler` - The account to set as the [`PoolRoles::state_toggler`].
     * 
     * # Note
     * 
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferrable.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('NominationPools.create') === '7ae05fded37735d5e310868c744bd330fdc58661eabd48fb4518ad22fc21bba3'
    }

    /**
     * Create a new delegation pool.
     * 
     * # Arguments
     * 
     * * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of
     *   deposit since the pools creator cannot fully unbond funds until the pool is being
     *   destroyed.
     * * `index` - A disambiguation index for creating the account. Likely only useful when
     *   creating multiple pools in the same extrinsic.
     * * `root` - The account to set as [`PoolRoles::root`].
     * * `nominator` - The account to set as the [`PoolRoles::nominator`].
     * * `state_toggler` - The account to set as the [`PoolRoles::state_toggler`].
     * 
     * # Note
     * 
     * In addition to `amount`, the caller will transfer the existential deposit; so the caller
     * needs at have at least `amount + existential_deposit` transferrable.
     */
    get asV9291(): {amount: bigint, root: v9291.MultiAddress, nominator: v9291.MultiAddress, stateToggler: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsCreateWithPoolIdCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.create_with_pool_id')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Create a new delegation pool with a previously used pool id
     * 
     * # Arguments
     * 
     * same as `create` with the inclusion of
     * * `pool_id` - `A valid PoolId.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('NominationPools.create_with_pool_id') === '1dc4a8a914cb8357e61fea3d2ca10f0d301609dd10fd210a6dd6b82c3f3531bd'
    }

    /**
     * Create a new delegation pool with a previously used pool id
     * 
     * # Arguments
     * 
     * same as `create` with the inclusion of
     * * `pool_id` - `A valid PoolId.
     */
    get asV9340(): {amount: bigint, root: v9340.MultiAddress, nominator: v9340.MultiAddress, stateToggler: v9340.MultiAddress, poolId: number} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsJoinCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.join')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Stake funds with a pool. The amount to bond is transferred from the member to the
     * pools account and immediately increases the pools bond.
     * 
     * # Note
     * 
     * * An account can only be a member of a single pool.
     * * An account cannot join the same pool multiple times.
     * * This call will *not* dust the member account, so the member must have at least
     *   `existential deposit + amount` in their account.
     * * Only a pool with [`PoolState::Open`] can be joined
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('NominationPools.join') === 'de2a709c303863c1ce837173c79d51dd30d0f7a823ebd564150b65d17fc7d962'
    }

    /**
     * Stake funds with a pool. The amount to bond is transferred from the member to the
     * pools account and immediately increases the pools bond.
     * 
     * # Note
     * 
     * * An account can only be a member of a single pool.
     * * An account cannot join the same pool multiple times.
     * * This call will *not* dust the member account, so the member must have at least
     *   `existential deposit + amount` in their account.
     * * Only a pool with [`PoolState::Open`] can be joined
     */
    get asV9220(): {amount: bigint, poolId: number} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsNominateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.nominate')
        this._chain = ctx._chain
        this.call = call
    }

    get isV9220(): boolean {
        return this._chain.getCallHash('NominationPools.nominate') === 'ea4465a57461881e03894b11ac5f7192136bacd8d01d54206bdb61e16cc8abfc'
    }

    get asV9220(): {poolId: number, validators: Uint8Array[]} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsPoolWithdrawUnbondedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.pool_withdraw_unbonded')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
     * 
     * This is useful if their are too many unlocking chunks to call `unbond`, and some
     * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
     * would probably see an error like `NoMoreChunks` emitted from the staking system when
     * they attempt to unbond.
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('NominationPools.pool_withdraw_unbonded') === 'b6653f1dc9abfe17deb7a0622d88108ba58931838aa5b5b27bcf79870b10c0bc'
    }

    /**
     * Call `withdraw_unbonded` for the pools account. This call can be made by any account.
     * 
     * This is useful if their are too many unlocking chunks to call `unbond`, and some
     * can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
     * would probably see an error like `NoMoreChunks` emitted from the staking system when
     * they attempt to unbond.
     */
    get asV9220(): {poolId: number, numSlashingSpans: number} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsSetConfigsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.set_configs')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update configurations for the nomination pools. The origin must for this call must be
     * Root.
     * 
     * # Arguments
     * 
     * * `min_join_bond` - Set [`MinJoinBond`].
     * * `min_create_bond` - Set [`MinCreateBond`].
     * * `max_pools` - Set [`MaxPools`].
     * * `max_members` - Set [`MaxPoolMembers`].
     * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('NominationPools.set_configs') === '112c5b3d3b728aab0beb95840134437ed6bd58bec0759961a13710389f4237e2'
    }

    /**
     * Update configurations for the nomination pools. The origin must for this call must be
     * Root.
     * 
     * # Arguments
     * 
     * * `min_join_bond` - Set [`MinJoinBond`].
     * * `min_create_bond` - Set [`MinCreateBond`].
     * * `max_pools` - Set [`MaxPools`].
     * * `max_members` - Set [`MaxPoolMembers`].
     * * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`].
     */
    get asV9220(): {minJoinBond: v9220.ConfigOp, minCreateBond: v9220.ConfigOp, maxPools: v9220.Type_488, maxMembers: v9220.Type_488, maxMembersPerPool: v9220.Type_488} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsSetMetadataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.set_metadata')
        this._chain = ctx._chain
        this.call = call
    }

    get isV9220(): boolean {
        return this._chain.getCallHash('NominationPools.set_metadata') === '027a45601396dd984f964705eb7eabc42207aedba700c7316c5f0201a21bc953'
    }

    get asV9220(): {poolId: number, metadata: Uint8Array} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsSetStateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.set_state')
        this._chain = ctx._chain
        this.call = call
    }

    get isV9220(): boolean {
        return this._chain.getCallHash('NominationPools.set_state') === '8edc6fb856b29d0578d262182420b2d913110185338eb0d25886711b95487d17'
    }

    get asV9220(): {poolId: number, state: v9220.PoolState} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsUnbondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.unbond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
     * implicitly collects the rewards one last time, since not doing so would mean some
     * rewards would go forfeited.
     * 
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     * 
     * # Conditions for a permissionless dispatch.
     * 
     * * The pool is blocked and the caller is either the root or state-toggler. This is
     *   refereed to as a kick.
     * * The pool is destroying and the member is not the depositor.
     * * The pool is destroying, the member is the depositor and no other members are in the
     *   pool.
     * 
     * ## Conditions for permissioned dispatch (i.e. the caller is also the
     * `member_account`):
     * 
     * * The caller is not the depositor.
     * * The caller is the depositor, the pool is destroying and no other members are in the
     *   pool.
     * 
     * # Note
     * 
     * If there are too many unlocking chunks to unbond with the pool account,
     * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks. If
     * there are too many unlocking chunks, the result of this call will likely be the
     * `NoMoreChunks` error from the staking system.
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('NominationPools.unbond') === '8fa56122c6759633d706b595abf98742254c8eda11ef9a812eb401a7c008496b'
    }

    /**
     * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
     * implicitly collects the rewards one last time, since not doing so would mean some
     * rewards would go forfeited.
     * 
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     * 
     * # Conditions for a permissionless dispatch.
     * 
     * * The pool is blocked and the caller is either the root or state-toggler. This is
     *   refereed to as a kick.
     * * The pool is destroying and the member is not the depositor.
     * * The pool is destroying, the member is the depositor and no other members are in the
     *   pool.
     * 
     * ## Conditions for permissioned dispatch (i.e. the caller is also the
     * `member_account`):
     * 
     * * The caller is not the depositor.
     * * The caller is the depositor, the pool is destroying and no other members are in the
     *   pool.
     * 
     * # Note
     * 
     * If there are too many unlocking chunks to unbond with the pool account,
     * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks. If
     * there are too many unlocking chunks, the result of this call will likely be the
     * `NoMoreChunks` error from the staking system.
     */
    get asV9220(): {memberAccount: Uint8Array, unbondingPoints: bigint} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
     * implicitly collects the rewards one last time, since not doing so would mean some
     * rewards would be forfeited.
     * 
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     * 
     * # Conditions for a permissionless dispatch.
     * 
     * * The pool is blocked and the caller is either the root or state-toggler. This is
     *   refereed to as a kick.
     * * The pool is destroying and the member is not the depositor.
     * * The pool is destroying, the member is the depositor and no other members are in the
     *   pool.
     * 
     * ## Conditions for permissioned dispatch (i.e. the caller is also the
     * `member_account`):
     * 
     * * The caller is not the depositor.
     * * The caller is the depositor, the pool is destroying and no other members are in the
     *   pool.
     * 
     * # Note
     * 
     * If there are too many unlocking chunks to unbond with the pool account,
     * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks. If
     * there are too many unlocking chunks, the result of this call will likely be the
     * `NoMoreChunks` error from the staking system.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('NominationPools.unbond') === '64450cc91b317addf9e9ebaf23d031c6cc889c6e14ecf696013d737cfe185ec8'
    }

    /**
     * Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It
     * implicitly collects the rewards one last time, since not doing so would mean some
     * rewards would be forfeited.
     * 
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     * 
     * # Conditions for a permissionless dispatch.
     * 
     * * The pool is blocked and the caller is either the root or state-toggler. This is
     *   refereed to as a kick.
     * * The pool is destroying and the member is not the depositor.
     * * The pool is destroying, the member is the depositor and no other members are in the
     *   pool.
     * 
     * ## Conditions for permissioned dispatch (i.e. the caller is also the
     * `member_account`):
     * 
     * * The caller is not the depositor.
     * * The caller is the depositor, the pool is destroying and no other members are in the
     *   pool.
     * 
     * # Note
     * 
     * If there are too many unlocking chunks to unbond with the pool account,
     * [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks. If
     * there are too many unlocking chunks, the result of this call will likely be the
     * `NoMoreChunks` error from the staking system.
     */
    get asV9291(): {memberAccount: v9291.MultiAddress, unbondingPoints: bigint} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsUpdateRolesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.update_roles')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update the roles of the pool.
     * 
     * The root is the only entity that can change any of the roles, including itself,
     * excluding the depositor, who can never change.
     * 
     * It emits an event, notifying UIs of the role change. This event is quite relevant to
     * most pool members and they should be informed of changes to pool roles.
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('NominationPools.update_roles') === 'b7945c9dd8fca50fe22b0029fb70f12ede03f05ad0094f2fde76a70177ba4c21'
    }

    /**
     * Update the roles of the pool.
     * 
     * The root is the only entity that can change any of the roles, including itself,
     * excluding the depositor, who can never change.
     * 
     * It emits an event, notifying UIs of the role change. This event is quite relevant to
     * most pool members and they should be informed of changes to pool roles.
     */
    get asV9220(): {poolId: number, root: (Uint8Array | undefined), nominator: (Uint8Array | undefined), stateToggler: (Uint8Array | undefined)} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update the roles of the pool.
     * 
     * The root is the only entity that can change any of the roles, including itself,
     * excluding the depositor, who can never change.
     * 
     * It emits an event, notifying UIs of the role change. This event is quite relevant to
     * most pool members and they should be informed of changes to pool roles.
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('NominationPools.update_roles') === '7bbd1de5541f610233088bb41a579f1de19accd1cb15d9568cebd3587531b70c'
    }

    /**
     * Update the roles of the pool.
     * 
     * The root is the only entity that can change any of the roles, including itself,
     * excluding the depositor, who can never change.
     * 
     * It emits an event, notifying UIs of the role change. This event is quite relevant to
     * most pool members and they should be informed of changes to pool roles.
     */
    get asV9230(): {poolId: number, newRoot: v9230.Type_487, newNominator: v9230.Type_487, newStateToggler: v9230.Type_487} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }
}

export class NominationPoolsWithdrawUnbondedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'NominationPools.withdraw_unbonded')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
     * error is returned.
     * 
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     * 
     * # Conditions for a permissionless dispatch
     * 
     * * The pool is in destroy mode and the target is not the depositor.
     * * The target is the depositor and they are the only member in the sub pools.
     * * The pool is blocked and the caller is either the root or state-toggler.
     * 
     * # Conditions for permissioned dispatch
     * 
     * * The caller is the target and they are not the depositor.
     * 
     * # Note
     * 
     * If the target is the depositor, the pool will be destroyed.
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('NominationPools.withdraw_unbonded') === '3a63834e0b3824107874a2ad5a0bed745e2fd1f9ca57e2b3bafe1bd907205558'
    }

    /**
     * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
     * error is returned.
     * 
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     * 
     * # Conditions for a permissionless dispatch
     * 
     * * The pool is in destroy mode and the target is not the depositor.
     * * The target is the depositor and they are the only member in the sub pools.
     * * The pool is blocked and the caller is either the root or state-toggler.
     * 
     * # Conditions for permissioned dispatch
     * 
     * * The caller is the target and they are not the depositor.
     * 
     * # Note
     * 
     * If the target is the depositor, the pool will be destroyed.
     */
    get asV9220(): {memberAccount: Uint8Array, numSlashingSpans: number} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
     * error is returned.
     * 
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     * 
     * # Conditions for a permissionless dispatch
     * 
     * * The pool is in destroy mode and the target is not the depositor.
     * * The target is the depositor and they are the only member in the sub pools.
     * * The pool is blocked and the caller is either the root or state-toggler.
     * 
     * # Conditions for permissioned dispatch
     * 
     * * The caller is the target and they are not the depositor.
     * 
     * # Note
     * 
     * If the target is the depositor, the pool will be destroyed.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('NominationPools.withdraw_unbonded') === '52fb3ae57a795478589c557de25b0d870d311ba397654773c80592329c8a086e'
    }

    /**
     * Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
     * error is returned.
     * 
     * Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
     * account).
     * 
     * # Conditions for a permissionless dispatch
     * 
     * * The pool is in destroy mode and the target is not the depositor.
     * * The target is the depositor and they are the only member in the sub pools.
     * * The pool is blocked and the caller is either the root or state-toggler.
     * 
     * # Conditions for permissioned dispatch
     * 
     * * The caller is the target and they are not the depositor.
     * 
     * # Note
     * 
     * If the target is the depositor, the pool will be destroyed.
     */
    get asV9291(): {memberAccount: v9291.MultiAddress, numSlashingSpans: number} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class ParaInherentEnterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParaInherent.enter')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Enter the paras inherent. This will process bitfields and backed candidates.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('ParaInherent.enter') === '9ee980f59274419dbaf62901f848a7d7d72288c3ca6b1aeaf882fd7a256ca205'
    }

    /**
     *  Enter the paras inherent. This will process bitfields and backed candidates.
     */
    get asV9090(): {data: v9090.ParachainsInherentData} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Enter the paras inherent. This will process bitfields and backed candidates.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('ParaInherent.enter') === '18a9cd13017feae2eeff50d5be0333229af2188a881a32e976e7f627d0e94376'
    }

    /**
     * Enter the paras inherent. This will process bitfields and backed candidates.
     */
    get asV9111(): {data: v9111.V1InherentData} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Enter the paras inherent. This will process bitfields and backed candidates.
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('ParaInherent.enter') === 'a9d507be3ededfc111412179310cc428ca61464dbaf93e10505bd1d8f6af4d8e'
    }

    /**
     * Enter the paras inherent. This will process bitfields and backed candidates.
     */
    get asV9130(): {data: v9130.V1InherentData} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsReportDoubleVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Parachains.report_double_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Provide a proof that some validator has commited a double-vote.
     * 
     *  The weight is 0; in order to avoid DoS a `SignedExtension` validation
     *  is implemented.
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('Parachains.report_double_vote') === 'dc410612df4fac8bebd0a9ed55c5375fce770aa67a4ad3638d31aedefea13bd1'
    }

    /**
     *  Provide a proof that some validator has commited a double-vote.
     * 
     *  The weight is 0; in order to avoid DoS a `SignedExtension` validation
     *  is implemented.
     */
    get asV1058(): {report: v1058.DoubleVoteReport} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsSendXcmpMessageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Parachains.send_xcmp_message')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Send a XCMP message to the given parachain.
     * 
     *  The origin must be another parachain.
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('Parachains.send_xcmp_message') === 'a1ddf6a14cd5bb82d9549a6279e74dc1ba70aee3d64196252b30fab309ab11d6'
    }

    /**
     *  Send a XCMP message to the given parachain.
     * 
     *  The origin must be another parachain.
     */
    get asV2013(): {to: number, msg: Uint8Array} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsSetHeadsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Parachains.set_heads')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Provide candidate receipts for parachains, in ascending order by id.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Parachains.set_heads') === 'c80aa943458f41e4a8324af643a273de43037563fd3e7a20a3d124f7107a64c5'
    }

    /**
     *  Provide candidate receipts for parachains, in ascending order by id.
     */
    get asV1020(): {heads: v1020.AttestedCandidate[]} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsTransferToParachainCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Parachains.transfer_to_parachain')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer some tokens into a parachain and leave a message in the downward queue for it.
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('Parachains.transfer_to_parachain') === 'ef579006d0d90c07b2b55deb9b27d3db1e746786d4a0a48a809d4acb33f5d06a'
    }

    /**
     *  Transfer some tokens into a parachain and leave a message in the downward queue for it.
     */
    get asV2013(): {to: number, amount: bigint, remark: Uint8Array} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetChainAvailabilityPeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_chain_availability_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the availability period for parachains.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_chain_availability_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the availability period for parachains.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetCodeRetentionPeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_code_retention_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the acceptance period for an included candidate.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_code_retention_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the acceptance period for an included candidate.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetDisputeConclusionByTimeOutPeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_dispute_conclusion_by_time_out_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the dispute conclusion by time out period.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_dispute_conclusion_by_time_out_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the dispute conclusion by time out period.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetDisputeMaxSpamSlotsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_dispute_max_spam_slots')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the maximum number of dispute spam slots.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_dispute_max_spam_slots') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the maximum number of dispute spam slots.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetDisputePeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_dispute_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the dispute period, in number of sessions to keep for disputes.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_dispute_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the dispute period, in number of sessions to keep for disputes.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetDisputePostConclusionAcceptancePeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_dispute_post_conclusion_acceptance_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the dispute post conclusion acceptance period.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_dispute_post_conclusion_acceptance_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the dispute post conclusion acceptance period.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetGroupRotationFrequencyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_group_rotation_frequency')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the parachain validator-group rotation frequency
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_group_rotation_frequency') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the parachain validator-group rotation frequency
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetHrmpChannelMaxCapacityCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_hrmp_channel_max_capacity')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of messages allowed in an HRMP channel at once.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_hrmp_channel_max_capacity') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of messages allowed in an HRMP channel at once.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetHrmpChannelMaxMessageSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_hrmp_channel_max_message_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum size of a message that could ever be put into an HRMP channel.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_hrmp_channel_max_message_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum size of a message that could ever be put into an HRMP channel.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetHrmpChannelMaxTotalSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_hrmp_channel_max_total_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum total size of messages in bytes allowed in an HRMP channel at once.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_hrmp_channel_max_total_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum total size of messages in bytes allowed in an HRMP channel at once.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetHrmpMaxMessageNumPerCandidateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_hrmp_max_message_num_per_candidate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of outbound HRMP messages can be sent by a candidate.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_hrmp_max_message_num_per_candidate') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of outbound HRMP messages can be sent by a candidate.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetHrmpMaxParachainInboundChannelsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_hrmp_max_parachain_inbound_channels')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of inbound HRMP channels a parachain is allowed to accept.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_hrmp_max_parachain_inbound_channels') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of inbound HRMP channels a parachain is allowed to accept.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetHrmpMaxParachainOutboundChannelsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_hrmp_max_parachain_outbound_channels')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of outbound HRMP channels a parachain is allowed to open.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_hrmp_max_parachain_outbound_channels') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of outbound HRMP channels a parachain is allowed to open.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetHrmpMaxParathreadInboundChannelsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_hrmp_max_parathread_inbound_channels')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of inbound HRMP channels a parathread is allowed to accept.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_hrmp_max_parathread_inbound_channels') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of inbound HRMP channels a parathread is allowed to accept.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetHrmpMaxParathreadOutboundChannelsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_hrmp_max_parathread_outbound_channels')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of outbound HRMP channels a parathread is allowed to open.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_hrmp_max_parathread_outbound_channels') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of outbound HRMP channels a parathread is allowed to open.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetHrmpOpenRequestTtlCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_hrmp_open_request_ttl')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the number of sessions after which an HRMP open channel request expires.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_hrmp_open_request_ttl') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the number of sessions after which an HRMP open channel request expires.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetHrmpRecipientDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_hrmp_recipient_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the amount of funds that the recipient should provide for accepting opening an HRMP
     *  channel.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_hrmp_recipient_deposit') === '86d3c70a5efeaca7d1a72b006ed6757b84fb71871eb54ca1d98d6a8fdeb79e3a'
    }

    /**
     *  Sets the amount of funds that the recipient should provide for accepting opening an HRMP
     *  channel.
     */
    get asV9010(): {new: bigint} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetHrmpSenderDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_hrmp_sender_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the amount of funds that the sender should provide for opening an HRMP channel.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_hrmp_sender_deposit') === '86d3c70a5efeaca7d1a72b006ed6757b84fb71871eb54ca1d98d6a8fdeb79e3a'
    }

    /**
     *  Sets the amount of funds that the sender should provide for opening an HRMP channel.
     */
    get asV9010(): {new: bigint} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetMaxCodeSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_max_code_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the max validation code size for incoming upgrades.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_max_code_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the max validation code size for incoming upgrades.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetMaxDownwardMessageSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_max_downward_message_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the critical downward message size.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_max_downward_message_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the critical downward message size.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetMaxHeadDataSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_max_head_data_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the max head data size for paras.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_max_head_data_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the max head data size for paras.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetMaxPovSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_max_pov_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the max POV block size for incoming upgrades.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_max_pov_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the max POV block size for incoming upgrades.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetMaxUpwardMessageNumPerCandidateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_max_upward_message_num_per_candidate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum number of messages that a candidate can contain.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_max_upward_message_num_per_candidate') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum number of messages that a candidate can contain.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetMaxUpwardMessageSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_max_upward_message_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum size of an upward message that can be sent by a candidate.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_max_upward_message_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum size of an upward message that can be sent by a candidate.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetMaxUpwardQueueCountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_max_upward_queue_count')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum items that can present in a upward dispatch queue at once.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_max_upward_queue_count') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum items that can present in a upward dispatch queue at once.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetMaxUpwardQueueSizeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_max_upward_queue_size')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the maximum total size of items that can present in a upward dispatch queue at once.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_max_upward_queue_size') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Sets the maximum total size of items that can present in a upward dispatch queue at once.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetMaxValidatorsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_max_validators')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the maximum number of validators to use in parachain consensus.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_max_validators') === 'b271d6a449f9641d900bc39e1a293351b09e8f890436186c9fc6db7592ba0967'
    }

    /**
     *  Set the maximum number of validators to use in parachain consensus.
     */
    get asV9010(): {new: (number | undefined)} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetMaxValidatorsPerCoreCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_max_validators_per_core')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the maximum number of validators to assign to any core.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_max_validators_per_core') === 'b271d6a449f9641d900bc39e1a293351b09e8f890436186c9fc6db7592ba0967'
    }

    /**
     *  Set the maximum number of validators to assign to any core.
     */
    get asV9010(): {new: (number | undefined)} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetNDelayTranchesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_n_delay_tranches')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the total number of delay tranches.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_n_delay_tranches') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the total number of delay tranches.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetNeededApprovalsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_needed_approvals')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the number of validators needed to approve a block.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_needed_approvals') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the number of validators needed to approve a block.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetNoShowSlotsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_no_show_slots')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the no show slots, in number of number of consensus slots.
     *  Must be at least 1.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_no_show_slots') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the no show slots, in number of number of consensus slots.
     *  Must be at least 1.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetParathreadCoresCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_parathread_cores')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the number of parathread execution cores.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_parathread_cores') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the number of parathread execution cores.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetParathreadRetriesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_parathread_retries')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the number of retries for a particular parathread.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_parathread_retries') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the number of retries for a particular parathread.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetPreferredDispatchableUpwardMessagesStepWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_preferred_dispatchable_upward_messages_step_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the soft limit for the phase of dispatching dispatchable upward messages.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_preferred_dispatchable_upward_messages_step_weight') === '8768ae636c927ffed8b3cb5f0df1e15afb0921835e5bc84b9495f4b39ea663b7'
    }

    /**
     *  Sets the soft limit for the phase of dispatching dispatchable upward messages.
     */
    get asV9010(): {new: bigint} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetRelayVrfModuloSamplesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_relay_vrf_modulo_samples')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the number of samples to do of the RelayVRFModulo approval assignment criterion.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_relay_vrf_modulo_samples') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the number of samples to do of the RelayVRFModulo approval assignment criterion.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetSchedulingLookaheadCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_scheduling_lookahead')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the scheduling lookahead, in expected number of blocks at peak throughput.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_scheduling_lookahead') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the scheduling lookahead, in expected number of blocks at peak throughput.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetThreadAvailabilityPeriodCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_thread_availability_period')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the availability period for parathreads.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_thread_availability_period') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the availability period for parathreads.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetUmpServiceTotalWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_ump_service_total_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the soft limit for the phase of dispatching dispatchable upward messages.
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_ump_service_total_weight') === '8768ae636c927ffed8b3cb5f0df1e15afb0921835e5bc84b9495f4b39ea663b7'
    }

    /**
     *  Sets the soft limit for the phase of dispatching dispatchable upward messages.
     */
    get asV9040(): {new: bigint} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetValidationUpgradeDelayCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_validation_upgrade_delay')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the validation upgrade delay.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_validation_upgrade_delay') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the validation upgrade delay.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetValidationUpgradeFrequencyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_validation_upgrade_frequency')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the validation upgrade frequency.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_validation_upgrade_frequency') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the validation upgrade frequency.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParachainsConfigurationSetZerothDelayTrancheWidthCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParachainsConfiguration.set_zeroth_delay_tranche_width')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the zeroth delay tranche width.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParachainsConfiguration.set_zeroth_delay_tranche_width') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     *  Set the zeroth delay tranche width.
     */
    get asV9010(): {new: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasAddTrustedValidationCodeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.add_trusted_validation_code')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Adds the validation code to the storage.
     * 
     * The code will not be added if it is already present. Additionally, if PVF pre-checking
     * is running for that code, it will be instantly accepted.
     * 
     * Otherwise, the code will be added into the storage. Note that the code will be added
     * into storage with reference count 0. This is to account the fact that there are no users
     * for this code yet. The caller will have to make sure that this code eventually gets
     * used by some parachain or removed from the storage to avoid storage leaks. For the latter
     * prefer to use the `poke_unused_validation_code` dispatchable to raw storage manipulation.
     * 
     * This function is mainly meant to be used for upgrading parachains that do not follow
     * the go-ahead signal while the PVF pre-checking feature is enabled.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Paras.add_trusted_validation_code') === '0ad78b20451a91789302238ce78bb346eb02be5596707efead661c7e083ab212'
    }

    /**
     * Adds the validation code to the storage.
     * 
     * The code will not be added if it is already present. Additionally, if PVF pre-checking
     * is running for that code, it will be instantly accepted.
     * 
     * Otherwise, the code will be added into the storage. Note that the code will be added
     * into storage with reference count 0. This is to account the fact that there are no users
     * for this code yet. The caller will have to make sure that this code eventually gets
     * used by some parachain or removed from the storage to avoid storage leaks. For the latter
     * prefer to use the `poke_unused_validation_code` dispatchable to raw storage manipulation.
     * 
     * This function is mainly meant to be used for upgrading parachains that do not follow
     * the go-ahead signal while the PVF pre-checking feature is enabled.
     */
    get asV9160(): {validationCode: Uint8Array} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasForceNoteNewHeadCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.force_note_new_head')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Note a new block head for para within the context of the current block.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Paras.force_note_new_head') === '630e70696dbb809d3a272dfc9da9bfd0656f82541be24c57ee1c634d2645017c'
    }

    /**
     *  Note a new block head for para within the context of the current block.
     */
    get asV9010(): {para: number, newHead: Uint8Array} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasForceQueueActionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.force_queue_action')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Put a parachain directly into the next session's action queue.
     *  We can't queue it any sooner than this without going into the
     *  initializer...
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Paras.force_queue_action') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     *  Put a parachain directly into the next session's action queue.
     *  We can't queue it any sooner than this without going into the
     *  initializer...
     */
    get asV9010(): {para: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasForceScheduleCodeUpgradeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.force_schedule_code_upgrade')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule a code upgrade for block `expected_at`.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Paras.force_schedule_code_upgrade') === '268f230876fd989f5afd9fc487986ef0d180589ace63634370745bfaf863fa92'
    }

    /**
     *  Schedule a code upgrade for block `expected_at`.
     */
    get asV9010(): {para: number, newCode: Uint8Array, expectedAt: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule an upgrade as if it was scheduled in the given relay parent block.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Paras.force_schedule_code_upgrade') === 'a8977843dd9b948a1a0495c6070fe0b2e8b1b4aa07d85a8f196863ca04a03a6b'
    }

    /**
     *  Schedule an upgrade as if it was scheduled in the given relay parent block.
     */
    get asV9090(): {para: number, newCode: Uint8Array, relayParentNumber: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasForceSetCurrentCodeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.force_set_current_code')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the storage for the parachain validation code immediately.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Paras.force_set_current_code') === '0b5bbf1b361dddb4826c2c1c0065a52b490f97f282bfc036e9cfc8d1934f8139'
    }

    /**
     *  Set the storage for the parachain validation code immediately.
     */
    get asV9010(): {para: number, newCode: Uint8Array} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasForceSetCurrentHeadCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.force_set_current_head')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the storage for the current parachain head data immediately.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Paras.force_set_current_head') === '630e70696dbb809d3a272dfc9da9bfd0656f82541be24c57ee1c634d2645017c'
    }

    /**
     *  Set the storage for the current parachain head data immediately.
     */
    get asV9010(): {para: number, newHead: Uint8Array} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasIncludePvfCheckStatementCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.include_pvf_check_statement')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Includes a statement for a PVF pre-checking vote. Potentially, finalizes the vote and
     * enacts the results if that was the last vote before achieving the supermajority.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Paras.include_pvf_check_statement') === 'ba297981fae49e9a7feef6b5c5946ef2256fa44b2bbba936e20f4e5a433b9b3f'
    }

    /**
     * Includes a statement for a PVF pre-checking vote. Potentially, finalizes the vote and
     * enacts the results if that was the last vote before achieving the supermajority.
     */
    get asV9160(): {stmt: v9160.V2PvfCheckStatement, signature: Uint8Array} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasPokeUnusedValidationCodeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Paras.poke_unused_validation_code')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove the validation code from the storage iff the reference count is 0.
     * 
     * This is better than removing the storage directly, because it will not remove the code
     * that was suddenly got used by some parachain while this dispatchable was pending
     * dispatching.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Paras.poke_unused_validation_code') === '6a0ee0e91dfac4ad12f1a7c0b407204956c918eeb7dbd4d37d9c4c210e9558de'
    }

    /**
     * Remove the validation code from the storage iff the reference count is 0.
     * 
     * This is better than removing the storage directly, because it will not remove the code
     * that was suddenly got used by some parachain while this dispatchable was pending
     * dispatching.
     */
    get asV9160(): {validationCodeHash: Uint8Array} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasDisputesForceUnfreezeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasDisputes.force_unfreeze')
        this._chain = ctx._chain
        this.call = call
    }

    get isV9130(): boolean {
        return this._chain.getCallHash('ParasDisputes.force_unfreeze') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    get asV9130(): null {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasHrmpForceCleanHrmpCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasHrmp.force_clean_hrmp')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  This extrinsic triggers the cleanup of all the HRMP storage items that
     *  a para may have. Normally this happens once per session, but this allows
     *  you to trigger the cleanup immediately for a specific parachain.
     * 
     *  Origin must be Root.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParasHrmp.force_clean_hrmp') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     *  This extrinsic triggers the cleanup of all the HRMP storage items that
     *  a para may have. Normally this happens once per session, but this allows
     *  you to trigger the cleanup immediately for a specific parachain.
     * 
     *  Origin must be Root.
     */
    get asV9010(): {para: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasHrmpForceProcessHrmpCloseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasHrmp.force_process_hrmp_close')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force process hrmp close channel requests.
     * 
     *  If there are pending HRMP close channel requests, you can use this
     *  function process all of those requests immediately.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParasHrmp.force_process_hrmp_close') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Force process hrmp close channel requests.
     * 
     *  If there are pending HRMP close channel requests, you can use this
     *  function process all of those requests immediately.
     */
    get asV9010(): null {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasHrmpForceProcessHrmpOpenCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasHrmp.force_process_hrmp_open')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force process hrmp open channel requests.
     * 
     *  If there are pending HRMP open channel requests, you can use this
     *  function process all of those requests immediately.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParasHrmp.force_process_hrmp_open') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Force process hrmp open channel requests.
     * 
     *  If there are pending HRMP open channel requests, you can use this
     *  function process all of those requests immediately.
     */
    get asV9010(): null {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasHrmpHrmpAcceptOpenChannelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasHrmp.hrmp_accept_open_channel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Accept a pending open channel request from the given sender.
     * 
     *  The channel will be opened only on the next session boundary.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParasHrmp.hrmp_accept_open_channel') === 'df73c5e1f40e14fb4e0ca9c4be4018d011ed0be4cb058df95899088220820d15'
    }

    /**
     *  Accept a pending open channel request from the given sender.
     * 
     *  The channel will be opened only on the next session boundary.
     */
    get asV9010(): {sender: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasHrmpHrmpCloseChannelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasHrmp.hrmp_close_channel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Initiate unilateral closing of a channel. The origin must be either the sender or the
     *  recipient in the channel being closed.
     * 
     *  The closure can only happen on a session change.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParasHrmp.hrmp_close_channel') === 'ad63c6e3452e8fbd9217f4fa7da9bc6efe307038eb9b4e5dc3f784e1d597ee1f'
    }

    /**
     *  Initiate unilateral closing of a channel. The origin must be either the sender or the
     *  recipient in the channel being closed.
     * 
     *  The closure can only happen on a session change.
     */
    get asV9010(): {channelId: v9010.HrmpChannelId} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasHrmpHrmpInitOpenChannelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasHrmp.hrmp_init_open_channel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Initiate opening a channel from a parachain to a given recipient with given channel
     *  parameters.
     * 
     *  - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
     *  - `proposed_max_message_size` - specifies the maximum size of any of the messages.
     * 
     *  These numbers are a subject to the relay-chain configuration limits.
     * 
     *  The channel can be opened only after the recipient confirms it and only on a session
     *  change.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParasHrmp.hrmp_init_open_channel') === 'c78d4e6da3f70d8bb4c2c00861e72fb4233df808203d0f148f572b5e16e04f71'
    }

    /**
     *  Initiate opening a channel from a parachain to a given recipient with given channel
     *  parameters.
     * 
     *  - `proposed_max_capacity` - specifies how many messages can be in the channel at once.
     *  - `proposed_max_message_size` - specifies the maximum size of any of the messages.
     * 
     *  These numbers are a subject to the relay-chain configuration limits.
     * 
     *  The channel can be opened only after the recipient confirms it and only on a session
     *  change.
     */
    get asV9010(): {recipient: number, proposedMaxCapacity: number, proposedMaxMessageSize: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasInherentEnterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasInherent.enter')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Enter the paras inherent. This will process bitfields and backed candidates.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParasInherent.enter') === '9ee980f59274419dbaf62901f848a7d7d72288c3ca6b1aeaf882fd7a256ca205'
    }

    /**
     *  Enter the paras inherent. This will process bitfields and backed candidates.
     */
    get asV9010(): {data: v9010.ParachainsInherentData} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class ParasInitializerForceApproveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'ParasInitializer.force_approve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Issue a signal to the consensus engine to forcibly act as though all parachain
     *  blocks in all relay chain blocks up to and including the given number in the current
     *  chain are valid and should be finalized.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('ParasInitializer.force_approve') === 'aa2b79ecc12cda7c6325357609f0dde737428c5b092dab0769d4e105b22bd955'
    }

    /**
     *  Issue a signal to the consensus engine to forcibly act as though all parachain
     *  blocks in all relay chain blocks up to and including the given number in the current
     *  chain are valid and should be finalized.
     */
    get asV9010(): {upTo: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class PhragmenElectionCleanDefunctVotersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PhragmenElection.clean_defunct_voters')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
     *  deposit of the removed voters are returned.
     * 
     *  This is an root function to be used only for cleaning the state.
     * 
     *  The dispatch origin of this call must be root.
     * 
     *  # <weight>
     *  The total number of voters and those that are defunct must be provided as witness data.
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('PhragmenElection.clean_defunct_voters') === '8279e35309d0c9a5d36cd12cce19e58fef95829d4096e23fe93a055a47afd8a0'
    }

    /**
     *  Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
     *  deposit of the removed voters are returned.
     * 
     *  This is an root function to be used only for cleaning the state.
     * 
     *  The dispatch origin of this call must be root.
     * 
     *  # <weight>
     *  The total number of voters and those that are defunct must be provided as witness data.
     *  # </weight>
     */
    get asV9010(): {numVoters: number, numDefunct: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class PhragmenElectionRemoveMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PhragmenElection.remove_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a particular member from the set. This is effective immediately and the bond of
     *  the outgoing member is slashed.
     * 
     *  If a runner-up is available, then the best runner-up will be removed and replaces the
     *  outgoing member. Otherwise, a new phragmen election is started.
     * 
     *  The dispatch origin of this call must be root.
     * 
     *  Note that this does not affect the designated block number of the next election.
     * 
     *  # <weight>
     *  If we have a replacement, we use a small weight. Else, since this is a root call and
     *  will go into phragmen, we assume full block for now.
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('PhragmenElection.remove_member') === '8f953115e82b1180527569f88641e39ddd7c750a04a3e0ab23cb9466f32e4a9b'
    }

    /**
     *  Remove a particular member from the set. This is effective immediately and the bond of
     *  the outgoing member is slashed.
     * 
     *  If a runner-up is available, then the best runner-up will be removed and replaces the
     *  outgoing member. Otherwise, a new phragmen election is started.
     * 
     *  The dispatch origin of this call must be root.
     * 
     *  Note that this does not affect the designated block number of the next election.
     * 
     *  # <weight>
     *  If we have a replacement, we use a small weight. Else, since this is a root call and
     *  will go into phragmen, we assume full block for now.
     *  # </weight>
     */
    get asV9010(): {who: v9010.LookupSource, hasReplacement: boolean} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove a particular member from the set. This is effective immediately and the bond of
     * the outgoing member is slashed.
     * 
     * If a runner-up is available, then the best runner-up will be removed and replaces the
     * outgoing member. Otherwise, a new phragmen election is started.
     * 
     * The dispatch origin of this call must be root.
     * 
     * Note that this does not affect the designated block number of the next election.
     * 
     * # <weight>
     * If we have a replacement, we use a small weight. Else, since this is a root call and
     * will go into phragmen, we assume full block for now.
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('PhragmenElection.remove_member') === '94d821dab992430b4c9e8c53b5d85ad026c368272bee49983181126c4f121681'
    }

    /**
     * Remove a particular member from the set. This is effective immediately and the bond of
     * the outgoing member is slashed.
     * 
     * If a runner-up is available, then the best runner-up will be removed and replaces the
     * outgoing member. Otherwise, a new phragmen election is started.
     * 
     * The dispatch origin of this call must be root.
     * 
     * Note that this does not affect the designated block number of the next election.
     * 
     * # <weight>
     * If we have a replacement, we use a small weight. Else, since this is a root call and
     * will go into phragmen, we assume full block for now.
     * # </weight>
     */
    get asV9111(): {who: v9111.MultiAddress, hasReplacement: boolean} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove a particular member from the set. This is effective immediately and the bond of
     * the outgoing member is slashed.
     * 
     * If a runner-up is available, then the best runner-up will be removed and replaces the
     * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
     * started, else, nothing happens.
     * 
     * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
     * it is returned.
     * 
     * The dispatch origin of this call must be root.
     * 
     * Note that this does not affect the designated block number of the next election.
     * 
     * # <weight>
     * If we have a replacement, we use a small weight. Else, since this is a root call and
     * will go into phragmen, we assume full block for now.
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('PhragmenElection.remove_member') === 'cad43b3c39cdcf8f1f0ade5f75d00e1cbedebcb3e3c8feb18958bef69d34a79f'
    }

    /**
     * Remove a particular member from the set. This is effective immediately and the bond of
     * the outgoing member is slashed.
     * 
     * If a runner-up is available, then the best runner-up will be removed and replaces the
     * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
     * started, else, nothing happens.
     * 
     * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
     * it is returned.
     * 
     * The dispatch origin of this call must be root.
     * 
     * Note that this does not affect the designated block number of the next election.
     * 
     * # <weight>
     * If we have a replacement, we use a small weight. Else, since this is a root call and
     * will go into phragmen, we assume full block for now.
     * # </weight>
     */
    get asV9271(): {who: v9271.MultiAddress, slashBond: boolean, rerunElection: boolean} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }
}

export class PhragmenElectionRemoveVoterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PhragmenElection.remove_voter')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove `origin` as a voter.
     * 
     *  This removes the lock and returns the deposit.
     * 
     *  The dispatch origin of this call must be signed and be a voter.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('PhragmenElection.remove_voter') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Remove `origin` as a voter.
     * 
     *  This removes the lock and returns the deposit.
     * 
     *  The dispatch origin of this call must be signed and be a voter.
     */
    get asV9010(): null {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class PhragmenElectionRenounceCandidacyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PhragmenElection.renounce_candidacy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Renounce one's intention to be a candidate for the next election round. 3 potential
     *  outcomes exist:
     * 
     *  - `origin` is a candidate and not elected in any set. In this case, the deposit is
     *    unreserved, returned and origin is removed as a candidate.
     *  - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
     *    origin is removed as a runner-up.
     *  - `origin` is a current member. In this case, the deposit is unreserved and origin is
     *    removed as a member, consequently not being a candidate for the next round anymore.
     *    Similar to [`remove_members`], if replacement runners exists, they are immediately
     *    used. If the prime is renouncing, then no prime will exist until the next round.
     * 
     *  The dispatch origin of this call must be signed, and have one of the above roles.
     * 
     *  # <weight>
     *  The type of renouncing must be provided as witness data.
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('PhragmenElection.renounce_candidacy') === '891a3ff219ab8817cfffbcd0ed48578a0fd96440dc2292a0cde84a40439f7fbe'
    }

    /**
     *  Renounce one's intention to be a candidate for the next election round. 3 potential
     *  outcomes exist:
     * 
     *  - `origin` is a candidate and not elected in any set. In this case, the deposit is
     *    unreserved, returned and origin is removed as a candidate.
     *  - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
     *    origin is removed as a runner-up.
     *  - `origin` is a current member. In this case, the deposit is unreserved and origin is
     *    removed as a member, consequently not being a candidate for the next round anymore.
     *    Similar to [`remove_members`], if replacement runners exists, they are immediately
     *    used. If the prime is renouncing, then no prime will exist until the next round.
     * 
     *  The dispatch origin of this call must be signed, and have one of the above roles.
     * 
     *  # <weight>
     *  The type of renouncing must be provided as witness data.
     *  # </weight>
     */
    get asV9010(): {renouncing: v9010.Renouncing} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class PhragmenElectionSubmitCandidacyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PhragmenElection.submit_candidacy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Submit oneself for candidacy. A fixed amount of deposit is recorded.
     * 
     *  All candidates are wiped at the end of the term. They either become a member/runner-up,
     *  or leave the system while their deposit is slashed.
     * 
     *  The dispatch origin of this call must be signed.
     * 
     *  ### Warning
     * 
     *  Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
     *  to get their deposit back. Losing the spot in an election will always lead to a slash.
     * 
     *  # <weight>
     *  The number of current candidates must be provided as witness data.
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('PhragmenElection.submit_candidacy') === 'f9d2bc9f755e33c27d34db4c3b063daa9e2490111d35f89ea1995d74e59b1819'
    }

    /**
     *  Submit oneself for candidacy. A fixed amount of deposit is recorded.
     * 
     *  All candidates are wiped at the end of the term. They either become a member/runner-up,
     *  or leave the system while their deposit is slashed.
     * 
     *  The dispatch origin of this call must be signed.
     * 
     *  ### Warning
     * 
     *  Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
     *  to get their deposit back. Losing the spot in an election will always lead to a slash.
     * 
     *  # <weight>
     *  The number of current candidates must be provided as witness data.
     *  # </weight>
     */
    get asV9010(): {candidateCount: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class PhragmenElectionVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'PhragmenElection.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Vote for a set of candidates for the upcoming round of election. This can be called to
     *  set the initial votes, or update already existing votes.
     * 
     *  Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
     *  reserved. The deposit is based on the number of votes and can be updated over time.
     * 
     *  The `votes` should:
     *    - not be empty.
     *    - be less than the number of possible candidates. Note that all current members and
     *      runners-up are also automatically candidates for the next round.
     * 
     *  If `value` is more than `who`'s total balance, then the maximum of the two is used.
     * 
     *  The dispatch origin of this call must be signed.
     * 
     *  ### Warning
     * 
     *  It is the responsibility of the caller to **NOT** place all of their balance into the
     *  lock and keep some for further operations.
     * 
     *  # <weight>
     *  We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less.
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('PhragmenElection.vote') === '75939c25de1c96145b5d2d4bc8627a3fc22299f0e1f1f6f0709e54e884796bda'
    }

    /**
     *  Vote for a set of candidates for the upcoming round of election. This can be called to
     *  set the initial votes, or update already existing votes.
     * 
     *  Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
     *  reserved. The deposit is based on the number of votes and can be updated over time.
     * 
     *  The `votes` should:
     *    - not be empty.
     *    - be less than the number of possible candidates. Note that all current members and
     *      runners-up are also automatically candidates for the next round.
     * 
     *  If `value` is more than `who`'s total balance, then the maximum of the two is used.
     * 
     *  The dispatch origin of this call must be signed.
     * 
     *  ### Warning
     * 
     *  It is the responsibility of the caller to **NOT** place all of their balance into the
     *  lock and keep some for further operations.
     * 
     *  # <weight>
     *  We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less.
     *  # </weight>
     */
    get asV9010(): {votes: Uint8Array[], value: bigint} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class PreimageNotePreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Preimage.note_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Register a preimage on-chain.
     * 
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Preimage.note_preimage') === 'fb6f9f7fd683160ab20dcde42ca8f757bc13845dc544f497e534fcf19c270a46'
    }

    /**
     * Register a preimage on-chain.
     * 
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     */
    get asV9160(): {bytes: Uint8Array} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class PreimageRequestPreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Preimage.request_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     * 
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Preimage.request_preimage') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     * 
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     */
    get asV9160(): {hash: Uint8Array} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class PreimageUnnotePreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Preimage.unnote_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Clear an unrequested preimage from the runtime storage.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Preimage.unnote_preimage') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     * Clear an unrequested preimage from the runtime storage.
     */
    get asV9160(): {hash: Uint8Array} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class PreimageUnrequestPreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Preimage.unrequest_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Clear a previously made request for a preimage.
     * 
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Preimage.unrequest_preimage') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     * Clear a previously made request for a preimage.
     * 
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     */
    get asV9160(): {hash: Uint8Array} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyAddProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.add_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `proxy`: The account that the `caller` would like to make a proxy.
     *  - `proxy_type`: The permissions allowed for this proxy account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 17.48 + .176 * P µs
     *  - DB weight: 1 storage read and write.
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Proxy.add_proxy') === '44f99d79af0ecee7db7959ac2fcd0be087f4982ee661630fa820953132759746'
    }

    /**
     *  Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `proxy`: The account that the `caller` would like to make a proxy.
     *  - `proxy_type`: The permissions allowed for this proxy account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 17.48 + .176 * P µs
     *  - DB weight: 1 storage read and write.
     *  # </weight>
     */
    get asV2005(): {proxy: Uint8Array, proxyType: v2005.ProxyType} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `proxy`: The account that the `caller` would like to make a proxy.
     *  - `proxy_type`: The permissions allowed for this proxy account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Proxy.add_proxy') === '6af70afabe78369204b2f8c08cc716bb4c7018534804dd5740dae2f192f93dbf'
    }

    /**
     *  Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `proxy`: The account that the `caller` would like to make a proxy.
     *  - `proxy_type`: The permissions allowed for this proxy account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV2023(): {delegate: Uint8Array, proxyType: v2023.ProxyType, delay: number} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Proxy.add_proxy') === '7f40d96b85f57c1c65bcfefdcded2012133e1bbc32e665b2ce6cb93b63f13311'
    }

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9180(): {delegate: Uint8Array, proxyType: v9180.ProxyType, delay: number} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Proxy.add_proxy') === '736bb60d85e1f8c45a10e962b2f5aefc0ffe45e083a582e3b984d6ab315c0794'
    }

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9291(): {delegate: v9291.MultiAddress, proxyType: v9291.ProxyType, delay: number} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyAnnounceCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.announce')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Publish the hash of a proxy-call that will be made in the future.
     * 
     *  This must be called some number of blocks before the corresponding `proxy` is attempted
     *  if the delay associated with the proxy relationship is greater than zero.
     * 
     *  No more than `MaxPending` announcements may be made at any one time.
     * 
     *  This will take a deposit of `AnnouncementDepositFactor` as well as
     *  `AnnouncementDepositBase` if there are no other pending announcements.
     * 
     *  The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `call_hash`: The hash of the call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Proxy.announce') === '886fe5248256b2372151aa5c936f9027a64929a3501efe231a22f1ee868cff3e'
    }

    /**
     *  Publish the hash of a proxy-call that will be made in the future.
     * 
     *  This must be called some number of blocks before the corresponding `proxy` is attempted
     *  if the delay associated with the proxy relationship is greater than zero.
     * 
     *  No more than `MaxPending` announcements may be made at any one time.
     * 
     *  This will take a deposit of `AnnouncementDepositFactor` as well as
     *  `AnnouncementDepositBase` if there are no other pending announcements.
     * 
     *  The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `call_hash`: The hash of the call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV2023(): {real: Uint8Array, callHash: Uint8Array} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     * 
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     * 
     * No more than `MaxPending` announcements may be made at any one time.
     * 
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     * 
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Proxy.announce') === '1e2ba1b130bab29ab148202fefa1b526f6d362ed3f3d2aaf35cc706821c5cd49'
    }

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     * 
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     * 
     * No more than `MaxPending` announcements may be made at any one time.
     * 
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     * 
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9291(): {real: v9291.MultiAddress, callHash: Uint8Array} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyAnonymousCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.anonymous')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     *  initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     *  Requires a `Signed` origin.
     * 
     *  - `proxy_type`: The type of the proxy that the sender will be registered as over the
     *  new account. This will almost always be the most permissive `ProxyType` possible to
     *  allow for maximum flexibility.
     *  - `index`: A disambiguation index, in case this is called multiple times in the same
     *  transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     *  want to use `0`.
     * 
     *  Fails with `Duplicate` if this has already been called in this transaction, from the
     *  same sender, with the same parameters.
     * 
     *  Fails if there are insufficient funds to pay for deposit.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 36.48 + .039 * P µs
     *  - DB weight: 1 storage read and write.
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Proxy.anonymous') === 'd5bd7dd5bc41f7b1145d73ed9d70910b52c4f28a9f1a8a3842108bb3f14d0acb'
    }

    /**
     *  Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     *  initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     *  Requires a `Signed` origin.
     * 
     *  - `proxy_type`: The type of the proxy that the sender will be registered as over the
     *  new account. This will almost always be the most permissive `ProxyType` possible to
     *  allow for maximum flexibility.
     *  - `index`: A disambiguation index, in case this is called multiple times in the same
     *  transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     *  want to use `0`.
     * 
     *  Fails with `Duplicate` if this has already been called in this transaction, from the
     *  same sender, with the same parameters.
     * 
     *  Fails if there are insufficient funds to pay for deposit.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 36.48 + .039 * P µs
     *  - DB weight: 1 storage read and write.
     *  # </weight>
     */
    get asV2005(): {proxyType: v2005.ProxyType, index: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     *  initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     *  Requires a `Signed` origin.
     * 
     *  - `proxy_type`: The type of the proxy that the sender will be registered as over the
     *  new account. This will almost always be the most permissive `ProxyType` possible to
     *  allow for maximum flexibility.
     *  - `index`: A disambiguation index, in case this is called multiple times in the same
     *  transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     *  want to use `0`.
     *  - `delay`: The announcement period required of the initial proxy. Will generally be
     *  zero.
     * 
     *  Fails with `Duplicate` if this has already been called in this transaction, from the
     *  same sender, with the same parameters.
     * 
     *  Fails if there are insufficient funds to pay for deposit.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     *  TODO: Might be over counting 1 read
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Proxy.anonymous') === '5a91bb8964e3268c39fef86f6486b814ca6631a0acb4e8a53539e9626f56203c'
    }

    /**
     *  Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     *  initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     *  Requires a `Signed` origin.
     * 
     *  - `proxy_type`: The type of the proxy that the sender will be registered as over the
     *  new account. This will almost always be the most permissive `ProxyType` possible to
     *  allow for maximum flexibility.
     *  - `index`: A disambiguation index, in case this is called multiple times in the same
     *  transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     *  want to use `0`.
     *  - `delay`: The announcement period required of the initial proxy. Will generally be
     *  zero.
     * 
     *  Fails with `Duplicate` if this has already been called in this transaction, from the
     *  same sender, with the same parameters.
     * 
     *  Fails if there are insufficient funds to pay for deposit.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     *  TODO: Might be over counting 1 read
     */
    get asV2023(): {proxyType: v2023.ProxyType, delay: number, index: number} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     * Requires a `Signed` origin.
     * 
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     * 
     * Fails if there are insufficient funds to pay for deposit.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     * TODO: Might be over counting 1 read
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Proxy.anonymous') === '3233758a9077ff591727ac841f0563c310d2c8475a287b9165d561d1eb0f9863'
    }

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     * Requires a `Signed` origin.
     * 
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     * 
     * Fails if there are insufficient funds to pay for deposit.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     * TODO: Might be over counting 1 read
     */
    get asV9180(): {proxyType: v9180.ProxyType, delay: number, index: number} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyCreatePureCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.create_pure')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     * Requires a `Signed` origin.
     * 
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     * 
     * Fails if there are insufficient funds to pay for deposit.
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Proxy.create_pure') === '3233758a9077ff591727ac841f0563c310d2c8475a287b9165d561d1eb0f9863'
    }

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     * 
     * Requires a `Signed` origin.
     * 
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     * 
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     * 
     * Fails if there are insufficient funds to pay for deposit.
     */
    get asV9300(): {proxyType: v9300.ProxyType, delay: number, index: number} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyKillAnonymousCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.kill_anonymous')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Removes a previously spawned anonymous proxy.
     * 
     *  WARNING: **All access to this account will be lost.** Any funds held in it will be
     *  inaccessible.
     * 
     *  Requires a `Signed` origin, and the sender account must have been created by a call to
     *  `anonymous` with corresponding parameters.
     * 
     *  - `spawner`: The account that originally called `anonymous` to create this account.
     *  - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.
     *  - `proxy_type`: The proxy type originally passed to `anonymous`.
     *  - `height`: The height of the chain when the call to `anonymous` was processed.
     *  - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.
     * 
     *  Fails with `NoPermission` in case the caller is not a previously created anonymous
     *  account whose `anonymous` call has corresponding parameters.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 15.65 + .137 * P µs
     *  - DB weight: 1 storage read and write.
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Proxy.kill_anonymous') === '4efbea40f12d27843ad8d921ef885b8b119995c009d891dc1f49c3f1b54950a8'
    }

    /**
     *  Removes a previously spawned anonymous proxy.
     * 
     *  WARNING: **All access to this account will be lost.** Any funds held in it will be
     *  inaccessible.
     * 
     *  Requires a `Signed` origin, and the sender account must have been created by a call to
     *  `anonymous` with corresponding parameters.
     * 
     *  - `spawner`: The account that originally called `anonymous` to create this account.
     *  - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.
     *  - `proxy_type`: The proxy type originally passed to `anonymous`.
     *  - `height`: The height of the chain when the call to `anonymous` was processed.
     *  - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.
     * 
     *  Fails with `NoPermission` in case the caller is not a previously created anonymous
     *  account whose `anonymous` call has corresponding parameters.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 15.65 + .137 * P µs
     *  - DB weight: 1 storage read and write.
     *  # </weight>
     */
    get asV2005(): {spawner: Uint8Array, proxyType: v2005.ProxyType, index: number, height: number, extIndex: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Removes a previously spawned anonymous proxy.
     * 
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     * 
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `anonymous` with corresponding parameters.
     * 
     * - `spawner`: The account that originally called `anonymous` to create this account.
     * - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `anonymous`.
     * - `height`: The height of the chain when the call to `anonymous` was processed.
     * - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.
     * 
     * Fails with `NoPermission` in case the caller is not a previously created anonymous
     * account whose `anonymous` call has corresponding parameters.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Proxy.kill_anonymous') === '81ce814a82bb8be857d63f3182a01882c40dc1be1dcd590cf7469b637913e796'
    }

    /**
     * Removes a previously spawned anonymous proxy.
     * 
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     * 
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `anonymous` with corresponding parameters.
     * 
     * - `spawner`: The account that originally called `anonymous` to create this account.
     * - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `anonymous`.
     * - `height`: The height of the chain when the call to `anonymous` was processed.
     * - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.
     * 
     * Fails with `NoPermission` in case the caller is not a previously created anonymous
     * account whose `anonymous` call has corresponding parameters.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9180(): {spawner: Uint8Array, proxyType: v9180.ProxyType, index: number, height: number, extIndex: number} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Removes a previously spawned anonymous proxy.
     * 
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     * 
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `anonymous` with corresponding parameters.
     * 
     * - `spawner`: The account that originally called `anonymous` to create this account.
     * - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `anonymous`.
     * - `height`: The height of the chain when the call to `anonymous` was processed.
     * - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.
     * 
     * Fails with `NoPermission` in case the caller is not a previously created anonymous
     * account whose `anonymous` call has corresponding parameters.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Proxy.kill_anonymous') === 'f9b25ab9a1db47807bc07c907a249982635532bd858ef287fed07bf4c0833c49'
    }

    /**
     * Removes a previously spawned anonymous proxy.
     * 
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     * 
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `anonymous` with corresponding parameters.
     * 
     * - `spawner`: The account that originally called `anonymous` to create this account.
     * - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `anonymous`.
     * - `height`: The height of the chain when the call to `anonymous` was processed.
     * - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.
     * 
     * Fails with `NoPermission` in case the caller is not a previously created anonymous
     * account whose `anonymous` call has corresponding parameters.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9291(): {spawner: v9291.MultiAddress, proxyType: v9291.ProxyType, index: number, height: number, extIndex: number} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyKillPureCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.kill_pure')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Removes a previously spawned pure proxy.
     * 
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     * 
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     * 
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     * 
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Proxy.kill_pure') === 'f9b25ab9a1db47807bc07c907a249982635532bd858ef287fed07bf4c0833c49'
    }

    /**
     * Removes a previously spawned pure proxy.
     * 
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     * 
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     * 
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     * 
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     */
    get asV9300(): {spawner: v9300.MultiAddress, proxyType: v9300.ProxyType, index: number, height: number, extIndex: number} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 19.87 + .141 * P µs
     *  - DB weight: 1 storage read.
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '520c93e0dd69823bc2a944dfc28774876216d3008046057fc561896841103041'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 19.87 + .141 * P µs
     *  - DB weight: 1 storage read.
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2005(): {real: Uint8Array, forceProxyType: (v2005.ProxyType | undefined), call: v2005.Type_188} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 19.87 + .141 * P µs
     *  - DB weight: 1 storage read.
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'c0d77ffe406bbe33a35a9e8b5e14cde09d0b90754f6083473d2ef63bda49d2af'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 19.87 + .141 * P µs
     *  - DB weight: 1 storage read.
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2007(): {real: Uint8Array, forceProxyType: (v2007.ProxyType | undefined), call: v2007.Type_189} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 19.87 + .141 * P µs
     *  - DB weight: 1 storage read.
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'a57d4d369eda1d813972e23633b05ea2fccd6a7e35270b26e969cfe9cf9a35aa'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 19.87 + .141 * P µs
     *  - DB weight: 1 storage read.
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2011(): {real: Uint8Array, forceProxyType: (v2011.ProxyType | undefined), call: v2011.Type_190} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 19.87 + .141 * P µs
     *  - DB weight: 1 storage read.
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '40149d7b321c1451cfeb3e157498c2e3d1c9e4cdd168d88e3fb96d99fe68fe92'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 19.87 + .141 * P µs
     *  - DB weight: 1 storage read.
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2013(): {real: Uint8Array, forceProxyType: (v2013.ProxyType | undefined), call: v2013.Type_190} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 19.87 + .141 * P µs
     *  - DB weight: 1 storage read.
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'b5d0156978f9a9356f14425deb7e665d77900d73adb7465cacf59072b12e2abb'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 19.87 + .141 * P µs
     *  - DB weight: 1 storage read.
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2015(): {real: Uint8Array, forceProxyType: (v2015.ProxyType | undefined), call: v2015.Type_192} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 19.87 + .141 * P µs
     *  - DB weight: 1 storage read.
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'd973bad8e7c9ca97c438e7dfeb2ce544858c222ef8907e8ac4b33e721d09258a'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 19.87 + .141 * P µs
     *  - DB weight: 1 storage read.
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2022(): {real: Uint8Array, forceProxyType: (v2022.ProxyType | undefined), call: v2022.Type_192} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '6a2ae5dd6423f54788ab193868a62cc3a37d0683ee5091a38141d0e67ac08968'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV2023(): {real: Uint8Array, forceProxyType: (v2023.ProxyType | undefined), call: v2023.Type_194} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'a984a84e8c41ea5f4400dfd47cfd9462a525d95bb05e77879e12b9594ccbfb1b'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV2024(): {real: Uint8Array, forceProxyType: (v2024.ProxyType | undefined), call: v2024.Type_194} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '17452293ca679292ab6b03a5967e15e8d81d8110efa289b7d4575f2b725db091'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV2025(): {real: Uint8Array, forceProxyType: (v2025.ProxyType | undefined), call: v2025.Type_195} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '969b27dde4c23ab51921123750aa61783d51d45e16a1f572e8e7a42693a47b63'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV2026(): {real: Uint8Array, forceProxyType: (v2026.ProxyType | undefined), call: v2026.Type_194} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '616e4eb1ca33847d421e014558c25484f30808990b822e53bd5be1d4a41b9703'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV2028(): {real: Uint8Array, forceProxyType: (v2028.ProxyType | undefined), call: v2028.Type_199} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '08ce960fca40ea5f8b0cea5d9204613dabf847880a4d081fb39b96c711450081'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV2029(): {real: Uint8Array, forceProxyType: (v2029.ProxyType | undefined), call: v2029.Type_199} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '022f9cc3f2a88ea65c4e80fb3185f439b2e729859aff6d1770b5173c93543c61'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV2030(): {real: Uint8Array, forceProxyType: (v2030.ProxyType | undefined), call: v2030.Type_138} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '9b1a9e942d0fc765c098a6c4724130d3dbc434e757b97c2fe2177764646b1ed1'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV9010(): {real: Uint8Array, forceProxyType: (v9010.ProxyType | undefined), call: v9010.Type_138} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'c62be92c04bf09c0e150f1e5bdc7b882a3faecf230b95ed30109b7b5e2e831fa'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV9030(): {real: Uint8Array, forceProxyType: (v9030.ProxyType | undefined), call: v9030.Type_138} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '0c106915e806b09169fc7b721467053a8d200751557192db540e89909a6fcd0b'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV9040(): {real: Uint8Array, forceProxyType: (v9040.ProxyType | undefined), call: v9040.Type_138} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '99fd4eeef30791fc0af77ef46dc9706790806dfb7bd66520950b8b07bc993f70'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV9050(): {real: Uint8Array, forceProxyType: (v9050.ProxyType | undefined), call: v9050.Type_139} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'c7e33c088b6d7cc2d7d07b709a32bb9dbfec0ace3634cd5c24b1be05e1f35f79'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV9080(): {real: Uint8Array, forceProxyType: (v9080.ProxyType | undefined), call: v9080.Type_138} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '43fbde8e5e5d756dc14ef47c3dbfff8fc4003e0c78a1302118547ce5258dfa8b'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV9090(): {real: Uint8Array, forceProxyType: (v9090.ProxyType | undefined), call: v9090.Type_138} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'cd6d1e332814e808fd18454a4af9dc740a58337e42f39ea4d31c64b9e6859710'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV9100(): {real: Uint8Array, forceProxyType: (v9100.ProxyType | undefined), call: v9100.Type_138} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'fb5537fbdf17a7bf07cb99a60f74e4ab28d9178774cb66117100c8198caefacf'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9111(): {real: Uint8Array, forceProxyType: (v9111.ProxyType | undefined), call: v9111.Call} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'a35405df7109c14d867e8935e3a4cf15f20778e5d6b462dcdad045d8fe343d9a'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9122(): {real: Uint8Array, forceProxyType: (v9122.ProxyType | undefined), call: v9122.Call} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'b74bb774599e5c5806bfe3ce8b32444fab595ff6e640da06dc3a43e4daa00301'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9130(): {real: Uint8Array, forceProxyType: (v9130.ProxyType | undefined), call: v9130.Call} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '07a23cb5f97cde36f93020b0ab5ff7bc237d7b68aa6e616a3c1536ddc7e4d5f9'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9160(): {real: Uint8Array, forceProxyType: (v9160.ProxyType | undefined), call: v9160.Call} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'ff12981cd73adb974faf8531ac1f386f158756576f65f997c053cc60eeefd06e'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9170(): {real: Uint8Array, forceProxyType: (v9170.ProxyType | undefined), call: v9170.Call} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '31f9ff91a5bb7fed9674596602af43c2492343923229f7b5adba1e9f06754fd3'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9180(): {real: Uint8Array, forceProxyType: (v9180.ProxyType | undefined), call: v9180.Call} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '16e03fa7c7e1b6bae68bb4b48b438ed1a1f1cce5b558b8d85cc7cd4c1236a366'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9190(): {real: Uint8Array, forceProxyType: (v9190.ProxyType | undefined), call: v9190.Call} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'a37410c7d153cc2f9cb90043b39df48ffcc7521009b8aaf402683445d2dc95a6'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9220(): {real: Uint8Array, forceProxyType: (v9220.ProxyType | undefined), call: v9220.Call} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '99b58f3a62d993879ed218ded97e8c704c76fdab48c213ea583f01d1ee8662dd'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9230(): {real: Uint8Array, forceProxyType: (v9230.ProxyType | undefined), call: v9230.Call} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '9dde280b6cdf944c534a49740ddb207a95161109b7a1b236f40245ceec0d3bfc'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9250(): {real: Uint8Array, forceProxyType: (v9250.ProxyType | undefined), call: v9250.Call} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '8b27523a84064841465014882911b634fe209ef8b1a9524f380a915c0f2770ab'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9271(): {real: Uint8Array, forceProxyType: (v9271.ProxyType | undefined), call: v9271.Call} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'de50858b61768c9bf64a0da4d17e503d771671a7cb39fd9d829856f3cfee07ea'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9291(): {real: v9291.MultiAddress, forceProxyType: (v9291.ProxyType | undefined), call: v9291.Call} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '50499479a459962a998d81187d03c6f9ecd81f5da429d91c76b2cd1232227494'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV9300(): {real: v9300.MultiAddress, forceProxyType: (v9300.ProxyType | undefined), call: v9300.Call} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === '2fb5741e491d365c0371920e50360bf2043a9225c57e452a37ada3401610ad29'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV9320(): {real: v9320.MultiAddress, forceProxyType: (v9320.ProxyType | undefined), call: v9320.Call} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'a90f9bf4bc45e72304c38564d0915decd40ab804cfc7a1a8c7a196c84d4a5c40'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV9340(): {real: v9340.MultiAddress, forceProxyType: (v9340.ProxyType | undefined), call: v9340.Call} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'd6673817b60624cbe38bbf52ea8c1a959be6fd0de28addd201c37e4b4f3befc1'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV9350(): {real: v9350.MultiAddress, forceProxyType: (v9350.ProxyType | undefined), call: v9350.Call} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Proxy.proxy') === 'a0564437e0e4cfce4a5a102e6c8dfecb48104108dbee4c800f24e606d3fa99b4'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV9370(): {real: v9370.MultiAddress, forceProxyType: (v9370.ProxyType | undefined), call: v9370.Call} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyProxyAnnouncedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.proxy_announced')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '88589676e781f01795a8cd95573c1b29f8f868b03f512090922757bce29d7db1'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV2023(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v2023.ProxyType | undefined), call: v2023.Type_194} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '604bbccf2df01dc5a0f7c17903b9d45d35f743d16ac0eb81ccb479456196bae4'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV2024(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v2024.ProxyType | undefined), call: v2024.Type_194} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'ca35a709139655ebcab0826baefef78deeda8f794f852def63f955dd56d876e0'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV2025(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v2025.ProxyType | undefined), call: v2025.Type_195} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'f4f675610a5f1b2f08d1ccebabf9fbcfe463c05580a9effb48e743a37b655570'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV2026(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v2026.ProxyType | undefined), call: v2026.Type_194} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '80282e3942f2782b4ab353bb3161fab5235c3d1abdf350a47a14dba0741ff155'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV2028(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v2028.ProxyType | undefined), call: v2028.Type_199} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '8abf342bd89dfd7926058b35bf9879fc1af7b4ada87c9e47c4c0508f3fba54c9'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorised for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV2029(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v2029.ProxyType | undefined), call: v2029.Type_199} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '16157a8f411ce278070e439228d51c30215e814176f3c1c815d22fb6713271f8'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV2030(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v2030.ProxyType | undefined), call: v2030.Type_138} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'd4ddea2cffc502e0f028ccd7736501b5a2596cf0ae0039878b48bdc1a0b8c605'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV9010(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9010.ProxyType | undefined), call: v9010.Type_138} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '31adf3a18d0e706d82c319c9ee654c268c8b27de0e5c16dfd9ee843a8630c75f'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV9030(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9030.ProxyType | undefined), call: v9030.Type_138} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '0c370833de911537109fb546555945c1683ad530e3b65609de3c56491c628b70'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV9040(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9040.ProxyType | undefined), call: v9040.Type_138} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'b5fd8ed4511638daecc6baf73085a332d7b2508d99ff26de3685e6f349d6910a'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV9050(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9050.ProxyType | undefined), call: v9050.Type_139} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '934c2e4f1d6c2deefed1c43ec4a905dd51ab6226f40544cd7b3de96020bbc1ba'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV9080(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9080.ProxyType | undefined), call: v9080.Type_138} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '0eb6db55eb67d4e72087166b9625f3a307b8d5a150736accdcc8cd697aec996b'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV9090(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9090.ProxyType | undefined), call: v9090.Type_138} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '4779fd39df284221ea2205f7e0ffaaf0ec1a928d3b4c9dd890c5b92de6864407'
    }

    /**
     *  Dispatch the given `call` from an account that the sender is authorized for through
     *  `add_proxy`.
     * 
     *  Removes any corresponding announcement(s).
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     *  - `call`: The call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV9100(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9100.ProxyType | undefined), call: v9100.Type_138} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '0da45f1bd343bf58d152bd6360c6e8f0c876fe4b991c293e47774631a35b1cdd'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9111(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9111.ProxyType | undefined), call: v9111.Call} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'a767820b2fd683058445cbeaebedd0d0540c32b30b5883b0161daa67ee849b13'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9122(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9122.ProxyType | undefined), call: v9122.Call} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '8ea22e49cd28d64a68b9e5d5c31ed9b79f1b5b82178a55aac131748cf4b48b7d'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9130(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9130.ProxyType | undefined), call: v9130.Call} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'f007b3df26d00b21dad84b313d5bb9ffa4b248aab2189187755e76c6e6a1d66f'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9160(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9160.ProxyType | undefined), call: v9160.Call} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '86618fee3cd8f9a2e24ac3317e614418e29ea844a259103991647d27fcf26d0a'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9170(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9170.ProxyType | undefined), call: v9170.Call} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '898d51cb39f6bd1ad049d8bbea2bd8e2c23c8c7f1baf2a78845146ce939b3126'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9180(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9180.ProxyType | undefined), call: v9180.Call} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '11ee228b46513431346bdcf8e07c16286f6316a24b055306d86bc785cd677dcd'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9190(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9190.ProxyType | undefined), call: v9190.Call} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'e3fbecd093816274027cd2dd84c6d297d484cfead077ce366c2debc71ed5e575'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9220(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9220.ProxyType | undefined), call: v9220.Call} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'e99ee37550e6acf7d8be6489036fb6181079a2851c7f49f27e1ee6a55b903c85'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9230(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9230.ProxyType | undefined), call: v9230.Call} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '6529895a06bd89b610160f49150e2786c97344713b3fcd24e56ed16b969e7651'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9250(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9250.ProxyType | undefined), call: v9250.Call} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '313906d8a448e1a69bc83857b5006dc194b5ac56b7e0209b36955269f4bff5d4'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9271(): {delegate: Uint8Array, real: Uint8Array, forceProxyType: (v9271.ProxyType | undefined), call: v9271.Call} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '9e07db3e06d85e0b0bf30aa73c76dfe7611b7026d8b04c154a71af9713f9149b'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9291(): {delegate: v9291.MultiAddress, real: v9291.MultiAddress, forceProxyType: (v9291.ProxyType | undefined), call: v9291.Call} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'f2b0b2dec5cd4c023ef096215b40dab81d246febaeadea450afdbeb8da17c74b'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV9300(): {delegate: v9300.MultiAddress, real: v9300.MultiAddress, forceProxyType: (v9300.ProxyType | undefined), call: v9300.Call} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'e533203066a39e4a1c73201c6577d019043e66282582a0f312fac7f70ee4dd5c'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV9320(): {delegate: v9320.MultiAddress, real: v9320.MultiAddress, forceProxyType: (v9320.ProxyType | undefined), call: v9320.Call} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'b8e17129138aa06af276479b8284cb2a8e54d2c397fd171b8151f77e8252276a'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV9340(): {delegate: v9340.MultiAddress, real: v9340.MultiAddress, forceProxyType: (v9340.ProxyType | undefined), call: v9340.Call} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === 'd289071b290f8e68cc5794c7c67699e664aa0b41edd3f69ceebca6b19957b247'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV9350(): {delegate: v9350.MultiAddress, real: v9350.MultiAddress, forceProxyType: (v9350.ProxyType | undefined), call: v9350.Call} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Proxy.proxy_announced') === '2d8e35818b6f3f68cc760945ef4776e22de6fa06775b52c6418205f490e5f5c4'
    }

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     * 
     * Removes any corresponding announcement(s).
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     */
    get asV9370(): {delegate: v9370.MultiAddress, real: v9370.MultiAddress, forceProxyType: (v9370.ProxyType | undefined), call: v9370.Call} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyRejectAnnouncementCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.reject_announcement')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove the given announcement of a delegate.
     * 
     *  May be called by a target (proxied) account to remove a call that one of their delegates
     *  (`delegate`) has announced they want to execute. The deposit is returned.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `delegate`: The account that previously announced the call.
     *  - `call_hash`: The hash of the call to be made.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Proxy.reject_announcement') === '717e6dbb2911f49e34a3b48c48c86b40495423ab31d5b45f0062629c73057f2b'
    }

    /**
     *  Remove the given announcement of a delegate.
     * 
     *  May be called by a target (proxied) account to remove a call that one of their delegates
     *  (`delegate`) has announced they want to execute. The deposit is returned.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `delegate`: The account that previously announced the call.
     *  - `call_hash`: The hash of the call to be made.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV2023(): {delegate: Uint8Array, callHash: Uint8Array} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove the given announcement of a delegate.
     * 
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Proxy.reject_announcement') === 'a1d7c3959dec3e3a68a4ea7b541568e066bd95b7007b052c43ff4736abe9b06b'
    }

    /**
     * Remove the given announcement of a delegate.
     * 
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9291(): {delegate: v9291.MultiAddress, callHash: Uint8Array} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyRemoveAnnouncementCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.remove_announcement')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a given announcement.
     * 
     *  May be called by a proxy account to remove a call they previously announced and return
     *  the deposit.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `call_hash`: The hash of the call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Proxy.remove_announcement') === '886fe5248256b2372151aa5c936f9027a64929a3501efe231a22f1ee868cff3e'
    }

    /**
     *  Remove a given announcement.
     * 
     *  May be called by a proxy account to remove a call they previously announced and return
     *  the deposit.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `real`: The account that the proxy will make a call on behalf of.
     *  - `call_hash`: The hash of the call to be made by the `real` account.
     * 
     *  # <weight>
     *  Weight is a function of:
     *  - A: the number of announcements made.
     *  - P: the number of proxies the user has.
     *  # </weight>
     */
    get asV2023(): {real: Uint8Array, callHash: Uint8Array} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove a given announcement.
     * 
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Proxy.remove_announcement') === '1e2ba1b130bab29ab148202fefa1b526f6d362ed3f3d2aaf35cc706821c5cd49'
    }

    /**
     * Remove a given announcement.
     * 
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     * 
     * # <weight>
     * Weight is a function of:
     * - A: the number of announcements made.
     * - P: the number of proxies the user has.
     * # </weight>
     */
    get asV9291(): {real: v9291.MultiAddress, callHash: Uint8Array} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyRemoveProxiesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.remove_proxies')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unregister all proxy accounts for the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  WARNING: This may be called on accounts created by `anonymous`, however if done, then
     *  the unreserved fees will be inaccessible. **All access to this account will be lost.**
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 13.73 + .129 * P µs
     *  - DB weight: 1 storage read and write.
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Proxy.remove_proxies') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Unregister all proxy accounts for the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  WARNING: This may be called on accounts created by `anonymous`, however if done, then
     *  the unreserved fees will be inaccessible. **All access to this account will be lost.**
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 13.73 + .129 * P µs
     *  - DB weight: 1 storage read and write.
     *  # </weight>
     */
    get asV2005(): null {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class ProxyRemoveProxyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Proxy.remove_proxy')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unregister a proxy account for the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `proxy`: The account that the `caller` would like to remove as a proxy.
     *  - `proxy_type`: The permissions currently enabled for the removed proxy account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 14.37 + .164 * P µs
     *  - DB weight: 1 storage read and write.
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Proxy.remove_proxy') === '44f99d79af0ecee7db7959ac2fcd0be087f4982ee661630fa820953132759746'
    }

    /**
     *  Unregister a proxy account for the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `proxy`: The account that the `caller` would like to remove as a proxy.
     *  - `proxy_type`: The permissions currently enabled for the removed proxy account.
     * 
     *  # <weight>
     *  P is the number of proxies the user has
     *  - Base weight: 14.37 + .164 * P µs
     *  - DB weight: 1 storage read and write.
     *  # </weight>
     */
    get asV2005(): {proxy: Uint8Array, proxyType: v2005.ProxyType} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Unregister a proxy account for the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `proxy`: The account that the `caller` would like to remove as a proxy.
     *  - `proxy_type`: The permissions currently enabled for the removed proxy account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Proxy.remove_proxy') === '6af70afabe78369204b2f8c08cc716bb4c7018534804dd5740dae2f192f93dbf'
    }

    /**
     *  Unregister a proxy account for the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `proxy`: The account that the `caller` would like to remove as a proxy.
     *  - `proxy_type`: The permissions currently enabled for the removed proxy account.
     * 
     *  # <weight>
     *  Weight is a function of the number of proxies the user has (P).
     *  # </weight>
     */
    get asV2023(): {delegate: Uint8Array, proxyType: v2023.ProxyType, delay: number} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Unregister a proxy account for the sender.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Proxy.remove_proxy') === '7f40d96b85f57c1c65bcfefdcded2012133e1bbc32e665b2ce6cb93b63f13311'
    }

    /**
     * Unregister a proxy account for the sender.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9180(): {delegate: Uint8Array, proxyType: v9180.ProxyType, delay: number} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Unregister a proxy account for the sender.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Proxy.remove_proxy') === '736bb60d85e1f8c45a10e962b2f5aefc0ffe45e083a582e3b984d6ab315c0794'
    }

    /**
     * Unregister a proxy account for the sender.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     * 
     * # <weight>
     * Weight is a function of the number of proxies the user has (P).
     * # </weight>
     */
    get asV9291(): {delegate: v9291.MultiAddress, proxyType: v9291.ProxyType, delay: number} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class RecoveryAsRecoveredCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Recovery.as_recovered')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '0197dfc43d24c9be89b393dadb95d4d6166f2cac450f03f44d553a8b05119ba6'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV1040(): {account: Uint8Array, call: v1040.Type_110} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'db54463879a561b623bb55a280fd1e458911c3a597eb5c79c5dedf2141b81bcf'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV1042(): {account: Uint8Array, call: v1042.Type_110} {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'b282e0204bc6a9d340f422064d2a1b2b82fdea53496a7bfc61d04e2679a3be4f'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV1050(): {account: Uint8Array, call: v1050.Type_113} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV1054(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'd9aa5a267568050020db2a296d2f427d937e553dc94c6c51ecdaa598e159d422'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV1054(): {account: Uint8Array, call: v1054.Type_113} {
        assert(this.isV1054)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'aae928cb9e8a6e58b4e32a21b360080db4ef51599ca388a794b93f64739d0f6c'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV1055(): {account: Uint8Array, call: v1055.Type_116} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'd8fd05a6ded6492d1f459d816bd08b127b27a2231366fef75844dadb8169ae1c'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV1058(): {account: Uint8Array, call: v1058.Type_176} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV1062(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'f564a559d0f669ef9c274324439c665d704b47b28e9975fae19ac4c7e3ddd575'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV1062(): {account: Uint8Array, call: v1062.Type_175} {
        assert(this.isV1062)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'e72d4a588e206964415d594510fbe5871d85cb2622f7bde7892d5257cf501420'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2005(): {account: Uint8Array, call: v2005.Type_188} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'db346aa82f75222cff8a57ede1d27c225e2e99a4c5b280e78fb02e64ee30d361'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2007(): {account: Uint8Array, call: v2007.Type_189} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '88f0b62c6e7657e08457e4e803ed3c1dac35c11596c0cba65a07e4899e15781d'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2011(): {account: Uint8Array, call: v2011.Type_190} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'bf25b67ca1fb89bf10b615ad11ee4843309b05fef24fddad7828510a2e094e6e'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2013(): {account: Uint8Array, call: v2013.Type_190} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'd9200226cdfd40cb93382510dd376c580a9b7ffd1403bf93f223bb0091eee8f2'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2015(): {account: Uint8Array, call: v2015.Type_192} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '6e14e4fa6adaf05f527c20f73439aad6c791a1482f24ec07d3cf5b1975a9980b'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2022(): {account: Uint8Array, call: v2022.Type_192} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '34af605f6825cc93878dadc2fae22265bcead67d0649c52b59288efa8a6aee27'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2023(): {account: Uint8Array, call: v2023.Type_194} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'f660e8ffd46ec0e8665326ef1caaf89d0b6846148df84db573b6ccc46773c7b2'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2024(): {account: Uint8Array, call: v2024.Type_194} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '0a1f9a64fb03ff9c41ec209a4dd79e0aa86a16a83f63d72d2f5d52d9c5ae56e9'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2025(): {account: Uint8Array, call: v2025.Type_195} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'c496f9095d7f4d6bd57e9ecd48d0c33f9dcf2d87f703e33fb87e7bb68946e317'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2026(): {account: Uint8Array, call: v2026.Type_194} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'f69d7ad7405c9cc8ce6cfad1efece3b98f79e2fb8fc2fb1ac7dbc6b35bb6e616'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2028(): {account: Uint8Array, call: v2028.Type_199} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '7e0d7639a011f12d4e67e93228fe692bd358bdea9cefad870bb041b9350b86e5'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2029(): {account: Uint8Array, call: v2029.Type_199} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '3dac29ed29be4dc7dbe018a7f93f6f4fe3d8ea57b6ac06489f69e33527a6bbbf'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV2030(): {account: Uint8Array, call: v2030.Type_138} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'b271ee7019e067d08d4f587c8847f7814dee9d0eafbca97ba6864102d80d802e'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV9010(): {account: Uint8Array, call: v9010.Type_138} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '23b78554d6d48245f0df214aa81a9975f9aae069e066c3545520033bfcc80f77'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV9030(): {account: Uint8Array, call: v9030.Type_138} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '125f8fa804535c3b40afe462b4d941ca6c196642dcc6020065c481fe83fc0b42'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV9040(): {account: Uint8Array, call: v9040.Type_138} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '5f097c89df54faa10cc050b624464e884e94704c7ccbe01a2b058e833c8696e9'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV9050(): {account: Uint8Array, call: v9050.Type_139} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'e07668f82edcd969086c0b0adf05133f596c8638471abccdc2e9400787bdb776'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV9080(): {account: Uint8Array, call: v9080.Type_138} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '3ed2e076bdae4eca611238ec3456fc96a1aea67e4fb8e16292a362fed180d30e'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV9090(): {account: Uint8Array, call: v9090.Type_138} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '1bf39001c6bd2ad6e3a23f70c60acd51fa657fcc31393713451d4e09b7f50a19'
    }

    /**
     *  Send a call through a recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you want to make a call on-behalf-of.
     *  - `call`: The call you want to make with the recovered account.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  - One storage lookup to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV9100(): {account: Uint8Array, call: v9100.Type_138} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '11145212d46868e91e208ce42807784431c7161b0c7bc0f4f0c66c4ed0045afd'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get asV9111(): {account: Uint8Array, call: v9111.Call} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'a722c25c1ff00a626f17c07e94c242ef64482795b5f45416760ac3bb95f9a7f8'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get asV9122(): {account: Uint8Array, call: v9122.Call} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '7ba3ea3d83fe4f2b67612a692d8b3836155c2ce5ae21ee40ed27d4b21ffe36ff'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get asV9130(): {account: Uint8Array, call: v9130.Call} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'e8ffe7b15dc1885d9573c07c984d475d6ede01d046afedfbc2b4d2b1c39d4d74'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get asV9160(): {account: Uint8Array, call: v9160.Call} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '15b5aa0d8ba3ca5502fbf663436d725ebf711c3d793897ed1eae649006e542c0'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get asV9170(): {account: Uint8Array, call: v9170.Call} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '56df1cbdcfb3765befdc0fbd32139581101f0c04fa6372bb1dbb6842623eac5a'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get asV9180(): {account: Uint8Array, call: v9180.Call} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'ac0e860fbfbe6b77d277444f428fcf9f778b3e738dd1f0991bf3c7289d3448d9'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     * 
     * # <weight>
     * - The weight of the `call` + 10,000.
     * - One storage lookup to check account is recovered by `who`. O(1)
     * # </weight>
     */
    get asV9190(): {account: Uint8Array, call: v9190.Call} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'd04d5620760630d3d15dae00a6f5fa4ae9e93ce231826dc7b23a19d0b2431e3b'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get asV9220(): {account: Uint8Array, call: v9220.Call} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'c3372a02b8ff4c713db3e2cf5eb8c0a85aa24ce4ec0aec3b59ae0f5d9df6827c'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get asV9230(): {account: Uint8Array, call: v9230.Call} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'fdc4d19309041d4a37ac93ad431675e618139386c6f39239bc09bea702ab5730'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get asV9250(): {account: Uint8Array, call: v9250.Call} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '236ba70c8076acb5fa44733bae5b897a52076c85d0a1534bf190f31bb1f13d95'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get asV9271(): {account: Uint8Array, call: v9271.Call} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '7b2fae2ae28553b0695b8605a1a9e4366405d2665ad36e9f503bd186489ebc84'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get asV9291(): {account: v9291.MultiAddress, call: v9291.Call} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '157777c4dd1afc374d15b667c88a39c63354740c8b2241d5c82f0e754df568c3'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get asV9300(): {account: v9300.MultiAddress, call: v9300.Call} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === '1e73afee949b394f07e7b6c2befab36d2ac45fd311ba2960b0a455a79e5d652f'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get asV9320(): {account: v9320.MultiAddress, call: v9320.Call} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'd7cb35ab69b5b975369fe879663c778cd3575189392e0cf35f4327b7f63b8546'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get asV9340(): {account: v9340.MultiAddress, call: v9340.Call} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'a5bb9bb0d2f28d1fb5a91e72f8bc26e3a2feab4715ddf3fdbebeeae87557a7e6'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get asV9350(): {account: v9350.MultiAddress, call: v9350.Call} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Recovery.as_recovered') === 'c7d7d68be70336002932c0449d58eb0cd6a0b4b796d0dceade3f951162e7fd54'
    }

    /**
     * Send a call through a recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you want to make a call on-behalf-of.
     * - `call`: The call you want to make with the recovered account.
     */
    get asV9370(): {account: v9370.MultiAddress, call: v9370.Call} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class RecoveryCancelRecoveredCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Recovery.cancel_recovered')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel the ability to use `as_recovered` for `account`.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you are able to call on-behalf-of.
     * 
     *  # <weight>
     *  - One storage mutation to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Recovery.cancel_recovered') === '7fb7672b764b0a4f0c4910fddefec0709628843df7ad0073a97eede13c53ca92'
    }

    /**
     *  Cancel the ability to use `as_recovered` for `account`.
     * 
     *  The dispatch origin for this call must be _Signed_ and registered to
     *  be able to make calls on behalf of the recovered account.
     * 
     *  Parameters:
     *  - `account`: The recovered account you are able to call on-behalf-of.
     * 
     *  # <weight>
     *  - One storage mutation to check account is recovered by `who`. O(1)
     *  # </weight>
     */
    get asV1050(): {account: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Cancel the ability to use `as_recovered` for `account`.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you are able to call on-behalf-of.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Recovery.cancel_recovered') === '2842be90a4599435dbefe83c28be9576bf64e6ff14aa9fa87c5fdb6255ef27b2'
    }

    /**
     * Cancel the ability to use `as_recovered` for `account`.
     * 
     * The dispatch origin for this call must be _Signed_ and registered to
     * be able to make calls on behalf of the recovered account.
     * 
     * Parameters:
     * - `account`: The recovered account you are able to call on-behalf-of.
     */
    get asV9291(): {account: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class RecoveryClaimRecoveryCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Recovery.claim_recovery')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Allow a successful rescuer to claim their recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and must be a "rescuer"
     *  who has successfully completed the account recovery process: collected
     *  `threshold` or more vouches, waited `delay_period` blocks since initiation.
     * 
     *  Parameters:
     *  - `account`: The lost account that you want to claim has been successfully
     *    recovered by you.
     * 
     *  # <weight>
     *  Key: F (len of friends in config), V (len of vouching friends)
     *  - One storage read to get the recovery configuration. O(1), Codec O(F)
     *  - One storage read to get the active recovery process. O(1), Codec O(V)
     *  - One storage read to get the current block number. O(1)
     *  - One storage write. O(1), Codec O(V).
     *  - One event.
     * 
     *  Total Complexity: O(F + V)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Recovery.claim_recovery') === '7fb7672b764b0a4f0c4910fddefec0709628843df7ad0073a97eede13c53ca92'
    }

    /**
     *  Allow a successful rescuer to claim their recovered account.
     * 
     *  The dispatch origin for this call must be _Signed_ and must be a "rescuer"
     *  who has successfully completed the account recovery process: collected
     *  `threshold` or more vouches, waited `delay_period` blocks since initiation.
     * 
     *  Parameters:
     *  - `account`: The lost account that you want to claim has been successfully
     *    recovered by you.
     * 
     *  # <weight>
     *  Key: F (len of friends in config), V (len of vouching friends)
     *  - One storage read to get the recovery configuration. O(1), Codec O(F)
     *  - One storage read to get the active recovery process. O(1), Codec O(V)
     *  - One storage read to get the current block number. O(1)
     *  - One storage write. O(1), Codec O(V).
     *  - One event.
     * 
     *  Total Complexity: O(F + V)
     *  # </weight>
     */
    get asV1040(): {account: Uint8Array} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Allow a successful rescuer to claim their recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and must be a "rescuer"
     * who has successfully completed the account recovery process: collected
     * `threshold` or more vouches, waited `delay_period` blocks since initiation.
     * 
     * Parameters:
     * - `account`: The lost account that you want to claim has been successfully recovered by
     *   you.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Recovery.claim_recovery') === '2842be90a4599435dbefe83c28be9576bf64e6ff14aa9fa87c5fdb6255ef27b2'
    }

    /**
     * Allow a successful rescuer to claim their recovered account.
     * 
     * The dispatch origin for this call must be _Signed_ and must be a "rescuer"
     * who has successfully completed the account recovery process: collected
     * `threshold` or more vouches, waited `delay_period` blocks since initiation.
     * 
     * Parameters:
     * - `account`: The lost account that you want to claim has been successfully recovered by
     *   you.
     */
    get asV9291(): {account: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class RecoveryCloseRecoveryCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Recovery.close_recovery')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  As the controller of a recoverable account, close an active recovery
     *  process for your account.
     * 
     *  Payment: By calling this function, the recoverable account will receive
     *  the recovery deposit `RecoveryDeposit` placed by the rescuer.
     * 
     *  The dispatch origin for this call must be _Signed_ and must be a
     *  recoverable account with an active recovery process for it.
     * 
     *  Parameters:
     *  - `rescuer`: The account trying to rescue this recoverable account.
     * 
     *  # <weight>
     *  Key: V (len of vouching friends)
     *  - One storage read/remove to get the active recovery process. O(1), Codec O(V)
     *  - One balance call to repatriate reserved. O(X)
     *  - One event.
     * 
     *  Total Complexity: O(V + X)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Recovery.close_recovery') === 'bf7ea1f5e086afbf45868ed1645503b48dc0ad2a62b98d87eb2a83cdbb2a6ef5'
    }

    /**
     *  As the controller of a recoverable account, close an active recovery
     *  process for your account.
     * 
     *  Payment: By calling this function, the recoverable account will receive
     *  the recovery deposit `RecoveryDeposit` placed by the rescuer.
     * 
     *  The dispatch origin for this call must be _Signed_ and must be a
     *  recoverable account with an active recovery process for it.
     * 
     *  Parameters:
     *  - `rescuer`: The account trying to rescue this recoverable account.
     * 
     *  # <weight>
     *  Key: V (len of vouching friends)
     *  - One storage read/remove to get the active recovery process. O(1), Codec O(V)
     *  - One balance call to repatriate reserved. O(X)
     *  - One event.
     * 
     *  Total Complexity: O(V + X)
     *  # </weight>
     */
    get asV1040(): {rescuer: Uint8Array} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     * As the controller of a recoverable account, close an active recovery
     * process for your account.
     * 
     * Payment: By calling this function, the recoverable account will receive
     * the recovery deposit `RecoveryDeposit` placed by the rescuer.
     * 
     * The dispatch origin for this call must be _Signed_ and must be a
     * recoverable account with an active recovery process for it.
     * 
     * Parameters:
     * - `rescuer`: The account trying to rescue this recoverable account.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Recovery.close_recovery') === '35641276d420e314bee73916596f9c923b0832cf84b0886fff164a0c199992c3'
    }

    /**
     * As the controller of a recoverable account, close an active recovery
     * process for your account.
     * 
     * Payment: By calling this function, the recoverable account will receive
     * the recovery deposit `RecoveryDeposit` placed by the rescuer.
     * 
     * The dispatch origin for this call must be _Signed_ and must be a
     * recoverable account with an active recovery process for it.
     * 
     * Parameters:
     * - `rescuer`: The account trying to rescue this recoverable account.
     */
    get asV9291(): {rescuer: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class RecoveryCreateRecoveryCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Recovery.create_recovery')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Create a recovery configuration for your account. This makes your account recoverable.
     * 
     *  Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance
     *  will be reserved for storing the recovery configuration. This deposit is returned
     *  in full when the user calls `remove_recovery`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `friends`: A list of friends you trust to vouch for recovery attempts.
     *    Should be ordered and contain no duplicate values.
     *  - `threshold`: The number of friends that must vouch for a recovery attempt
     *    before the account can be recovered. Should be less than or equal to
     *    the length of the list of friends.
     *  - `delay_period`: The number of blocks after a recovery attempt is initialized
     *    that needs to pass before the account can be recovered.
     * 
     *  # <weight>
     *  - Key: F (len of friends)
     *  - One storage read to check that account is not already recoverable. O(1).
     *  - A check that the friends list is sorted and unique. O(F)
     *  - One currency reserve operation. O(X)
     *  - One storage write. O(1). Codec O(F).
     *  - One event.
     * 
     *  Total Complexity: O(F + X)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Recovery.create_recovery') === 'f15707f38a1f989e268042b9a0fb39bc5c323ba5ea517caa023a5dec5966feb6'
    }

    /**
     *  Create a recovery configuration for your account. This makes your account recoverable.
     * 
     *  Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance
     *  will be reserved for storing the recovery configuration. This deposit is returned
     *  in full when the user calls `remove_recovery`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `friends`: A list of friends you trust to vouch for recovery attempts.
     *    Should be ordered and contain no duplicate values.
     *  - `threshold`: The number of friends that must vouch for a recovery attempt
     *    before the account can be recovered. Should be less than or equal to
     *    the length of the list of friends.
     *  - `delay_period`: The number of blocks after a recovery attempt is initialized
     *    that needs to pass before the account can be recovered.
     * 
     *  # <weight>
     *  - Key: F (len of friends)
     *  - One storage read to check that account is not already recoverable. O(1).
     *  - A check that the friends list is sorted and unique. O(F)
     *  - One currency reserve operation. O(X)
     *  - One storage write. O(1). Codec O(F).
     *  - One event.
     * 
     *  Total Complexity: O(F + X)
     *  # </weight>
     */
    get asV1040(): {friends: Uint8Array[], threshold: number, delayPeriod: number} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }
}

export class RecoveryInitiateRecoveryCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Recovery.initiate_recovery')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Initiate the process for recovering a recoverable account.
     * 
     *  Payment: `RecoveryDeposit` balance will be reserved for initiating the
     *  recovery process. This deposit will always be repatriated to the account
     *  trying to be recovered. See `close_recovery`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `account`: The lost account that you want to recover. This account
     *    needs to be recoverable (i.e. have a recovery configuration).
     * 
     *  # <weight>
     *  - One storage read to check that account is recoverable. O(F)
     *  - One storage read to check that this recovery process hasn't already started. O(1)
     *  - One currency reserve operation. O(X)
     *  - One storage read to get the current block number. O(1)
     *  - One storage write. O(1).
     *  - One event.
     * 
     *  Total Complexity: O(F + X)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Recovery.initiate_recovery') === '7fb7672b764b0a4f0c4910fddefec0709628843df7ad0073a97eede13c53ca92'
    }

    /**
     *  Initiate the process for recovering a recoverable account.
     * 
     *  Payment: `RecoveryDeposit` balance will be reserved for initiating the
     *  recovery process. This deposit will always be repatriated to the account
     *  trying to be recovered. See `close_recovery`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `account`: The lost account that you want to recover. This account
     *    needs to be recoverable (i.e. have a recovery configuration).
     * 
     *  # <weight>
     *  - One storage read to check that account is recoverable. O(F)
     *  - One storage read to check that this recovery process hasn't already started. O(1)
     *  - One currency reserve operation. O(X)
     *  - One storage read to get the current block number. O(1)
     *  - One storage write. O(1).
     *  - One event.
     * 
     *  Total Complexity: O(F + X)
     *  # </weight>
     */
    get asV1040(): {account: Uint8Array} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Initiate the process for recovering a recoverable account.
     * 
     * Payment: `RecoveryDeposit` balance will be reserved for initiating the
     * recovery process. This deposit will always be repatriated to the account
     * trying to be recovered. See `close_recovery`.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `account`: The lost account that you want to recover. This account needs to be
     *   recoverable (i.e. have a recovery configuration).
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Recovery.initiate_recovery') === '2842be90a4599435dbefe83c28be9576bf64e6ff14aa9fa87c5fdb6255ef27b2'
    }

    /**
     * Initiate the process for recovering a recoverable account.
     * 
     * Payment: `RecoveryDeposit` balance will be reserved for initiating the
     * recovery process. This deposit will always be repatriated to the account
     * trying to be recovered. See `close_recovery`.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Parameters:
     * - `account`: The lost account that you want to recover. This account needs to be
     *   recoverable (i.e. have a recovery configuration).
     */
    get asV9291(): {account: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class RecoveryRemoveRecoveryCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Recovery.remove_recovery')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove the recovery process for your account.
     * 
     *  NOTE: The user must make sure to call `close_recovery` on all active
     *  recovery attempts before calling this function else it will fail.
     * 
     *  Payment: By calling this function the recoverable account will unreserve
     *  their recovery configuration deposit.
     *  (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)
     * 
     *  The dispatch origin for this call must be _Signed_ and must be a
     *  recoverable account (i.e. has a recovery configuration).
     * 
     *  # <weight>
     *  Key: F (len of friends)
     *  - One storage read to get the prefix iterator for active recoveries. O(1)
     *  - One storage read/remove to get the recovery configuration. O(1), Codec O(F)
     *  - One balance call to unreserved. O(X)
     *  - One event.
     * 
     *  Total Complexity: O(F + X)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Recovery.remove_recovery') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Remove the recovery process for your account.
     * 
     *  NOTE: The user must make sure to call `close_recovery` on all active
     *  recovery attempts before calling this function else it will fail.
     * 
     *  Payment: By calling this function the recoverable account will unreserve
     *  their recovery configuration deposit.
     *  (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)
     * 
     *  The dispatch origin for this call must be _Signed_ and must be a
     *  recoverable account (i.e. has a recovery configuration).
     * 
     *  # <weight>
     *  Key: F (len of friends)
     *  - One storage read to get the prefix iterator for active recoveries. O(1)
     *  - One storage read/remove to get the recovery configuration. O(1), Codec O(F)
     *  - One balance call to unreserved. O(X)
     *  - One event.
     * 
     *  Total Complexity: O(F + X)
     *  # </weight>
     */
    get asV1040(): null {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }
}

export class RecoverySetRecoveredCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Recovery.set_recovered')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Allow ROOT to bypass the recovery process and set an a rescuer account
     *  for a lost account directly.
     * 
     *  The dispatch origin for this call must be _ROOT_.
     * 
     *  Parameters:
     *  - `lost`: The "lost account" to be recovered.
     *  - `rescuer`: The "rescuer account" which can call as the lost account.
     * 
     *  # <weight>
     *  - One storage write O(1)
     *  - One event
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Recovery.set_recovered') === 'e31e64948b0477d6c231238f14482bc8fb02052d698dcb08eac8e46cb8abdf6c'
    }

    /**
     *  Allow ROOT to bypass the recovery process and set an a rescuer account
     *  for a lost account directly.
     * 
     *  The dispatch origin for this call must be _ROOT_.
     * 
     *  Parameters:
     *  - `lost`: The "lost account" to be recovered.
     *  - `rescuer`: The "rescuer account" which can call as the lost account.
     * 
     *  # <weight>
     *  - One storage write O(1)
     *  - One event
     *  # </weight>
     */
    get asV1040(): {lost: Uint8Array, rescuer: Uint8Array} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Allow ROOT to bypass the recovery process and set an a rescuer account
     * for a lost account directly.
     * 
     * The dispatch origin for this call must be _ROOT_.
     * 
     * Parameters:
     * - `lost`: The "lost account" to be recovered.
     * - `rescuer`: The "rescuer account" which can call as the lost account.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Recovery.set_recovered') === '12dcb73249a3bef1953d8d44b54c11a2420fd3d13f55159e3173b5d3dee3de90'
    }

    /**
     * Allow ROOT to bypass the recovery process and set an a rescuer account
     * for a lost account directly.
     * 
     * The dispatch origin for this call must be _ROOT_.
     * 
     * Parameters:
     * - `lost`: The "lost account" to be recovered.
     * - `rescuer`: The "rescuer account" which can call as the lost account.
     */
    get asV9291(): {lost: v9291.MultiAddress, rescuer: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class RecoveryVouchRecoveryCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Recovery.vouch_recovery')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Allow a "friend" of a recoverable account to vouch for an active recovery
     *  process for that account.
     * 
     *  The dispatch origin for this call must be _Signed_ and must be a "friend"
     *  for the recoverable account.
     * 
     *  Parameters:
     *  - `lost`: The lost account that you want to recover.
     *  - `rescuer`: The account trying to rescue the lost account that you
     *    want to vouch for.
     * 
     *  The combination of these two parameters must point to an active recovery
     *  process.
     * 
     *  # <weight>
     *  Key: F (len of friends in config), V (len of vouching friends)
     *  - One storage read to get the recovery configuration. O(1), Codec O(F)
     *  - One storage read to get the active recovery process. O(1), Codec O(V)
     *  - One binary search to confirm caller is a friend. O(logF)
     *  - One binary search to confirm caller has not already vouched. O(logV)
     *  - One storage write. O(1), Codec O(V).
     *  - One event.
     * 
     *  Total Complexity: O(F + logF + V + logV)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Recovery.vouch_recovery') === 'e31e64948b0477d6c231238f14482bc8fb02052d698dcb08eac8e46cb8abdf6c'
    }

    /**
     *  Allow a "friend" of a recoverable account to vouch for an active recovery
     *  process for that account.
     * 
     *  The dispatch origin for this call must be _Signed_ and must be a "friend"
     *  for the recoverable account.
     * 
     *  Parameters:
     *  - `lost`: The lost account that you want to recover.
     *  - `rescuer`: The account trying to rescue the lost account that you
     *    want to vouch for.
     * 
     *  The combination of these two parameters must point to an active recovery
     *  process.
     * 
     *  # <weight>
     *  Key: F (len of friends in config), V (len of vouching friends)
     *  - One storage read to get the recovery configuration. O(1), Codec O(F)
     *  - One storage read to get the active recovery process. O(1), Codec O(V)
     *  - One binary search to confirm caller is a friend. O(logF)
     *  - One binary search to confirm caller has not already vouched. O(logV)
     *  - One storage write. O(1), Codec O(V).
     *  - One event.
     * 
     *  Total Complexity: O(F + logF + V + logV)
     *  # </weight>
     */
    get asV1040(): {lost: Uint8Array, rescuer: Uint8Array} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Allow a "friend" of a recoverable account to vouch for an active recovery
     * process for that account.
     * 
     * The dispatch origin for this call must be _Signed_ and must be a "friend"
     * for the recoverable account.
     * 
     * Parameters:
     * - `lost`: The lost account that you want to recover.
     * - `rescuer`: The account trying to rescue the lost account that you want to vouch for.
     * 
     * The combination of these two parameters must point to an active recovery
     * process.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Recovery.vouch_recovery') === '12dcb73249a3bef1953d8d44b54c11a2420fd3d13f55159e3173b5d3dee3de90'
    }

    /**
     * Allow a "friend" of a recoverable account to vouch for an active recovery
     * process for that account.
     * 
     * The dispatch origin for this call must be _Signed_ and must be a "friend"
     * for the recoverable account.
     * 
     * Parameters:
     * - `lost`: The lost account that you want to recover.
     * - `rescuer`: The account trying to rescue the lost account that you want to vouch for.
     * 
     * The combination of these two parameters must point to an active recovery
     * process.
     */
    get asV9291(): {lost: v9291.MultiAddress, rescuer: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaCancelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.cancel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel an ongoing referendum.
     * 
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Cancelled`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Referenda.cancel') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Cancel an ongoing referendum.
     * 
     * - `origin`: must be the `CancelOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Cancelled`.
     */
    get asV9320(): {index: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaKillCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.kill')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Cancel an ongoing referendum and slash the deposits.
     * 
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Killed` and `DepositSlashed`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Referenda.kill') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Cancel an ongoing referendum and slash the deposits.
     * 
     * - `origin`: must be the `KillOrigin`.
     * - `index`: The index of the referendum to be cancelled.
     * 
     * Emits `Killed` and `DepositSlashed`.
     */
    get asV9320(): {index: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaNudgeReferendumCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.nudge_referendum')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Referenda.nudge_referendum') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Advance a referendum onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `index`: the referendum to be advanced.
     */
    get asV9320(): {index: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaOneFewerDecidingCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.one_fewer_deciding')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Advance a track onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     * 
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Referenda.one_fewer_deciding') === '75d849d1c0275ad91cee68e888f612b619530fe1a9f1955df3cd6d91e4d4ed1d'
    }

    /**
     * Advance a track onto its next logical state. Only used internally.
     * 
     * - `origin`: must be `Root`.
     * - `track`: the track to be advanced.
     * 
     * Action item for when there is now one fewer referendum in the deciding phase and the
     * `DecidingCount` is not yet updated. This means that we should either:
     * - begin deciding another referendum (and leave `DecidingCount` alone); or
     * - decrement `DecidingCount`.
     */
    get asV9320(): {track: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaPlaceDecisionDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.place_decision_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Post the Decision Deposit for a referendum.
     * 
     * - `origin`: must be `Signed` and the account must have funds available for the
     *   referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     *   posted.
     * 
     * Emits `DecisionDepositPlaced`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Referenda.place_decision_deposit') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Post the Decision Deposit for a referendum.
     * 
     * - `origin`: must be `Signed` and the account must have funds available for the
     *   referendum's track's Decision Deposit.
     * - `index`: The index of the submitted referendum whose Decision Deposit is yet to be
     *   posted.
     * 
     * Emits `DecisionDepositPlaced`.
     */
    get asV9320(): {index: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaRefundDecisionDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.refund_decision_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     *   refunded.
     * 
     * Emits `DecisionDepositRefunded`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Referenda.refund_decision_deposit') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Refund the Decision Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Decision Deposit has not yet been
     *   refunded.
     * 
     * Emits `DecisionDepositRefunded`.
     */
    get asV9320(): {index: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaRefundSubmissionDepositCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.refund_submission_deposit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     *   refunded.
     * 
     * Emits `SubmissionDepositRefunded`.
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Referenda.refund_submission_deposit') === '25a99cc820e15400356f62165725d9d84847d859e62ca1e5fd6eb340dc5c217e'
    }

    /**
     * Refund the Submission Deposit for a closed referendum back to the depositor.
     * 
     * - `origin`: must be `Signed` or `Root`.
     * - `index`: The index of a closed referendum whose Submission Deposit has not yet been
     *   refunded.
     * 
     * Emits `SubmissionDepositRefunded`.
     */
    get asV9350(): {index: number} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }
}

export class ReferendaSubmitCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Referenda.submit')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Referenda.submit') === '6973d34a693667744def0a5715cbdd4f9e5f021d58a5384675436ddb19fbb30d'
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get asV9320(): {proposalOrigin: v9320.OriginCaller, proposal: v9320.Bounded, enactmentMoment: v9320.DispatchTime} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Referenda.submit') === '864072fcea84d418733365bbf1c6b2afb718972174993b29cfec79274651ab29'
    }

    /**
     * Propose a referendum on a privileged action.
     * 
     * - `origin`: must be `SubmitOrigin` and the account must have `SubmissionDeposit` funds
     *   available.
     * - `proposal_origin`: The origin from which the proposal should be executed.
     * - `proposal`: The proposal.
     * - `enactment_moment`: The moment that the proposal should be enacted.
     * 
     * Emits `Submitted`.
     */
    get asV9370(): {proposalOrigin: v9370.OriginCaller, proposal: v9370.Bounded, enactmentMoment: v9370.DispatchTime} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarAddLockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.add_lock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Add a manager lock from a para. This will prevent the manager of a
     * para to deregister or swap a para.
     * 
     * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Registrar.add_lock') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     * Add a manager lock from a para. This will prevent the manager of a
     * para to deregister or swap a para.
     * 
     * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
     */
    get asV9320(): {para: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarDeregisterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.deregister')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Deregister a Para Id, freeing all data and returning any deposit.
     * 
     *  The caller must be Root, the `para` owner, or the `para` itself. The para must be a parathread.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Registrar.deregister') === '0fb20b5afc6a2830162f8daea8abc92a50d6411d977d5e83e205bdeb2dcd6598'
    }

    /**
     *  Deregister a Para Id, freeing all data and returning any deposit.
     * 
     *  The caller must be Root, the `para` owner, or the `para` itself. The para must be a parathread.
     */
    get asV9010(): {id: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarDeregisterParaCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.deregister_para')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Deregister a parachain with given id
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Registrar.deregister_para') === '49bd869aaca66b3b67b16fd6a8ea65fd03e8898dcc62afb378e07fcfd945201c'
    }

    /**
     *  Deregister a parachain with given id
     */
    get asV1020(): {id: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarDeregisterParathreadCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.deregister_parathread')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Deregister a parathread and retrieve the deposit.
     * 
     *  Must be sent from a `Parachain` origin which is currently a parathread.
     * 
     *  Ensure that before calling this that any funds you want emptied from the parathread's
     *  account is moved out; after this it will be impossible to retrieve them (without
     *  governance intervention).
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Registrar.deregister_parathread') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Deregister a parathread and retrieve the deposit.
     * 
     *  Must be sent from a `Parachain` origin which is currently a parathread.
     * 
     *  Ensure that before calling this that any funds you want emptied from the parathread's
     *  account is moved out; after this it will be impossible to retrieve them (without
     *  governance intervention).
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarForceRegisterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.force_register')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force the registration of a Para Id on the relay chain.
     * 
     *  This function must be called by a Root origin.
     * 
     *  The deposit taken can be specified for this registration. Any ParaId
     *  can be registered, including sub-1000 IDs which are System Parachains.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Registrar.force_register') === 'a5b6a45ddb0597c424abb7f3f416971b6f9078847fb58371773188cc269b135b'
    }

    /**
     *  Force the registration of a Para Id on the relay chain.
     * 
     *  This function must be called by a Root origin.
     * 
     *  The deposit taken can be specified for this registration. Any ParaId
     *  can be registered, including sub-1000 IDs which are System Parachains.
     */
    get asV9010(): {who: Uint8Array, deposit: bigint, id: number, genesisHead: Uint8Array, validationCode: Uint8Array} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarForceRemoveLockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.force_remove_lock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a manager lock from a para. This will allow the manager of a
     *  previously locked para to deregister or swap a para without using governance.
     * 
     *  Can only be called by the Root origin.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Registrar.force_remove_lock') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     *  Remove a manager lock from a para. This will allow the manager of a
     *  previously locked para to deregister or swap a para without using governance.
     * 
     *  Can only be called by the Root origin.
     */
    get asV9010(): {para: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarRegisterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.register')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register head data and validation code for a reserved Para Id.
     * 
     *  ## Arguments
     *  - `origin`: Must be called by a `Signed` origin.
     *  - `id`: The para ID. Must be owned/managed by the `origin` signing account.
     *  - `genesis_head`: The genesis head data of the parachain/thread.
     *  - `validation_code`: The initial validation code of the parachain/thread.
     * 
     *  ## Deposits/Fees
     *  The origin signed account must reserve a corresponding deposit for the registration. Anything already
     *  reserved previously for this para ID is accounted for.
     * 
     *  ## Events
     *  The `Registered` event is emitted in case of success.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Registrar.register') === '3a4cf817f8bb406cb7985618b2fb45aaf0a9fffe415f2a1be091d56bb241889b'
    }

    /**
     *  Register head data and validation code for a reserved Para Id.
     * 
     *  ## Arguments
     *  - `origin`: Must be called by a `Signed` origin.
     *  - `id`: The para ID. Must be owned/managed by the `origin` signing account.
     *  - `genesis_head`: The genesis head data of the parachain/thread.
     *  - `validation_code`: The initial validation code of the parachain/thread.
     * 
     *  ## Deposits/Fees
     *  The origin signed account must reserve a corresponding deposit for the registration. Anything already
     *  reserved previously for this para ID is accounted for.
     * 
     *  ## Events
     *  The `Registered` event is emitted in case of success.
     */
    get asV9010(): {id: number, genesisHead: Uint8Array, validationCode: Uint8Array} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarRegisterParaCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.register_para')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register a parachain with given code.
     *  Fails if given ID is already used.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Registrar.register_para') === '9c09e7470bc9ca43a5dea1f87539ab900dbaab966ca48317470d798d4a46a872'
    }

    /**
     *  Register a parachain with given code.
     *  Fails if given ID is already used.
     */
    get asV1020(): {id: number, info: v1020.ParaInfo, code: Uint8Array, initialHeadData: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarRegisterParathreadCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.register_parathread')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register a parathread for immediate use.
     * 
     *  Must be sent from a Signed origin that is able to have ParathreadDeposit reserved.
     *  `code` and `initial_head_data` are used to initialize the parathread's state.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Registrar.register_parathread') === '854b863227772f14ca08776e2c60f53410480f47c5380ee5045dae1002484bad'
    }

    /**
     *  Register a parathread for immediate use.
     * 
     *  Must be sent from a Signed origin that is able to have ParathreadDeposit reserved.
     *  `code` and `initial_head_data` are used to initialize the parathread's state.
     */
    get asV1020(): {code: Uint8Array, initialHeadData: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarRemoveLockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.remove_lock')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Remove a manager lock from a para. This will allow the manager of a
     * previously locked para to deregister or swap a para without using governance.
     * 
     * Can only be called by the Root origin or the parachain.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Registrar.remove_lock') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     * Remove a manager lock from a para. This will allow the manager of a
     * previously locked para to deregister or swap a para without using governance.
     * 
     * Can only be called by the Root origin or the parachain.
     */
    get asV9320(): {para: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarReserveCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.reserve')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Reserve a Para Id on the relay chain.
     * 
     *  This function will reserve a new Para Id to be owned/managed by the origin account.
     *  The origin account is able to register head data and validation code using `register` to create
     *  a parathread. Using the Slots pallet, a parathread can then be upgraded to get a parachain slot.
     * 
     *  ## Arguments
     *  - `origin`: Must be called by a `Signed` origin. Becomes the manager/owner of the new para ID.
     * 
     *  ## Deposits/Fees
     *  The origin must reserve a deposit of `ParaDeposit` for the registration.
     * 
     *  ## Events
     *  The `Reserved` event is emitted in case of success, which provides the ID reserved for use.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Registrar.reserve') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Reserve a Para Id on the relay chain.
     * 
     *  This function will reserve a new Para Id to be owned/managed by the origin account.
     *  The origin account is able to register head data and validation code using `register` to create
     *  a parathread. Using the Slots pallet, a parathread can then be upgraded to get a parachain slot.
     * 
     *  ## Arguments
     *  - `origin`: Must be called by a `Signed` origin. Becomes the manager/owner of the new para ID.
     * 
     *  ## Deposits/Fees
     *  The origin must reserve a deposit of `ParaDeposit` for the registration.
     * 
     *  ## Events
     *  The `Reserved` event is emitted in case of success, which provides the ID reserved for use.
     */
    get asV9010(): null {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarScheduleCodeUpgradeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.schedule_code_upgrade')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Schedule a parachain upgrade.
     * 
     * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Registrar.schedule_code_upgrade') === '0b5bbf1b361dddb4826c2c1c0065a52b490f97f282bfc036e9cfc8d1934f8139'
    }

    /**
     * Schedule a parachain upgrade.
     * 
     * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
     */
    get asV9320(): {para: number, newCode: Uint8Array} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarSelectParathreadCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.select_parathread')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Place a bid for a parathread to be progressed in the next block.
     * 
     *  This is a kind of special transaction that should by heavily prioritized in the
     *  transaction pool according to the `value`; only `ThreadCount` of them may be presented
     *  in any single block.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Registrar.select_parathread') === 'df280635aada7e2d475a114b84199ed40b324a34b3bf8f73bc19293879d825ed'
    }

    /**
     *  Place a bid for a parathread to be progressed in the next block.
     * 
     *  This is a kind of special transaction that should by heavily prioritized in the
     *  transaction pool according to the `value`; only `ThreadCount` of them may be presented
     *  in any single block.
     */
    get asV1020(): {id: number, collator: Uint8Array, headHash: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarSetCurrentHeadCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.set_current_head')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set the parachain's current head.
     * 
     * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Registrar.set_current_head') === '630e70696dbb809d3a272dfc9da9bfd0656f82541be24c57ee1c634d2645017c'
    }

    /**
     * Set the parachain's current head.
     * 
     * Can be called by Root, the parachain, or the parachain manager if the parachain is unlocked.
     */
    get asV9320(): {para: number, newHead: Uint8Array} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarSetThreadCountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.set_thread_count')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Reset the number of parathreads that can pay to be scheduled in a single block.
     * 
     *  - `count`: The number of parathreads.
     * 
     *  Must be called from Root origin.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Registrar.set_thread_count') === '1cdbdc8ac203922f95ae6ab3e8b98004e956389f7ec11480ec5633d29b48cf71'
    }

    /**
     *  Reset the number of parathreads that can pay to be scheduled in a single block.
     * 
     *  - `count`: The number of parathreads.
     * 
     *  Must be called from Root origin.
     */
    get asV1020(): {count: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class RegistrarSwapCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Registrar.swap')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Swap a parachain with another parachain or parathread. The origin must be a `Parachain`.
     *  The swap will happen only if there is already an opposite swap pending. If there is not,
     *  the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
     * 
     *  The `ParaId`s remain mapped to the same head data and code so external code can rely on
     *  `ParaId` to be a long-term identifier of a notional "parachain". However, their
     *  scheduling info (i.e. whether they're a parathread or parachain), auction information
     *  and the auction deposit are switched.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Registrar.swap') === '6b0ee98f761c4740fd9a12ee09427e5d960aa8315667eaa445899c2b5bbd59d1'
    }

    /**
     *  Swap a parachain with another parachain or parathread. The origin must be a `Parachain`.
     *  The swap will happen only if there is already an opposite swap pending. If there is not,
     *  the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
     * 
     *  The `ParaId`s remain mapped to the same head data and code so external code can rely on
     *  `ParaId` to be a long-term identifier of a notional "parachain". However, their
     *  scheduling info (i.e. whether they're a parathread or parachain), auction information
     *  and the auction deposit are switched.
     */
    get asV1020(): {other: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Swap a parachain with another parachain or parathread.
     * 
     *  The origin must be Root, the `para` owner, or the `para` itself.
     * 
     *  The swap will happen only if there is already an opposite swap pending. If there is not,
     *  the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
     * 
     *  The `ParaId`s remain mapped to the same head data and code so external code can rely on
     *  `ParaId` to be a long-term identifier of a notional "parachain". However, their
     *  scheduling info (i.e. whether they're a parathread or parachain), auction information
     *  and the auction deposit are switched.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Registrar.swap') === '6feebc54e6390627dc0adcf3db1cd4a5b837a30257a2bb93cd4268cad6b4957e'
    }

    /**
     *  Swap a parachain with another parachain or parathread.
     * 
     *  The origin must be Root, the `para` owner, or the `para` itself.
     * 
     *  The swap will happen only if there is already an opposite swap pending. If there is not,
     *  the swap will be stored in the pending swaps map, ready for a later confirmatory swap.
     * 
     *  The `ParaId`s remain mapped to the same head data and code so external code can rely on
     *  `ParaId` to be a long-term identifier of a notional "parachain". However, their
     *  scheduling info (i.e. whether they're a parathread or parachain), auction information
     *  and the auction deposit are switched.
     */
    get asV9010(): {id: number, other: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerCancelCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.cancel')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel an anonymously scheduled task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.15 + 2.869 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 100 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Scheduler.cancel') === '4186e24556a58b04e04d6d697a530eedf78f255da1ba9d84df6511dd6d6465f7'
    }

    /**
     *  Cancel an anonymously scheduled task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.15 + 2.869 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 100 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2005(): {when: number, index: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerCancelNamedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.cancel_named')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel a named scheduled task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 24.91 + 2.907 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 100 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Scheduler.cancel_named') === 'a0b847240e1232c10a62578340a2af6708e760669b06344b70c15e6370b514cf'
    }

    /**
     *  Cancel a named scheduled task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 24.91 + 2.907 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 100 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2005(): {id: Uint8Array} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Cancel a named scheduled task.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Scheduler.cancel_named') === '2a01c4c05d6bf45e0dc267bd7f6e27df3b3e4b23af7982734357c4de87ef690c'
    }

    /**
     * Cancel a named scheduled task.
     */
    get asV9320(): {id: Uint8Array} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerScheduleCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.schedule')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '39b57719a45916c50a9c3571621710808496c53f71c1b5be02a74d2fbfd07574'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2005(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2005.Type_188} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '0dfeee6e32ff07316e9ce26e9b3402228ca4d8345b4cfd67d9c1039dd46a45bb'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2007(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2007.Type_189} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'a2b58b261508b1965a2fc20bfab29a2af2e7e2d36e8b32ebdcc893850e293cc4'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2011(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2011.Type_190} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'a1f2541b9b5db93a04734c9a54ffd9a75498b3016d599bf3825f72a0a26fbe98'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2013(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2013.Type_190} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '93ddd58e2c100558ecdcf716c60502c299dba7ecd7bed257d7f728c4c4bf4fa7'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2015(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2015.Type_192} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '119dccba20a2cad741150b5daaf2ce5954f90081331db1c9ea50307f98b2b89d'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2022(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2022.Type_192} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '0a8338d4c67e205a02ba1a478fab45381e6869c6300b6f7bcb7d79fb02c14f17'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2023(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2023.Type_194} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '719d2d820a799591ff41fe0e03f135743dce576ebf816766e0daf504b6802203'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2024(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2024.Type_194} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'b91f5ab7149e84ad999465a5afe4a4b6c21f259fe435ddd2e0323ba03cd4bc76'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2025(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2025.Type_195} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '6cfd9096d3df127c355f27fe7adb8c780774e0145934129dab358f0119938b95'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2026(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2026.Type_194} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'e4df50d6fda20d6faf9f3887187971b6e49f1f1e2933511c368dad51b6ab5b61'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2028(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2028.Type_199} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '74f0c70827bbc4b2f4a8012dd205f93d3a89340631023b2d4001c921cfa4198e'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2029(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2029.Type_199} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '0e3713ed0b2137f0e0a2b85ed7bdafe58f6b7aa357092c85a8b4f2f5ee1dd1f5'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV2030(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2030.Type_138} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '218eee953c68fb94b1c99446e1f796799a2b68eaa368bbdb08205db9f40a90bc'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV9010(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9010.Type_138} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '00c94ebb8023a96af020b95d2955ad6eed160bf32b6a09849580563ab45c6046'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV9030(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9030.Type_138} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '103329b3e41f51a3e7d6c4d05d861f01282b66a329a5eff502fd5acb82231634'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV9040(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9040.Type_138} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'eefea5c2e6a9c5d50260caf1a75055516d1007c8d9eedd7b61b674f36f354d6a'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV9050(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9050.Type_139} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '9fd004ac9c4023f20cbb68a42be1da9ad9cef2a955d46ae960a7f57235d139fb'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV9080(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9080.Type_138} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '73dad6b94afd48524fcd55bd8d968815a30ba8d46d492e3c4f709e65e5cfd893'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV9090(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9090.Type_138} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'a608ef64469338406565235ec5b53b62d9dbb5a4e04dc67000a425eef02b9442'
    }

    /**
     *  Anonymously schedule a task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 22.29 + .126 * S µs
     *  - DB Weight:
     *      - Read: Agenda
     *      - Write: Agenda
     *  - Will use base weight of 25 which should be good for up to 30 scheduled calls
     *  # </weight>
     */
    get asV9100(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9100.Type_138} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '30ef397367068b96653e1b9acea881185d2d87a5f70a17c0d272da1a4fb210c3'
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get asV9111(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9111.Call} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'f5ebb5f179e9a64f57eec93cfe2fcca90a24521c1f5d733bca10358d13b650b9'
    }

    /**
     * Anonymously schedule a task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 22.29 + .126 * S µs
     * - DB Weight:
     *     - Read: Agenda
     *     - Write: Agenda
     * - Will use base weight of 25 which should be good for up to 30 scheduled calls
     * # </weight>
     */
    get asV9122(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9122.Call} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '9e81147d322c66fec97a7bc1a8db6da48273f234e04890fefd63155dae7b691c'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9130(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9130.Call} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'c836bc1402045274a3b2ba649de73c66056a5a757709f51b28f36de849b0a087'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9160(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9160.MaybeHashed} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '36c3d764a89316a0ccee3cf835d4f54b8be2b41455774560a2c61debf31fd1da'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9170(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9170.MaybeHashed} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '57cf0d6660a78f96a58ee029a4efb7f1f4e733e61b9fa5b525ca4a6cd2cec77b'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9180(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9180.MaybeHashed} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '7d048199baf4410cbd96cac0d05f7dd99fbd96e14cc87f1b62f30ef4fc1648e4'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9190(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9190.MaybeHashed} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '54ba523f430cf853c1eaf0bb3a17b6d9d4fcbaf536773b859891deee52dcecd9'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9220(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9220.MaybeHashed} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '381b9fba7c5c82ca299ad826d905f18240ca1e38bc6ce381250a52f934488260'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9230(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9230.MaybeHashed} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '2f42dca3cdffe40bca1e17527f787cbb6b4dbbb682657c8db07ad379fbbbf094'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9250(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9250.MaybeHashed} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'ce11ac20a6888a8d2ad2f50e61a6a5e81d6c2241408cf9a9accddeb7577fc88e'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9271(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9271.MaybeHashed} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '4e8a1b807ac59bcbbe25872ed93b3ce2cd7fffca391c6dce3e7087376d4445bf'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9291(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9291.MaybeHashed} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'abe25ff0c03ac6c91716278c7e6c28feeecb8d2dafe46f40072626c338a96cc5'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9300(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9300.MaybeHashed} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'ebb3ce4ec4440dc90f85688d390aefc5c2e5738e48cc2a582be64837d21131c3'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9320(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9320.Call} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '3dbc5c183bfd3f4bf318c6616278ae2d5bddbe668a9bd2f9e4ad13f521057891'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9340(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9340.Call} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === '60948f0579a117d39bd77372c0cda3ecf4e08c6043e64a847dac0ed19a6c71d3'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9350(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9350.Call} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Scheduler.schedule') === 'ea2dae94faf5f1a34da1df670b9e650c7f1683093a6aa33b17a6e6416c067fc4'
    }

    /**
     * Anonymously schedule a task.
     */
    get asV9370(): {when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9370.Call} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerScheduleAfterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.schedule_after')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '0270fd3aabc555de47501fff741bd7d892a496c52fd27e3d091f1d379ec28995'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV2015(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2015.Type_192} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '455bfd5256b55c0ea1dbfb3018343d6fcec2a311b27ed635b811ec94d2864f30'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV2022(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2022.Type_192} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '194e877d6d3edeefa6bbede038972228930fa6b7e233e07d5a84654cfca8f065'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV2023(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2023.Type_194} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '025d41d49944bffd2cc5ef6252a67ac48e03469a8728f7dec657433683b2369f'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV2024(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2024.Type_194} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '16f27c0aa3d4450b5e8738c1144c075bc1fb5084b4393654aef2d79e13f54854'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV2025(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2025.Type_195} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'fd8ce66b94efd7548686df9516f9de9218c504a298743d240040f299d49007cb'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV2026(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2026.Type_194} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '33265937895d0322fc9fa903ab14d8bf3b7048f96d47cb590dcefaac10332b3f'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV2028(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2028.Type_199} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '408d03bab2d378ae9b60c32ef0cc4dc7addf1af8e018365eecc985b21b6cbadb'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV2029(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2029.Type_199} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '236e64a3cf1a5f47234710ca5469830b49706003f797c7738613dc27038b76d1'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV2030(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2030.Type_138} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'fe91eb0a4a6de2c22ba40e2b0f712cc0e656e1eeb8ebecf31b0465976a95f6a6'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV9010(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9010.Type_138} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '84b5b6292c416f03b1e238988ed342e9ab5af0e95a0a32f9b67a3ce9791073d9'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV9030(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9030.Type_138} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '3b9f7ed85cbe77489c0ec222e402aae7f007ba4a31c48bf8c37e982d34185992'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV9040(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9040.Type_138} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '09123e654d5eaa3dbfb86d88001d6e9be24735b32f721d0ec39cdf9b771a607a'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV9050(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9050.Type_139} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '1b0f95a679fdfa4477bb33cf44e42d6323e942064071d351778f8d1c5754696d'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV9080(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9080.Type_138} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'f314f83465114b332b79ed2428ee40ba182252640843ea95cbb7e258ce55ba95'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV9090(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9090.Type_138} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '43ecf2d68d16dfd550c4fe85395cad1c55f090dc9c94875ee45c4cebd3b77f1a'
    }

    /**
     *  Anonymously schedule a task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule`].
     *  # </weight>
     */
    get asV9100(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9100.Type_138} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '79da0093a0caf8d3d132f19eeaabfc51e913836ba1af4d2e75ba4eb34a095fbd'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9111(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9111.Call} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '728addce21940a677f84084a580f86628e797524dc62c737955cfa49fb45a9a2'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9122(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9122.Call} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '70da3343fcc028adfc5c9cbbde2675b86c094aa5d478bcf604aa344002c03ac7'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9130(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9130.Call} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '20e43cf455dab5221853dc85fd37e40265fbc8a0477fef5aecc7cd0525080592'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9160(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9160.MaybeHashed} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'bcfa0ad0f329a732f0f17d4bc38b4f9029ebee85aacfa0eca09ff30989c50fd1'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9170(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9170.MaybeHashed} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '693937bfd2c5ce6cce7602632864fbb1ce8390e8f77cf5d2eb5fb81b05ee8517'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9180(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9180.MaybeHashed} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '5742be6470219310bb7de5597f2d78879c02d438d26794494c929c91be455d28'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9190(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9190.MaybeHashed} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'a025458b911b3cf465b8aa59912e0acc7b689c87aef43cc26a126c7f9cc9b6f1'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9220(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9220.MaybeHashed} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '93b3e7c1717b68bcc0de91d08241d5a310ba0badf913b5beb88fe9a78d07f482'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9230(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9230.MaybeHashed} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '0eb68954e8c676759346021f0a987424aac3427c12798025bc0b4c9a45fdf82f'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9250(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9250.MaybeHashed} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'f537837558ece826e2f4b1b5c758eb7b88384e25bd9e9eebd41b0a126f6fa0ab'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9271(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9271.MaybeHashed} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'c76b8a9f39b83c878614a6d987051020f1a59c2b36f274a5e14640f16e761a5e'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9291(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9291.MaybeHashed} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '99036be590a578a0839b5138346ee8ef6b33f5a55e7bbf03852003004352f1f9'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9300(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9300.MaybeHashed} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '95d1d698edbf3c35a564ce40d042063978dd4f670142cbb8b2c81f1d8ac4b6fe'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9320(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9320.Call} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '5e41f55cccd4ac3a675b3ce1bdcc3286f32ab540db670b8b16ecd26ed8000517'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9340(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9340.Call} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === '5bc4ff906cbbecf5d7b77739a50cbb21388e8c88d2d730e6525f2dd72eae6e5a'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9350(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9350.Call} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_after') === 'dfecec9cb436af544a5c24866bee50e959457a5256665c6e43f8e0f1191d0024'
    }

    /**
     * Anonymously schedule a task after a delay.
     * 
     * # <weight>
     * Same as [`schedule`].
     * # </weight>
     */
    get asV9370(): {after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9370.Call} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerScheduleNamedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.schedule_named')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '6df53e7f5df461c7544c8532ba2b0e0a1339ee8f17f87c42e201c10b4f41d0ec'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2005(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2005.Type_188} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '362ac765ef55a0131503fff140fb1c0932cd2287d8946bd600cc5194ad5e0525'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2007(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2007.Type_189} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '1fcc6ce1979d07442e7ec9ab67b6fd1c26955d137ff5a35af9884cd9c64636a0'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2011(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2011.Type_190} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '041271a7a07eea4d8c1ff884610ef1e0bdbfd77cdeb95b41d938b3938f976a1b'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2013(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2013.Type_190} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '9ae170f22a8933f4e7e5e3658ea15be97d6fd61c184dd1b1fa6013f484de9181'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2015(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2015.Type_192} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'cd6e3b2c41a1011208170e3a1e294cc4e916c530b93301f0871f61bf5f26531b'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2022(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2022.Type_192} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '3c7bcd0a67b85ff84aeda941e0d9b74963b9b3c197a7a84bb2fb32379dd3ee7b'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2023(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2023.Type_194} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '89e4976584cd5597217c0c4eb332fcb67dce6b2a5c1bcc1e007adea60baa28b3'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2024(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2024.Type_194} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '428c027befb212c22c3fcad9f80846a203d43c3492e01c788b7854f59f52f844'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2025(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2025.Type_195} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'ff5aa4204e785080f95ef32cedb8f69940b27ea87ffc6d54778eb907a21da4b7'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2026(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2026.Type_194} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '74cfc51a2b1bdb027356c180a24f9b309a9b9dc39444a5b3298e209641a018c1'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2028(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2028.Type_199} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '10b417667b9a40cf4b33fb2ea5ba0cc02ffd367000b9e37b995be7c59bd30021'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2029(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2029.Type_199} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'eb717840bea6efda9f8ae89a1c202441ff45b8cad0f9468fc372fb96035622d8'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV2030(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2030.Type_138} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'd7e8d1e24a5e90c82d0ee5b3d22893f499047b05b992038e232427cfbc4bd515'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV9010(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9010.Type_138} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '6d2c8452092d2343a234b65986abf25c95731ae814b79e1ab1db585f83bb2c90'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV9030(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9030.Type_138} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '4781824909bb1e7bd6cc703e1c8ac8529450c2e53185c74c0dddfb41596519f4'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV9040(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9040.Type_138} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'fab373ba228c97391b045defa483e73715b6f93c159f6e630b30fd29663021e5'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV9050(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9050.Type_139} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '017b8b13afcab8f463b297d98887aa349edf0825d2ded05a5be5651c03516d4d'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV9080(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9080.Type_138} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'd01f103ece10aa2720574a2c4cce71a0745bf66dc65810ab9a89fb58501f82ad'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV9090(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9090.Type_138} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'f4e1cc6845e53ebd1ca4eecb047cf7a641a4d86940cf9bc30525f65f5982fbf8'
    }

    /**
     *  Schedule a named task.
     * 
     *  # <weight>
     *  - S = Number of already scheduled calls
     *  - Base Weight: 29.6 + .159 * S µs
     *  - DB Weight:
     *      - Read: Agenda, Lookup
     *      - Write: Agenda, Lookup
     *  - Will use base weight of 35 which should be good for more than 30 scheduled calls
     *  # </weight>
     */
    get asV9100(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9100.Type_138} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'c0c970200b80ccc70316b437961d7269bfcaaa3eb6a6ea6a8876e5e14ac66c91'
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get asV9111(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9111.Call} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'f8077b1e5293ee7f320d92ac3375d113ca08db7e9440aabc3489cfb321702f73'
    }

    /**
     * Schedule a named task.
     * 
     * # <weight>
     * - S = Number of already scheduled calls
     * - Base Weight: 29.6 + .159 * S µs
     * - DB Weight:
     *     - Read: Agenda, Lookup
     *     - Write: Agenda, Lookup
     * - Will use base weight of 35 which should be good for more than 30 scheduled calls
     * # </weight>
     */
    get asV9122(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9122.Call} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '847ee4e98eaa922801f17258812421779b0b21b44008a779e7cfa99a21dc19b6'
    }

    /**
     * Schedule a named task.
     */
    get asV9130(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9130.Call} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'cc6d4a4b8617404a14067c1ef55ab5076282df2df6c4d122621fc64898d78fed'
    }

    /**
     * Schedule a named task.
     */
    get asV9160(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9160.MaybeHashed} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'b546fea3bdc8817f9ff0d215e3b795dfbae5da3ca959f0e1103d43a64ff4807f'
    }

    /**
     * Schedule a named task.
     */
    get asV9170(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9170.MaybeHashed} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'cc90267681ae8643a83259a95c7d41fa95801b8a82fc518f21ceadb1c985c965'
    }

    /**
     * Schedule a named task.
     */
    get asV9180(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9180.MaybeHashed} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '2bc21040e4d8b63e38deb5cd31127668eccf8cd20b95ea4257caa994ac096538'
    }

    /**
     * Schedule a named task.
     */
    get asV9190(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9190.MaybeHashed} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '2cab46e03081b3ff3b65c1030fa85f57b433d316a2b3774e737ee7b6d88810ec'
    }

    /**
     * Schedule a named task.
     */
    get asV9220(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9220.MaybeHashed} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '436a23dca6cc94a8a5660088db0a4501b3dba9be1a064b74bf5cf9256c3d9f36'
    }

    /**
     * Schedule a named task.
     */
    get asV9230(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9230.MaybeHashed} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '2bd3d8064323434a95f86028023a8972fb5ef6dd356fdfd3fd19c976c5cd6865'
    }

    /**
     * Schedule a named task.
     */
    get asV9250(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9250.MaybeHashed} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '801cc91edadcd5575c18313dbecaaff00eff27c62fe4e4f763a96e349de272bc'
    }

    /**
     * Schedule a named task.
     */
    get asV9271(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9271.MaybeHashed} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '8da1a75b75acd57f58f0d6b80012d76e0b14777c82b4dc8a7d67693234c3a899'
    }

    /**
     * Schedule a named task.
     */
    get asV9291(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9291.MaybeHashed} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'd31e6f9d387b974a6d727caf4774dfd9cbc0322d5224ee24d1ebf2951fb63ac7'
    }

    /**
     * Schedule a named task.
     */
    get asV9300(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9300.MaybeHashed} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'b99137a482dee4d49ce1b5b6cd55177f94a95b70ca178de964353290757a418d'
    }

    /**
     * Schedule a named task.
     */
    get asV9320(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9320.Call} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '1f27046d496af3873c479d3dd33d5888e191a6375b4e5e47ac8d3ae8239c34d8'
    }

    /**
     * Schedule a named task.
     */
    get asV9340(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9340.Call} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === '54bc8031539d41a2dbe3505f88fee7f450294dc948426a2005a7e6bc410bf169'
    }

    /**
     * Schedule a named task.
     */
    get asV9350(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9350.Call} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named') === 'f245ed20e8588ed35d29e6782e265d8f252fc445fe506236736d99e507bb8aca'
    }

    /**
     * Schedule a named task.
     */
    get asV9370(): {id: Uint8Array, when: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9370.Call} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class SchedulerScheduleNamedAfterCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Scheduler.schedule_named_after')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'd08c1691204b51e636b5ad33b8f09c4cccd9738d642ef223700208df6877d321'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV2015(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2015.Type_192} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '570020afcf5818e5f60ff51629edd9954be6075d5d6b35ccf92a03efc016edf4'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV2022(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2022.Type_192} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '82c7045a33319a35dcf80d5b3eb3be93af7274e2d023200948a8356d2f4a82e8'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV2023(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2023.Type_194} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '346bcc88bf7f8c30737a329f181123e89af8434f7a420a2b2c8021f480bd85b5'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV2024(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2024.Type_194} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'e8be702ad3ca7721f198509a690dd386cdd36a8a0b7ad7449a044d8d68c688ae'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV2025(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2025.Type_195} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '9da6dd446e9a51cc6bacd7be88bf237c74b637b89a50106c2ac490e0bc04358d'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV2026(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2026.Type_194} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '7849bb839e63e14bdc498977c7215f54ebdf73397736f5a4647c587178f8a89a'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV2028(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2028.Type_199} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '7f5ce396653788a531e911c1bf8d72ddafde5f1575857b909b74a40e91331be5'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV2029(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2029.Type_199} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '0d9498e1528d57554a58f92572ca1f0695dcc5593b8b849bde92157bc1c8faf3'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV2030(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v2030.Type_138} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'c405ddea8c8366c0d6481ce6c307a746e2ab09f75d8f131b782aca976a3bee25'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV9010(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9010.Type_138} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'b7f0517803734d43456bc219c418144c0bf2d161e0ac8602b8d9cee1ea5abfb8'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV9030(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9030.Type_138} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '3199ab4cb9200a41b2be8fe9c4906c986cda4941468f8fd5bd50fe2ddccd7ab5'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV9040(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9040.Type_138} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'd7efe4d79c99aecc2a0bf2cb2e20ec8d51ff7a4dd44caf69f90d2f098af651a8'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV9050(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9050.Type_139} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '20e6fde0f8583db6ade901eb507b1f0a57f05f6269d3fa41e59da30966edee97'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`].
     *  # </weight>
     */
    get asV9080(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9080.Type_138} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '095a9e68569801818170203479a5b90e440847df0319313a5ea8f2a579b73c7c'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get asV9090(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9090.Type_138} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'ee8d621d1e7fb3d3fcc8d62dbadf65c9cbe23043c281df16b57c7fdc6c842fba'
    }

    /**
     *  Schedule a named task after a delay.
     * 
     *  # <weight>
     *  Same as [`schedule_named`](Self::schedule_named).
     *  # </weight>
     */
    get asV9100(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9100.Type_138} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '3d26b66fdd784c8414ec1a479e9a2c30221b1cdc91b510e4afb84a933444bdd6'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9111(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9111.Call} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'e9d89123fa71db157e0b26bb57b1360cbf5e744a928d89d3d52eabcffd86e46c'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9122(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9122.Call} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '9d6a06f284661bf6f467f769b5d7fdbe8490194357490e50193bafdb73944672'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9130(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9130.Call} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'dea995ed121c39b5eaad2ca076b94c49b525ea54c58d3f0fda1724412720f580'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9160(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9160.MaybeHashed} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '4e30a0577a7f8840528768d9081a84eee8a993f548a1b56f56b0342f56d68218'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9170(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9170.MaybeHashed} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '53a3b4c2ddacb8ac204cfd22fd50c6945b7ecfb43babf027be9cd39ebd288187'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9180(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9180.MaybeHashed} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '96b1877d6872b7b404457badea781d915698a1e037d05f0ec0ca33944076b84a'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9190(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9190.MaybeHashed} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'b4f0883e1f1008f85a7e2105bc12aebcccea0bb620f0e31d58b7f7e1e2afad6b'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9220(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9220.MaybeHashed} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '1833dc3f0cd917e7578ac270dec09ec54dfe3ee92a25c7cee0353a90ef1951e4'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9230(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9230.MaybeHashed} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '2b7c6c9b11ed00b47de67803b8190dcc77e99de2bbf53c450a7ef1b303b4cbdd'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9250(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9250.MaybeHashed} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '6abedd9faa09614ce57934b2398a88af5158d5e0248a3bebf678ef2747e59f53'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9271(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9271.MaybeHashed} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '0c0b0cad65a434b858acfac022cdc3f18f1b610813b92a9b20b732d8498681c6'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9291(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9291.MaybeHashed} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'd7d4f4ed811bae655294f44cc52b7016237e68af5b3f504cb9a44bb8bcf6392c'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9300(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9300.MaybeHashed} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'cb047d74babe6cda9112642e80da058599418bf40067debefc37be2e8194f6d9'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9320(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9320.Call} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === 'b09d4dfbdbd41ff1832b8bfdf1abbd7f3481477b7724304ed22b8d6b20ea8640'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9340(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9340.Call} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '09ffbb0a4bb4e9902d13513482b5f8534e27e22755d016a18daa7ccde073cb81'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9350(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9350.Call} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Scheduler.schedule_named_after') === '86bf9f2288f0c6f70c1ad2d27cd08745ac4627cf09f20fcf7a7e1b327ae58297'
    }

    /**
     * Schedule a named task after a delay.
     * 
     * # <weight>
     * Same as [`schedule_named`](Self::schedule_named).
     * # </weight>
     */
    get asV9370(): {id: Uint8Array, after: number, maybePeriodic: ([number, number] | undefined), priority: number, call: v9370.Call} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class SessionPurgeKeysCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Session.purge_keys')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Removes any session key(s) of the function caller.
     *  This doesn't take effect until the next session.
     * 
     *  The dispatch origin of this function must be signed.
     * 
     *  # <weight>
     *  - O(N) in number of key types.
     *  - Removes N + 1 DB entries.
     *  - Reduces system account refs by one on success.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Session.purge_keys') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Removes any session key(s) of the function caller.
     *  This doesn't take effect until the next session.
     * 
     *  The dispatch origin of this function must be signed.
     * 
     *  # <weight>
     *  - O(N) in number of key types.
     *  - Removes N + 1 DB entries.
     *  - Reduces system account refs by one on success.
     *  # </weight>
     */
    get asV1050(): null {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class SessionSetKeysCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Session.set_keys')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Sets the session key(s) of the function caller to `key`.
     *  Allows an account to set its session key prior to becoming a validator.
     *  This doesn't take effect until the next session.
     * 
     *  The dispatch origin of this function must be signed.
     * 
     *  # <weight>
     *  - O(log n) in number of accounts.
     *  - One extra DB entry.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Session.set_keys') === '36e471631b42c68fd766c98024a7cfee894483d4bef76175535c24da12e081d3'
    }

    /**
     *  Sets the session key(s) of the function caller to `key`.
     *  Allows an account to set its session key prior to becoming a validator.
     *  This doesn't take effect until the next session.
     * 
     *  The dispatch origin of this function must be signed.
     * 
     *  # <weight>
     *  - O(log n) in number of accounts.
     *  - One extra DB entry.
     *  # </weight>
     */
    get asV1020(): {keys: [Uint8Array, Uint8Array, Uint8Array, Uint8Array, Uint8Array], proof: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Sets the session key(s) of the function caller to `keys`.
     *  Allows an account to set its session key prior to becoming a validator.
     *  This doesn't take effect until the next session.
     * 
     *  The dispatch origin of this function must be signed.
     * 
     *  # <weight>
     *  - Complexity: `O(1)`
     *    Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.
     *  - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
     *  - DbWrites: `origin account`, `NextKeys`
     *  - DbReads per key id: `KeyOwner`
     *  - DbWrites per key id: `KeyOwner`
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Session.set_keys') === 'a1a70888479ad5247435d9e2fd23b8e33f612d30750e9df442eb1fe2113226a2'
    }

    /**
     *  Sets the session key(s) of the function caller to `keys`.
     *  Allows an account to set its session key prior to becoming a validator.
     *  This doesn't take effect until the next session.
     * 
     *  The dispatch origin of this function must be signed.
     * 
     *  # <weight>
     *  - Complexity: `O(1)`
     *    Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.
     *  - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
     *  - DbWrites: `origin account`, `NextKeys`
     *  - DbReads per key id: `KeyOwner`
     *  - DbWrites per key id: `KeyOwner`
     *  # </weight>
     */
    get asV2028(): {keys: [Uint8Array, Uint8Array, Uint8Array, Uint8Array, Uint8Array, Uint8Array], proof: Uint8Array} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     * 
     * The dispatch origin of this function must be signed.
     * 
     * # <weight>
     * - Complexity: `O(1)`. Actual cost depends on the number of length of
     *   `T::Keys::key_ids()` which is fixed.
     * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
     * - DbWrites: `origin account`, `NextKeys`
     * - DbReads per key id: `KeyOwner`
     * - DbWrites per key id: `KeyOwner`
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Session.set_keys') === '4604d1399268a7696192252f14d8cb6323ded610dca210e5e585de92eec430d5'
    }

    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     * 
     * The dispatch origin of this function must be signed.
     * 
     * # <weight>
     * - Complexity: `O(1)`. Actual cost depends on the number of length of
     *   `T::Keys::key_ids()` which is fixed.
     * - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`
     * - DbWrites: `origin account`, `NextKeys`
     * - DbReads per key id: `KeyOwner`
     * - DbWrites per key id: `KeyOwner`
     * # </weight>
     */
    get asV9111(): {keys: v9111.SessionKeys, proof: Uint8Array} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class SlotsBidCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slots.bid')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Make a new bid from an account (including a parachain account) for deploying a new
     *  parachain.
     * 
     *  Multiple simultaneous bids from the same bidder are allowed only as long as all active
     *  bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
     * 
     *  - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
     *  funded by) the same account.
     *  - `auction_index` is the index of the auction to bid on. Should just be the present
     *  value of `AuctionCounter`.
     *  - `first_slot` is the first lease period index of the range to bid on. This is the
     *  absolute lease period index value, not an auction-specific offset.
     *  - `last_slot` is the last lease period index of the range to bid on. This is the
     *  absolute lease period index value, not an auction-specific offset.
     *  - `amount` is the amount to bid to be held as deposit for the parachain should the
     *  bid win. This amount is held throughout the range.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Slots.bid') === 'b1d8925547e09f658e88f4a3e5620e482f8ac6168d4815ea06d9f5f7eaa1ea59'
    }

    /**
     *  Make a new bid from an account (including a parachain account) for deploying a new
     *  parachain.
     * 
     *  Multiple simultaneous bids from the same bidder are allowed only as long as all active
     *  bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
     * 
     *  - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and
     *  funded by) the same account.
     *  - `auction_index` is the index of the auction to bid on. Should just be the present
     *  value of `AuctionCounter`.
     *  - `first_slot` is the first lease period index of the range to bid on. This is the
     *  absolute lease period index value, not an auction-specific offset.
     *  - `last_slot` is the last lease period index of the range to bid on. This is the
     *  absolute lease period index value, not an auction-specific offset.
     *  - `amount` is the amount to bid to be held as deposit for the parachain should the
     *  bid win. This amount is held throughout the range.
     */
    get asV1020(): {sub: number, auctionIndex: number, firstSlot: number, lastSlot: number, amount: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class SlotsBidRenewCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slots.bid_renew')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Make a new bid from a parachain account for renewing that (pre-existing) parachain.
     * 
     *  The origin *must* be a parachain account.
     * 
     *  Multiple simultaneous bids from the same bidder are allowed only as long as all active
     *  bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
     * 
     *  - `auction_index` is the index of the auction to bid on. Should just be the present
     *  value of `AuctionCounter`.
     *  - `first_slot` is the first lease period index of the range to bid on. This is the
     *  absolute lease period index value, not an auction-specific offset.
     *  - `last_slot` is the last lease period index of the range to bid on. This is the
     *  absolute lease period index value, not an auction-specific offset.
     *  - `amount` is the amount to bid to be held as deposit for the parachain should the
     *  bid win. This amount is held throughout the range.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Slots.bid_renew') === '018a267b8de5c41a29f25645e8e202178edd8a9c1c73c57c28b898f07a6c6108'
    }

    /**
     *  Make a new bid from a parachain account for renewing that (pre-existing) parachain.
     * 
     *  The origin *must* be a parachain account.
     * 
     *  Multiple simultaneous bids from the same bidder are allowed only as long as all active
     *  bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.
     * 
     *  - `auction_index` is the index of the auction to bid on. Should just be the present
     *  value of `AuctionCounter`.
     *  - `first_slot` is the first lease period index of the range to bid on. This is the
     *  absolute lease period index value, not an auction-specific offset.
     *  - `last_slot` is the last lease period index of the range to bid on. This is the
     *  absolute lease period index value, not an auction-specific offset.
     *  - `amount` is the amount to bid to be held as deposit for the parachain should the
     *  bid win. This amount is held throughout the range.
     */
    get asV1020(): {auctionIndex: number, firstSlot: number, lastSlot: number, amount: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class SlotsClearAllLeasesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slots.clear_all_leases')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Clear all leases for a Para Id, refunding any deposits back to the original owners.
     * 
     *  Can only be called by the Root origin.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Slots.clear_all_leases') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     *  Clear all leases for a Para Id, refunding any deposits back to the original owners.
     * 
     *  Can only be called by the Root origin.
     */
    get asV9010(): {para: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class SlotsElaborateDeployDataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slots.elaborate_deploy_data')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Note a new parachain's code.
     * 
     *  This must be called after `fix_deploy_data` and `code` must be the preimage of the
     *  `code_hash` passed there for the same `para_id`.
     * 
     *  This may be called before or after the beginning of the parachain's first lease period.
     *  If called before then the parachain will become active at the first block of its
     *  starting lease period. If after, then it will become active immediately after this call.
     * 
     *  - `_origin` is irrelevant.
     *  - `para_id` is the parachain ID whose code will be elaborated.
     *  - `code` is the preimage of the registered `code_hash` of `para_id`.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Slots.elaborate_deploy_data') === '9a40a8fb74388254ebfe10c77c1a2d627c12e75a87a05c83a06dc46a5bab3790'
    }

    /**
     *  Note a new parachain's code.
     * 
     *  This must be called after `fix_deploy_data` and `code` must be the preimage of the
     *  `code_hash` passed there for the same `para_id`.
     * 
     *  This may be called before or after the beginning of the parachain's first lease period.
     *  If called before then the parachain will become active at the first block of its
     *  starting lease period. If after, then it will become active immediately after this call.
     * 
     *  - `_origin` is irrelevant.
     *  - `para_id` is the parachain ID whose code will be elaborated.
     *  - `code` is the preimage of the registered `code_hash` of `para_id`.
     */
    get asV1020(): {paraId: number, code: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class SlotsFixDeployDataCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slots.fix_deploy_data')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the deploy information for a successful bid to deploy a new parachain.
     * 
     *  - `origin` must be the successful bidder account.
     *  - `sub` is the sub-bidder ID of the bidder.
     *  - `para_id` is the parachain ID allotted to the winning bidder.
     *  - `code_hash` is the hash of the parachain's Wasm validation function.
     *  - `initial_head_data` is the parachain's initial head data.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Slots.fix_deploy_data') === '5e6d9b5a4db80ac24001e9bbaf21eb24bab30b039987a75414548657ecc46dc4'
    }

    /**
     *  Set the deploy information for a successful bid to deploy a new parachain.
     * 
     *  - `origin` must be the successful bidder account.
     *  - `sub` is the sub-bidder ID of the bidder.
     *  - `para_id` is the parachain ID allotted to the winning bidder.
     *  - `code_hash` is the hash of the parachain's Wasm validation function.
     *  - `initial_head_data` is the parachain's initial head data.
     */
    get asV1020(): {sub: number, paraId: number, codeHash: Uint8Array, initialHeadData: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set the deploy information for a successful bid to deploy a new parachain.
     * 
     *  - `origin` must be the successful bidder account.
     *  - `sub` is the sub-bidder ID of the bidder.
     *  - `para_id` is the parachain ID allotted to the winning bidder.
     *  - `code_hash` is the hash of the parachain's Wasm validation function.
     *  - `initial_head_data` is the parachain's initial head data.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Slots.fix_deploy_data') === '5961015494d0987b15bf20f5cbc514afb227420bda7aecb64cbe1bf082d3e5fa'
    }

    /**
     *  Set the deploy information for a successful bid to deploy a new parachain.
     * 
     *  - `origin` must be the successful bidder account.
     *  - `sub` is the sub-bidder ID of the bidder.
     *  - `para_id` is the parachain ID allotted to the winning bidder.
     *  - `code_hash` is the hash of the parachain's Wasm validation function.
     *  - `initial_head_data` is the parachain's initial head data.
     */
    get asV1050(): {sub: number, paraId: number, codeHash: Uint8Array, codeSize: number, initialHeadData: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class SlotsForceLeaseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slots.force_lease')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Just a hotwire into the `lease_out` call, in case Root wants to force some lease to happen
     *  independently of any other on-chain mechanism to use it.
     * 
     *  Can only be called by the Root origin.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Slots.force_lease') === '7a85a97c4d9a6ea8aaf207f4760fceb3366bcc7fbfd7836192a4b01aebb9a461'
    }

    /**
     *  Just a hotwire into the `lease_out` call, in case Root wants to force some lease to happen
     *  independently of any other on-chain mechanism to use it.
     * 
     *  Can only be called by the Root origin.
     */
    get asV9010(): {para: number, leaser: Uint8Array, amount: bigint, periodBegin: number, periodCount: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class SlotsNewAuctionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slots.new_auction')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Create a new auction.
     * 
     *  This can only happen when there isn't already an auction in progress and may only be
     *  called by the root origin. Accepts the `duration` of this auction and the
     *  `lease_period_index` of the initial lease period of the four that are to be auctioned.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Slots.new_auction') === 'f9c6104e2d8ee4a5650bf6b22307030d44c7c7014eb5b79c3fdc26e37431996c'
    }

    /**
     *  Create a new auction.
     * 
     *  This can only happen when there isn't already an auction in progress and may only be
     *  called by the root origin. Accepts the `duration` of this auction and the
     *  `lease_period_index` of the initial lease period of the four that are to be auctioned.
     */
    get asV1020(): {duration: number, leasePeriodIndex: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class SlotsSetOffboardingCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slots.set_offboarding')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the off-boarding information for a parachain.
     * 
     *  The origin *must* be a parachain account.
     * 
     *  - `dest` is the destination account to receive the parachain's deposit.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Slots.set_offboarding') === 'd9f8d63eacf2ccc3b324687cc40a7fe2094ae32a05cf3df1ef1ee1689f634349'
    }

    /**
     *  Set the off-boarding information for a parachain.
     * 
     *  The origin *must* be a parachain account.
     * 
     *  - `dest` is the destination account to receive the parachain's deposit.
     */
    get asV1020(): {dest: v1020.LookupSource} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set the off-boarding information for a parachain.
     * 
     *  The origin *must* be a parachain account.
     * 
     *  - `dest` is the destination account to receive the parachain's deposit.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Slots.set_offboarding') === 'b460c0e5be86faa4e205be32c38d7cbf4012485c8ea8f2b0d2831cc6157b2ed8'
    }

    /**
     *  Set the off-boarding information for a parachain.
     * 
     *  The origin *must* be a parachain account.
     * 
     *  - `dest` is the destination account to receive the parachain's deposit.
     */
    get asV1050(): {dest: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class SlotsTriggerOnboardCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Slots.trigger_onboard')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Try to onboard a parachain that has a lease for the current lease period.
     * 
     *  This function can be useful if there was some state issue with a para that should
     *  have onboarded, but was unable to. As long as they have a lease period, we can
     *  let them onboard from here.
     * 
     *  Origin must be signed, but can be called by anyone.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Slots.trigger_onboard') === '0ce4d19bdf40ed1e5a65dd2dbc04fe21b73ba0dc7590c221c3e403e96726dc18'
    }

    /**
     *  Try to onboard a parachain that has a lease for the current lease period.
     * 
     *  This function can be useful if there was some state issue with a para that should
     *  have onboarded, but was unable to. As long as they have a lease period, we can
     *  let them onboard from here.
     * 
     *  Origin must be signed, but can be called by anyone.
     */
    get asV9010(): {para: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }
}

export class SocietyBidCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Society.bid')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  A user outside of the society can make a bid for entry.
     * 
     *  Payment: `CandidateDeposit` will be reserved for making a bid. It is returned
     *  when the bid becomes a member, or if the bid calls `unbid`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `value`: A one time payment the bid would like to receive when joining the society.
     * 
     *  # <weight>
     *  Key: B (len of bids), C (len of candidates), M (len of members), X (balance reserve)
     *  - Storage Reads:
     *  	- One storage read to check for suspended candidate. O(1)
     *  	- One storage read to check for suspended member. O(1)
     *  	- One storage read to retrieve all current bids. O(B)
     *  	- One storage read to retrieve all current candidates. O(C)
     *  	- One storage read to retrieve all members. O(M)
     *  - Storage Writes:
     *  	- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w/ read)
     *  	- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)
     *  - Notable Computation:
     *  	- O(B + C + log M) search to check user is not already a part of society.
     *  	- O(log B) search to insert the new bid sorted.
     *  - External Module Operations:
     *  	- One balance reserve operation. O(X)
     *  	- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.
     *  - Events:
     *  	- One event for new bid.
     *  	- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.
     * 
     *  Total Complexity: O(M + B + C + logM + logB + X)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Society.bid') === 'd74027ad27459f17d7446fef449271d1b0dc12b852c175623e871d009a661493'
    }

    /**
     *  A user outside of the society can make a bid for entry.
     * 
     *  Payment: `CandidateDeposit` will be reserved for making a bid. It is returned
     *  when the bid becomes a member, or if the bid calls `unbid`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Parameters:
     *  - `value`: A one time payment the bid would like to receive when joining the society.
     * 
     *  # <weight>
     *  Key: B (len of bids), C (len of candidates), M (len of members), X (balance reserve)
     *  - Storage Reads:
     *  	- One storage read to check for suspended candidate. O(1)
     *  	- One storage read to check for suspended member. O(1)
     *  	- One storage read to retrieve all current bids. O(B)
     *  	- One storage read to retrieve all current candidates. O(C)
     *  	- One storage read to retrieve all members. O(M)
     *  - Storage Writes:
     *  	- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w/ read)
     *  	- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)
     *  - Notable Computation:
     *  	- O(B + C + log M) search to check user is not already a part of society.
     *  	- O(log B) search to insert the new bid sorted.
     *  - External Module Operations:
     *  	- One balance reserve operation. O(X)
     *  	- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.
     *  - Events:
     *  	- One event for new bid.
     *  	- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.
     * 
     *  Total Complexity: O(M + B + C + logM + logB + X)
     *  # </weight>
     */
    get asV1040(): {value: bigint} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }
}

export class SocietyDefenderVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Society.defender_vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  As a member, vote on the defender.
     * 
     *  The dispatch origin for this call must be _Signed_ and a member.
     * 
     *  Parameters:
     *  - `approve`: A boolean which says if the candidate should be
     *  approved (`true`) or rejected (`false`).
     * 
     *  # <weight>
     *  - Key: M (len of members)
     *  - One storage read O(M) and O(log M) search to check user is a member.
     *  - One storage write to add vote to votes. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(M + logM)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Society.defender_vote') === '7f3883eaa4337d0b921104008470f68603a927875190e5df78d5a8579db11bb1'
    }

    /**
     *  As a member, vote on the defender.
     * 
     *  The dispatch origin for this call must be _Signed_ and a member.
     * 
     *  Parameters:
     *  - `approve`: A boolean which says if the candidate should be
     *  approved (`true`) or rejected (`false`).
     * 
     *  # <weight>
     *  - Key: M (len of members)
     *  - One storage read O(M) and O(log M) search to check user is a member.
     *  - One storage write to add vote to votes. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(M + logM)
     *  # </weight>
     */
    get asV1040(): {approve: boolean} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }
}

export class SocietyFoundCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Society.found')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Found the society.
     * 
     *  This is done as a discrete action in order to allow for the
     *  module to be included into a running chain and can only be done once.
     * 
     *  The dispatch origin for this call must be from the _FounderSetOrigin_.
     * 
     *  Parameters:
     *  - `founder` - The first member and head of the newly founded society.
     * 
     *  # <weight>
     *  - Two storage mutates to set `Head` and `Founder`. O(1)
     *  - One storage write to add the first member to society. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(1)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Society.found') === '3ce498ea29d7447b53a485fa80a93df29a14764a9c60317d99c91bb14617f832'
    }

    /**
     *  Found the society.
     * 
     *  This is done as a discrete action in order to allow for the
     *  module to be included into a running chain and can only be done once.
     * 
     *  The dispatch origin for this call must be from the _FounderSetOrigin_.
     * 
     *  Parameters:
     *  - `founder` - The first member and head of the newly founded society.
     * 
     *  # <weight>
     *  - Two storage mutates to set `Head` and `Founder`. O(1)
     *  - One storage write to add the first member to society. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(1)
     *  # </weight>
     */
    get asV1040(): {founder: Uint8Array} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Found the society.
     * 
     *  This is done as a discrete action in order to allow for the
     *  module to be included into a running chain and can only be done once.
     * 
     *  The dispatch origin for this call must be from the _FounderSetOrigin_.
     * 
     *  Parameters:
     *  - `founder` - The first member and head of the newly founded society.
     *  - `max_members` - The initial max number of members for the society.
     *  - `rules` - The rules of this society concerning membership.
     * 
     *  # <weight>
     *  - Two storage mutates to set `Head` and `Founder`. O(1)
     *  - One storage write to add the first member to society. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(1)
     *  # </weight>
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('Society.found') === 'd43b03d59ed8f1ae9a9e7a2fcc6153e9f585fc5f0162aa4f5c20bacbc75c918d'
    }

    /**
     *  Found the society.
     * 
     *  This is done as a discrete action in order to allow for the
     *  module to be included into a running chain and can only be done once.
     * 
     *  The dispatch origin for this call must be from the _FounderSetOrigin_.
     * 
     *  Parameters:
     *  - `founder` - The first member and head of the newly founded society.
     *  - `max_members` - The initial max number of members for the society.
     *  - `rules` - The rules of this society concerning membership.
     * 
     *  # <weight>
     *  - Two storage mutates to set `Head` and `Founder`. O(1)
     *  - One storage write to add the first member to society. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(1)
     *  # </weight>
     */
    get asV1042(): {founder: Uint8Array, maxMembers: number, rules: Uint8Array} {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Found the society.
     * 
     * This is done as a discrete action in order to allow for the
     * pallet to be included into a running chain and can only be done once.
     * 
     * The dispatch origin for this call must be from the _FounderSetOrigin_.
     * 
     * Parameters:
     * - `founder` - The first member and head of the newly founded society.
     * - `max_members` - The initial max number of members for the society.
     * - `rules` - The rules of this society concerning membership.
     * 
     * # <weight>
     * - Two storage mutates to set `Head` and `Founder`. O(1)
     * - One storage write to add the first member to society. O(1)
     * - One event.
     * 
     * Total Complexity: O(1)
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Society.found') === '292c78d910045fb09690369dc1ecf194fb284e4213dfabcc72d1e00246902c10'
    }

    /**
     * Found the society.
     * 
     * This is done as a discrete action in order to allow for the
     * pallet to be included into a running chain and can only be done once.
     * 
     * The dispatch origin for this call must be from the _FounderSetOrigin_.
     * 
     * Parameters:
     * - `founder` - The first member and head of the newly founded society.
     * - `max_members` - The initial max number of members for the society.
     * - `rules` - The rules of this society concerning membership.
     * 
     * # <weight>
     * - Two storage mutates to set `Head` and `Founder`. O(1)
     * - One storage write to add the first member to society. O(1)
     * - One event.
     * 
     * Total Complexity: O(1)
     * # </weight>
     */
    get asV9291(): {founder: v9291.MultiAddress, maxMembers: number, rules: Uint8Array} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class SocietyJudgeSuspendedCandidateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Society.judge_suspended_candidate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Allow suspended judgement origin to make judgement on a suspended candidate.
     * 
     *  If the judgement is `Approve`, we add them to society as a member with the appropriate
     *  payment for joining society.
     * 
     *  If the judgement is `Reject`, we either slash the deposit of the bid, giving it back
     *  to the society treasury, or we ban the voucher from vouching again.
     * 
     *  If the judgement is `Rebid`, we put the candidate back in the bid pool and let them go
     *  through the induction process again.
     * 
     *  The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.
     * 
     *  Parameters:
     *  - `who` - The suspended candidate to be judged.
     *  - `judgement` - `Approve`, `Reject`, or `Rebid`.
     * 
     *  # <weight>
     *  Key: B (len of bids), M (len of members), X (balance action)
     *  - One storage read to check `who` is a suspended candidate.
     *  - One storage removal of the suspended candidate.
     *  - Approve Logic
     *  	- One storage read to get the available pot to pay users with. O(1)
     *  	- One storage write to update the available pot. O(1)
     *  	- One storage read to get the current block number. O(1)
     *  	- One storage read to get all members. O(M)
     *  	- Up to one unreserve currency action.
     *  	- Up to two new storage writes to payouts.
     *  	- Up to one storage write with O(log M) binary search to add a member to society.
     *  - Reject Logic
     *  	- Up to one repatriate reserved currency action. O(X)
     *  	- Up to one storage write to ban the vouching member from vouching again.
     *  - Rebid Logic
     *  	- Storage mutate with O(log B) binary search to place the user back into bids.
     *  - Up to one additional event if unvouch takes place.
     *  - One storage removal.
     *  - One event for the judgement.
     * 
     *  Total Complexity: O(M + logM + B + X)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Society.judge_suspended_candidate') === '9cfbbcfc23b3de70e4c1d31b9c05e96a7516f783fe2bcdd1a713d315e7c1c8e7'
    }

    /**
     *  Allow suspended judgement origin to make judgement on a suspended candidate.
     * 
     *  If the judgement is `Approve`, we add them to society as a member with the appropriate
     *  payment for joining society.
     * 
     *  If the judgement is `Reject`, we either slash the deposit of the bid, giving it back
     *  to the society treasury, or we ban the voucher from vouching again.
     * 
     *  If the judgement is `Rebid`, we put the candidate back in the bid pool and let them go
     *  through the induction process again.
     * 
     *  The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.
     * 
     *  Parameters:
     *  - `who` - The suspended candidate to be judged.
     *  - `judgement` - `Approve`, `Reject`, or `Rebid`.
     * 
     *  # <weight>
     *  Key: B (len of bids), M (len of members), X (balance action)
     *  - One storage read to check `who` is a suspended candidate.
     *  - One storage removal of the suspended candidate.
     *  - Approve Logic
     *  	- One storage read to get the available pot to pay users with. O(1)
     *  	- One storage write to update the available pot. O(1)
     *  	- One storage read to get the current block number. O(1)
     *  	- One storage read to get all members. O(M)
     *  	- Up to one unreserve currency action.
     *  	- Up to two new storage writes to payouts.
     *  	- Up to one storage write with O(log M) binary search to add a member to society.
     *  - Reject Logic
     *  	- Up to one repatriate reserved currency action. O(X)
     *  	- Up to one storage write to ban the vouching member from vouching again.
     *  - Rebid Logic
     *  	- Storage mutate with O(log B) binary search to place the user back into bids.
     *  - Up to one additional event if unvouch takes place.
     *  - One storage removal.
     *  - One event for the judgement.
     * 
     *  Total Complexity: O(M + logM + B + X)
     *  # </weight>
     */
    get asV1040(): {who: Uint8Array, judgement: v1040.SocietyJudgement} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Allow suspended judgement origin to make judgement on a suspended candidate.
     * 
     * If the judgement is `Approve`, we add them to society as a member with the appropriate
     * payment for joining society.
     * 
     * If the judgement is `Reject`, we either slash the deposit of the bid, giving it back
     * to the society treasury, or we ban the voucher from vouching again.
     * 
     * If the judgement is `Rebid`, we put the candidate back in the bid pool and let them go
     * through the induction process again.
     * 
     * The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.
     * 
     * Parameters:
     * - `who` - The suspended candidate to be judged.
     * - `judgement` - `Approve`, `Reject`, or `Rebid`.
     * 
     * # <weight>
     * Key: B (len of bids), M (len of members), X (balance action)
     * - One storage read to check `who` is a suspended candidate.
     * - One storage removal of the suspended candidate.
     * - Approve Logic
     * 	- One storage read to get the available pot to pay users with. O(1)
     * 	- One storage write to update the available pot. O(1)
     * 	- One storage read to get the current block number. O(1)
     * 	- One storage read to get all members. O(M)
     * 	- Up to one unreserve currency action.
     * 	- Up to two new storage writes to payouts.
     * 	- Up to one storage write with O(log M) binary search to add a member to society.
     * - Reject Logic
     * 	- Up to one repatriate reserved currency action. O(X)
     * 	- Up to one storage write to ban the vouching member from vouching again.
     * - Rebid Logic
     * 	- Storage mutate with O(log B) binary search to place the user back into bids.
     * - Up to one additional event if unvouch takes place.
     * - One storage removal.
     * - One event for the judgement.
     * 
     * Total Complexity: O(M + logM + B + X)
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Society.judge_suspended_candidate') === 'a696052a8479d0eb388fb51fef46be81d7ac813689e702cd5f4c6e0730e96108'
    }

    /**
     * Allow suspended judgement origin to make judgement on a suspended candidate.
     * 
     * If the judgement is `Approve`, we add them to society as a member with the appropriate
     * payment for joining society.
     * 
     * If the judgement is `Reject`, we either slash the deposit of the bid, giving it back
     * to the society treasury, or we ban the voucher from vouching again.
     * 
     * If the judgement is `Rebid`, we put the candidate back in the bid pool and let them go
     * through the induction process again.
     * 
     * The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.
     * 
     * Parameters:
     * - `who` - The suspended candidate to be judged.
     * - `judgement` - `Approve`, `Reject`, or `Rebid`.
     * 
     * # <weight>
     * Key: B (len of bids), M (len of members), X (balance action)
     * - One storage read to check `who` is a suspended candidate.
     * - One storage removal of the suspended candidate.
     * - Approve Logic
     * 	- One storage read to get the available pot to pay users with. O(1)
     * 	- One storage write to update the available pot. O(1)
     * 	- One storage read to get the current block number. O(1)
     * 	- One storage read to get all members. O(M)
     * 	- Up to one unreserve currency action.
     * 	- Up to two new storage writes to payouts.
     * 	- Up to one storage write with O(log M) binary search to add a member to society.
     * - Reject Logic
     * 	- Up to one repatriate reserved currency action. O(X)
     * 	- Up to one storage write to ban the vouching member from vouching again.
     * - Rebid Logic
     * 	- Storage mutate with O(log B) binary search to place the user back into bids.
     * - Up to one additional event if unvouch takes place.
     * - One storage removal.
     * - One event for the judgement.
     * 
     * Total Complexity: O(M + logM + B + X)
     * # </weight>
     */
    get asV9291(): {who: v9291.MultiAddress, judgement: v9291.Type_386} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class SocietyJudgeSuspendedMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Society.judge_suspended_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Allow suspension judgement origin to make judgement on a suspended member.
     * 
     *  If a suspended member is forgiven, we simply add them back as a member, not affecting
     *  any of the existing storage items for that member.
     * 
     *  If a suspended member is rejected, remove all associated storage items, including
     *  their payouts, and remove any vouched bids they currently have.
     * 
     *  The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.
     * 
     *  Parameters:
     *  - `who` - The suspended member to be judged.
     *  - `forgive` - A boolean representing whether the suspension judgement origin
     *                forgives (`true`) or rejects (`false`) a suspended member.
     * 
     *  # <weight>
     *  Key: B (len of bids), M (len of members)
     *  - One storage read to check `who` is a suspended member. O(1)
     *  - Up to one storage write O(M) with O(log M) binary search to add a member back to society.
     *  - Up to 3 storage removals O(1) to clean up a removed member.
     *  - Up to one storage write O(B) with O(B) search to remove vouched bid from bids.
     *  - Up to one additional event if unvouch takes place.
     *  - One storage removal. O(1)
     *  - One event for the judgement.
     * 
     *  Total Complexity: O(M + logM + B)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Society.judge_suspended_member') === 'aedcf5a71b5a0fe37cbee301407f2e17b13722a40ff1d688ceaaee0d1653e9d8'
    }

    /**
     *  Allow suspension judgement origin to make judgement on a suspended member.
     * 
     *  If a suspended member is forgiven, we simply add them back as a member, not affecting
     *  any of the existing storage items for that member.
     * 
     *  If a suspended member is rejected, remove all associated storage items, including
     *  their payouts, and remove any vouched bids they currently have.
     * 
     *  The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.
     * 
     *  Parameters:
     *  - `who` - The suspended member to be judged.
     *  - `forgive` - A boolean representing whether the suspension judgement origin
     *                forgives (`true`) or rejects (`false`) a suspended member.
     * 
     *  # <weight>
     *  Key: B (len of bids), M (len of members)
     *  - One storage read to check `who` is a suspended member. O(1)
     *  - Up to one storage write O(M) with O(log M) binary search to add a member back to society.
     *  - Up to 3 storage removals O(1) to clean up a removed member.
     *  - Up to one storage write O(B) with O(B) search to remove vouched bid from bids.
     *  - Up to one additional event if unvouch takes place.
     *  - One storage removal. O(1)
     *  - One event for the judgement.
     * 
     *  Total Complexity: O(M + logM + B)
     *  # </weight>
     */
    get asV1040(): {who: Uint8Array, forgive: boolean} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Allow suspension judgement origin to make judgement on a suspended member.
     * 
     * If a suspended member is forgiven, we simply add them back as a member, not affecting
     * any of the existing storage items for that member.
     * 
     * If a suspended member is rejected, remove all associated storage items, including
     * their payouts, and remove any vouched bids they currently have.
     * 
     * The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.
     * 
     * Parameters:
     * - `who` - The suspended member to be judged.
     * - `forgive` - A boolean representing whether the suspension judgement origin forgives
     *   (`true`) or rejects (`false`) a suspended member.
     * 
     * # <weight>
     * Key: B (len of bids), M (len of members)
     * - One storage read to check `who` is a suspended member. O(1)
     * - Up to one storage write O(M) with O(log M) binary search to add a member back to
     *   society.
     * - Up to 3 storage removals O(1) to clean up a removed member.
     * - Up to one storage write O(B) with O(B) search to remove vouched bid from bids.
     * - Up to one additional event if unvouch takes place.
     * - One storage removal. O(1)
     * - One event for the judgement.
     * 
     * Total Complexity: O(M + logM + B)
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Society.judge_suspended_member') === 'd456db496c82da99b467b8a225c2a3c32cf059dc152d040afe4065d7ffda2094'
    }

    /**
     * Allow suspension judgement origin to make judgement on a suspended member.
     * 
     * If a suspended member is forgiven, we simply add them back as a member, not affecting
     * any of the existing storage items for that member.
     * 
     * If a suspended member is rejected, remove all associated storage items, including
     * their payouts, and remove any vouched bids they currently have.
     * 
     * The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.
     * 
     * Parameters:
     * - `who` - The suspended member to be judged.
     * - `forgive` - A boolean representing whether the suspension judgement origin forgives
     *   (`true`) or rejects (`false`) a suspended member.
     * 
     * # <weight>
     * Key: B (len of bids), M (len of members)
     * - One storage read to check `who` is a suspended member. O(1)
     * - Up to one storage write O(M) with O(log M) binary search to add a member back to
     *   society.
     * - Up to 3 storage removals O(1) to clean up a removed member.
     * - Up to one storage write O(B) with O(B) search to remove vouched bid from bids.
     * - Up to one additional event if unvouch takes place.
     * - One storage removal. O(1)
     * - One event for the judgement.
     * 
     * Total Complexity: O(M + logM + B)
     * # </weight>
     */
    get asV9291(): {who: v9291.MultiAddress, forgive: boolean} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class SocietyPayoutCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Society.payout')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer the first matured payout for the sender and remove it from the records.
     * 
     *  NOTE: This extrinsic needs to be called multiple times to claim multiple matured payouts.
     * 
     *  Payment: The member will receive a payment equal to their first matured
     *  payout to their free balance.
     * 
     *  The dispatch origin for this call must be _Signed_ and a member with
     *  payouts remaining.
     * 
     *  # <weight>
     *  Key: M (len of members), P (number of payouts for a particular member)
     *  - One storage read O(M) and O(log M) search to check signer is a member.
     *  - One storage read O(P) to get all payouts for a member.
     *  - One storage read O(1) to get the current block number.
     *  - One currency transfer call. O(X)
     *  - One storage write or removal to update the member's payouts. O(P)
     * 
     *  Total Complexity: O(M + logM + P + X)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Society.payout') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Transfer the first matured payout for the sender and remove it from the records.
     * 
     *  NOTE: This extrinsic needs to be called multiple times to claim multiple matured payouts.
     * 
     *  Payment: The member will receive a payment equal to their first matured
     *  payout to their free balance.
     * 
     *  The dispatch origin for this call must be _Signed_ and a member with
     *  payouts remaining.
     * 
     *  # <weight>
     *  Key: M (len of members), P (number of payouts for a particular member)
     *  - One storage read O(M) and O(log M) search to check signer is a member.
     *  - One storage read O(P) to get all payouts for a member.
     *  - One storage read O(1) to get the current block number.
     *  - One currency transfer call. O(X)
     *  - One storage write or removal to update the member's payouts. O(P)
     * 
     *  Total Complexity: O(M + logM + P + X)
     *  # </weight>
     */
    get asV1040(): null {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }
}

export class SocietySetMaxMembersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Society.set_max_members')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Allows root origin to change the maximum number of members in society.
     *  Max membership count must be greater than 1.
     * 
     *  The dispatch origin for this call must be from _ROOT_.
     * 
     *  Parameters:
     *  - `max` - The maximum number of members for the society.
     * 
     *  # <weight>
     *  - One storage write to update the max. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(1)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Society.set_max_members') === '405f1447d8db6ecc920213976cf7f98b6e74c5ceb4e2ecf66c742895e40e5d78'
    }

    /**
     *  Allows root origin to change the maximum number of members in society.
     *  Max membership count must be greater than 1.
     * 
     *  The dispatch origin for this call must be from _ROOT_.
     * 
     *  Parameters:
     *  - `max` - The maximum number of members for the society.
     * 
     *  # <weight>
     *  - One storage write to update the max. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(1)
     *  # </weight>
     */
    get asV1040(): {max: number} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }
}

export class SocietyUnbidCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Society.unbid')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  A bidder can remove their bid for entry into society.
     *  By doing so, they will have their candidate deposit returned or
     *  they will unvouch their voucher.
     * 
     *  Payment: The bid deposit is unreserved if the user made a bid.
     * 
     *  The dispatch origin for this call must be _Signed_ and a bidder.
     * 
     *  Parameters:
     *  - `pos`: Position in the `Bids` vector of the bid who wants to unbid.
     * 
     *  # <weight>
     *  Key: B (len of bids), X (balance unreserve)
     *  - One storage read and write to retrieve and update the bids. O(B)
     *  - Either one unreserve balance action O(X) or one vouching storage removal. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(B + X)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Society.unbid') === '63713692c933a03c402b9905e1704697c3aee2aa43526e662e752ecea441a045'
    }

    /**
     *  A bidder can remove their bid for entry into society.
     *  By doing so, they will have their candidate deposit returned or
     *  they will unvouch their voucher.
     * 
     *  Payment: The bid deposit is unreserved if the user made a bid.
     * 
     *  The dispatch origin for this call must be _Signed_ and a bidder.
     * 
     *  Parameters:
     *  - `pos`: Position in the `Bids` vector of the bid who wants to unbid.
     * 
     *  # <weight>
     *  Key: B (len of bids), X (balance unreserve)
     *  - One storage read and write to retrieve and update the bids. O(B)
     *  - Either one unreserve balance action O(X) or one vouching storage removal. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(B + X)
     *  # </weight>
     */
    get asV1040(): {pos: number} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }
}

export class SocietyUnfoundCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Society.unfound')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Anull the founding of the society.
     * 
     *  The dispatch origin for this call must be Signed, and the signing account must be both
     *  the `Founder` and the `Head`. This implies that it may only be done when there is one
     *  member.
     * 
     *  # <weight>
     *  - Two storage reads O(1).
     *  - Four storage removals O(1).
     *  - One event.
     * 
     *  Total Complexity: O(1)
     *  # </weight>
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('Society.unfound') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Anull the founding of the society.
     * 
     *  The dispatch origin for this call must be Signed, and the signing account must be both
     *  the `Founder` and the `Head`. This implies that it may only be done when there is one
     *  member.
     * 
     *  # <weight>
     *  - Two storage reads O(1).
     *  - Four storage removals O(1).
     *  - One event.
     * 
     *  Total Complexity: O(1)
     *  # </weight>
     */
    get asV1042(): null {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }
}

export class SocietyUnvouchCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Society.unvouch')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  As a vouching member, unvouch a bid. This only works while vouched user is
     *  only a bidder (and not a candidate).
     * 
     *  The dispatch origin for this call must be _Signed_ and a vouching member.
     * 
     *  Parameters:
     *  - `pos`: Position in the `Bids` vector of the bid who should be unvouched.
     * 
     *  # <weight>
     *  Key: B (len of bids)
     *  - One storage read O(1) to check the signer is a vouching member.
     *  - One storage mutate to retrieve and update the bids. O(B)
     *  - One vouching storage removal. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(B)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Society.unvouch') === '63713692c933a03c402b9905e1704697c3aee2aa43526e662e752ecea441a045'
    }

    /**
     *  As a vouching member, unvouch a bid. This only works while vouched user is
     *  only a bidder (and not a candidate).
     * 
     *  The dispatch origin for this call must be _Signed_ and a vouching member.
     * 
     *  Parameters:
     *  - `pos`: Position in the `Bids` vector of the bid who should be unvouched.
     * 
     *  # <weight>
     *  Key: B (len of bids)
     *  - One storage read O(1) to check the signer is a vouching member.
     *  - One storage mutate to retrieve and update the bids. O(B)
     *  - One vouching storage removal. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(B)
     *  # </weight>
     */
    get asV1040(): {pos: number} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }
}

export class SocietyVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Society.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  As a member, vote on a candidate.
     * 
     *  The dispatch origin for this call must be _Signed_ and a member.
     * 
     *  Parameters:
     *  - `candidate`: The candidate that the member would like to bid on.
     *  - `approve`: A boolean which says if the candidate should be
     *               approved (`true`) or rejected (`false`).
     * 
     *  # <weight>
     *  Key: C (len of candidates), M (len of members)
     *  - One storage read O(M) and O(log M) search to check user is a member.
     *  - One account lookup.
     *  - One storage read O(C) and O(C) search to check that user is a candidate.
     *  - One storage write to add vote to votes. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(M + logM + C)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Society.vote') === '2eb6120737af03d884fdc49b1bd8a0170d25e6e82f9ec4cd6c1621ef50df1994'
    }

    /**
     *  As a member, vote on a candidate.
     * 
     *  The dispatch origin for this call must be _Signed_ and a member.
     * 
     *  Parameters:
     *  - `candidate`: The candidate that the member would like to bid on.
     *  - `approve`: A boolean which says if the candidate should be
     *               approved (`true`) or rejected (`false`).
     * 
     *  # <weight>
     *  Key: C (len of candidates), M (len of members)
     *  - One storage read O(M) and O(log M) search to check user is a member.
     *  - One account lookup.
     *  - One storage read O(C) and O(C) search to check that user is a candidate.
     *  - One storage write to add vote to votes. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(M + logM + C)
     *  # </weight>
     */
    get asV1040(): {candidate: v1040.LookupSource, approve: boolean} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  As a member, vote on a candidate.
     * 
     *  The dispatch origin for this call must be _Signed_ and a member.
     * 
     *  Parameters:
     *  - `candidate`: The candidate that the member would like to bid on.
     *  - `approve`: A boolean which says if the candidate should be
     *               approved (`true`) or rejected (`false`).
     * 
     *  # <weight>
     *  Key: C (len of candidates), M (len of members)
     *  - One storage read O(M) and O(log M) search to check user is a member.
     *  - One account lookup.
     *  - One storage read O(C) and O(C) search to check that user is a candidate.
     *  - One storage write to add vote to votes. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(M + logM + C)
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Society.vote') === 'f9469731201474d6292b35c0c90bc4985fbcf2125f2ece2c08b1d529c9b288e2'
    }

    /**
     *  As a member, vote on a candidate.
     * 
     *  The dispatch origin for this call must be _Signed_ and a member.
     * 
     *  Parameters:
     *  - `candidate`: The candidate that the member would like to bid on.
     *  - `approve`: A boolean which says if the candidate should be
     *               approved (`true`) or rejected (`false`).
     * 
     *  # <weight>
     *  Key: C (len of candidates), M (len of members)
     *  - One storage read O(M) and O(log M) search to check user is a member.
     *  - One account lookup.
     *  - One storage read O(C) and O(C) search to check that user is a candidate.
     *  - One storage write to add vote to votes. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(M + logM + C)
     *  # </weight>
     */
    get asV1050(): {candidate: Uint8Array, approve: boolean} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  As a member, vote on a candidate.
     * 
     *  The dispatch origin for this call must be _Signed_ and a member.
     * 
     *  Parameters:
     *  - `candidate`: The candidate that the member would like to bid on.
     *  - `approve`: A boolean which says if the candidate should be
     *               approved (`true`) or rejected (`false`).
     * 
     *  # <weight>
     *  Key: C (len of candidates), M (len of members)
     *  - One storage read O(M) and O(log M) search to check user is a member.
     *  - One account lookup.
     *  - One storage read O(C) and O(C) search to check that user is a candidate.
     *  - One storage write to add vote to votes. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(M + logM + C)
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Society.vote') === '4451648f1740ff23cf2089647852281796f85acf02c0564e2e28974339273555'
    }

    /**
     *  As a member, vote on a candidate.
     * 
     *  The dispatch origin for this call must be _Signed_ and a member.
     * 
     *  Parameters:
     *  - `candidate`: The candidate that the member would like to bid on.
     *  - `approve`: A boolean which says if the candidate should be
     *               approved (`true`) or rejected (`false`).
     * 
     *  # <weight>
     *  Key: C (len of candidates), M (len of members)
     *  - One storage read O(M) and O(log M) search to check user is a member.
     *  - One account lookup.
     *  - One storage read O(C) and O(C) search to check that user is a candidate.
     *  - One storage write to add vote to votes. O(1)
     *  - One event.
     * 
     *  Total Complexity: O(M + logM + C)
     *  # </weight>
     */
    get asV2028(): {candidate: v2028.LookupSource, approve: boolean} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * As a member, vote on a candidate.
     * 
     * The dispatch origin for this call must be _Signed_ and a member.
     * 
     * Parameters:
     * - `candidate`: The candidate that the member would like to bid on.
     * - `approve`: A boolean which says if the candidate should be approved (`true`) or
     *   rejected (`false`).
     * 
     * # <weight>
     * Key: C (len of candidates), M (len of members)
     * - One storage read O(M) and O(log M) search to check user is a member.
     * - One account lookup.
     * - One storage read O(C) and O(C) search to check that user is a candidate.
     * - One storage write to add vote to votes. O(1)
     * - One event.
     * 
     * Total Complexity: O(M + logM + C)
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Society.vote') === '464e63d02db5ce6d0fc135184a217a60a7b532efa52d9522c48d91c9d16a5395'
    }

    /**
     * As a member, vote on a candidate.
     * 
     * The dispatch origin for this call must be _Signed_ and a member.
     * 
     * Parameters:
     * - `candidate`: The candidate that the member would like to bid on.
     * - `approve`: A boolean which says if the candidate should be approved (`true`) or
     *   rejected (`false`).
     * 
     * # <weight>
     * Key: C (len of candidates), M (len of members)
     * - One storage read O(M) and O(log M) search to check user is a member.
     * - One account lookup.
     * - One storage read O(C) and O(C) search to check that user is a candidate.
     * - One storage write to add vote to votes. O(1)
     * - One event.
     * 
     * Total Complexity: O(M + logM + C)
     * # </weight>
     */
    get asV9111(): {candidate: v9111.MultiAddress, approve: boolean} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class SocietyVouchCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Society.vouch')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  As a member, vouch for someone to join society by placing a bid on their behalf.
     * 
     *  There is no deposit required to vouch for a new bid, but a member can only vouch for
     *  one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by
     *  the suspension judgement origin, the member will be banned from vouching again.
     * 
     *  As a vouching member, you can claim a tip if the candidate is accepted. This tip will
     *  be paid as a portion of the reward the member will receive for joining the society.
     * 
     *  The dispatch origin for this call must be _Signed_ and a member.
     * 
     *  Parameters:
     *  - `who`: The user who you would like to vouch for.
     *  - `value`: The total reward to be paid between you and the candidate if they become
     *  a member in the society.
     *  - `tip`: Your cut of the total `value` payout when the candidate is inducted into
     *  the society. Tips larger than `value` will be saturated upon payout.
     * 
     *  # <weight>
     *  Key: B (len of bids), C (len of candidates), M (len of members)
     *  - Storage Reads:
     *  	- One storage read to retrieve all members. O(M)
     *  	- One storage read to check member is not already vouching. O(1)
     *  	- One storage read to check for suspended candidate. O(1)
     *  	- One storage read to check for suspended member. O(1)
     *  	- One storage read to retrieve all current bids. O(B)
     *  	- One storage read to retrieve all current candidates. O(C)
     *  - Storage Writes:
     *  	- One storage write to insert vouching status to the member. O(1)
     *  	- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w/ read)
     *  	- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)
     *  - Notable Computation:
     *  	- O(log M) search to check sender is a member.
     *  	- O(B + C + log M) search to check user is not already a part of society.
     *  	- O(log B) search to insert the new bid sorted.
     *  - External Module Operations:
     *  	- One balance reserve operation. O(X)
     *  	- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.
     *  - Events:
     *  	- One event for vouch.
     *  	- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.
     * 
     *  Total Complexity: O(M + B + C + logM + logB + X)
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Society.vouch') === '65c996f4655d3571c6a10715859f05f3488b25b8a6a881f981bb44307dd9c03b'
    }

    /**
     *  As a member, vouch for someone to join society by placing a bid on their behalf.
     * 
     *  There is no deposit required to vouch for a new bid, but a member can only vouch for
     *  one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by
     *  the suspension judgement origin, the member will be banned from vouching again.
     * 
     *  As a vouching member, you can claim a tip if the candidate is accepted. This tip will
     *  be paid as a portion of the reward the member will receive for joining the society.
     * 
     *  The dispatch origin for this call must be _Signed_ and a member.
     * 
     *  Parameters:
     *  - `who`: The user who you would like to vouch for.
     *  - `value`: The total reward to be paid between you and the candidate if they become
     *  a member in the society.
     *  - `tip`: Your cut of the total `value` payout when the candidate is inducted into
     *  the society. Tips larger than `value` will be saturated upon payout.
     * 
     *  # <weight>
     *  Key: B (len of bids), C (len of candidates), M (len of members)
     *  - Storage Reads:
     *  	- One storage read to retrieve all members. O(M)
     *  	- One storage read to check member is not already vouching. O(1)
     *  	- One storage read to check for suspended candidate. O(1)
     *  	- One storage read to check for suspended member. O(1)
     *  	- One storage read to retrieve all current bids. O(B)
     *  	- One storage read to retrieve all current candidates. O(C)
     *  - Storage Writes:
     *  	- One storage write to insert vouching status to the member. O(1)
     *  	- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w/ read)
     *  	- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)
     *  - Notable Computation:
     *  	- O(log M) search to check sender is a member.
     *  	- O(B + C + log M) search to check user is not already a part of society.
     *  	- O(log B) search to insert the new bid sorted.
     *  - External Module Operations:
     *  	- One balance reserve operation. O(X)
     *  	- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.
     *  - Events:
     *  	- One event for vouch.
     *  	- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.
     * 
     *  Total Complexity: O(M + B + C + logM + logB + X)
     *  # </weight>
     */
    get asV1040(): {who: Uint8Array, value: bigint, tip: bigint} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     * As a member, vouch for someone to join society by placing a bid on their behalf.
     * 
     * There is no deposit required to vouch for a new bid, but a member can only vouch for
     * one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by
     * the suspension judgement origin, the member will be banned from vouching again.
     * 
     * As a vouching member, you can claim a tip if the candidate is accepted. This tip will
     * be paid as a portion of the reward the member will receive for joining the society.
     * 
     * The dispatch origin for this call must be _Signed_ and a member.
     * 
     * Parameters:
     * - `who`: The user who you would like to vouch for.
     * - `value`: The total reward to be paid between you and the candidate if they become
     * a member in the society.
     * - `tip`: Your cut of the total `value` payout when the candidate is inducted into
     * the society. Tips larger than `value` will be saturated upon payout.
     * 
     * # <weight>
     * Key: B (len of bids), C (len of candidates), M (len of members)
     * - Storage Reads:
     * 	- One storage read to retrieve all members. O(M)
     * 	- One storage read to check member is not already vouching. O(1)
     * 	- One storage read to check for suspended candidate. O(1)
     * 	- One storage read to check for suspended member. O(1)
     * 	- One storage read to retrieve all current bids. O(B)
     * 	- One storage read to retrieve all current candidates. O(C)
     * - Storage Writes:
     * 	- One storage write to insert vouching status to the member. O(1)
     * 	- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization
     *    w/ read)
     * 	- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)
     * - Notable Computation:
     * 	- O(log M) search to check sender is a member.
     * 	- O(B + C + log M) search to check user is not already a part of society.
     * 	- O(log B) search to insert the new bid sorted.
     * - External Pallet Operations:
     * 	- One balance reserve operation. O(X)
     * 	- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.
     * - Events:
     * 	- One event for vouch.
     * 	- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.
     * 
     * Total Complexity: O(M + B + C + logM + logB + X)
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Society.vouch') === '6e4614d88956c320da6839813343aafce0760712678ec170a6086e958d21e5e6'
    }

    /**
     * As a member, vouch for someone to join society by placing a bid on their behalf.
     * 
     * There is no deposit required to vouch for a new bid, but a member can only vouch for
     * one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by
     * the suspension judgement origin, the member will be banned from vouching again.
     * 
     * As a vouching member, you can claim a tip if the candidate is accepted. This tip will
     * be paid as a portion of the reward the member will receive for joining the society.
     * 
     * The dispatch origin for this call must be _Signed_ and a member.
     * 
     * Parameters:
     * - `who`: The user who you would like to vouch for.
     * - `value`: The total reward to be paid between you and the candidate if they become
     * a member in the society.
     * - `tip`: Your cut of the total `value` payout when the candidate is inducted into
     * the society. Tips larger than `value` will be saturated upon payout.
     * 
     * # <weight>
     * Key: B (len of bids), C (len of candidates), M (len of members)
     * - Storage Reads:
     * 	- One storage read to retrieve all members. O(M)
     * 	- One storage read to check member is not already vouching. O(1)
     * 	- One storage read to check for suspended candidate. O(1)
     * 	- One storage read to check for suspended member. O(1)
     * 	- One storage read to retrieve all current bids. O(B)
     * 	- One storage read to retrieve all current candidates. O(C)
     * - Storage Writes:
     * 	- One storage write to insert vouching status to the member. O(1)
     * 	- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization
     *    w/ read)
     * 	- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)
     * - Notable Computation:
     * 	- O(log M) search to check sender is a member.
     * 	- O(B + C + log M) search to check user is not already a part of society.
     * 	- O(log B) search to insert the new bid sorted.
     * - External Pallet Operations:
     * 	- One balance reserve operation. O(X)
     * 	- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.
     * - Events:
     * 	- One event for vouch.
     * 	- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.
     * 
     * Total Complexity: O(M + B + C + logM + logB + X)
     * # </weight>
     */
    get asV9291(): {who: v9291.MultiAddress, value: bigint, tip: bigint} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingBondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.bond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Take the origin account as a stash and lock up `value` of its balance. `controller` will
     *  be the account that controls it.
     * 
     *  `value` must be more than the `minimum_balance` specified by `T::Currency`.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash account.
     * 
     *  # <weight>
     *  - Independent of the arguments. Moderate complexity.
     *  - O(1).
     *  - Three extra DB entries.
     * 
     *  NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned unless
     *  the `origin` falls below _existential deposit_ and gets removed as dust.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.bond') === '77a89e4c12792f968efd83b6a9d740690602a445b35884d8ae655bdc1f3480f7'
    }

    /**
     *  Take the origin account as a stash and lock up `value` of its balance. `controller` will
     *  be the account that controls it.
     * 
     *  `value` must be more than the `minimum_balance` specified by `T::Currency`.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash account.
     * 
     *  # <weight>
     *  - Independent of the arguments. Moderate complexity.
     *  - O(1).
     *  - Three extra DB entries.
     * 
     *  NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned unless
     *  the `origin` falls below _existential deposit_ and gets removed as dust.
     *  # </weight>
     */
    get asV1020(): {controller: v1020.LookupSource, value: bigint, payee: v1020.RewardDestination} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Take the origin account as a stash and lock up `value` of its balance. `controller` will
     *  be the account that controls it.
     * 
     *  `value` must be more than the `minimum_balance` specified by `T::Currency`.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash account.
     * 
     *  # <weight>
     *  - Independent of the arguments. Moderate complexity.
     *  - O(1).
     *  - Three extra DB entries.
     * 
     *  NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned unless
     *  the `origin` falls below _existential deposit_ and gets removed as dust.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Staking.bond') === 'bb948688bed1a70b8b0ff155f0a4555536a3bab1f35f7432580a502b100ae8e4'
    }

    /**
     *  Take the origin account as a stash and lock up `value` of its balance. `controller` will
     *  be the account that controls it.
     * 
     *  `value` must be more than the `minimum_balance` specified by `T::Currency`.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash account.
     * 
     *  # <weight>
     *  - Independent of the arguments. Moderate complexity.
     *  - O(1).
     *  - Three extra DB entries.
     * 
     *  NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned unless
     *  the `origin` falls below _existential deposit_ and gets removed as dust.
     *  # </weight>
     */
    get asV1050(): {controller: Uint8Array, value: bigint, payee: v1050.RewardDestination} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Take the origin account as a stash and lock up `value` of its balance. `controller` will
     *  be the account that controls it.
     * 
     *  `value` must be more than the `minimum_balance` specified by `T::Currency`.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash account.
     * 
     *  Emits `Bonded`.
     * 
     *  # <weight>
     *  - Independent of the arguments. Moderate complexity.
     *  - O(1).
     *  - Three extra DB entries.
     * 
     *  NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
     *  unless the `origin` falls below _existential deposit_ and gets removed as dust.
     *  ------------------
     *  Weight: O(1)
     *  DB Weight:
     *  - Read: Bonded, Ledger, [Origin Account], Current Era, History Depth, Locks
     *  - Write: Bonded, Payee, [Origin Account], Locks, Ledger
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Staking.bond') === '336aace4bca839311d4cecb842a12241ffdc1cb7c84e81b2b6ab6a2b818777f0'
    }

    /**
     *  Take the origin account as a stash and lock up `value` of its balance. `controller` will
     *  be the account that controls it.
     * 
     *  `value` must be more than the `minimum_balance` specified by `T::Currency`.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash account.
     * 
     *  Emits `Bonded`.
     * 
     *  # <weight>
     *  - Independent of the arguments. Moderate complexity.
     *  - O(1).
     *  - Three extra DB entries.
     * 
     *  NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
     *  unless the `origin` falls below _existential deposit_ and gets removed as dust.
     *  ------------------
     *  Weight: O(1)
     *  DB Weight:
     *  - Read: Bonded, Ledger, [Origin Account], Current Era, History Depth, Locks
     *  - Write: Bonded, Payee, [Origin Account], Locks, Ledger
     *  # </weight>
     */
    get asV2028(): {controller: v2028.LookupSource, value: bigint, payee: v2028.RewardDestination} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Take the origin account as a stash and lock up `value` of its balance. `controller` will
     * be the account that controls it.
     * 
     * `value` must be more than the `minimum_balance` specified by `T::Currency`.
     * 
     * The dispatch origin for this call must be _Signed_ by the stash account.
     * 
     * Emits `Bonded`.
     * # <weight>
     * - Independent of the arguments. Moderate complexity.
     * - O(1).
     * - Three extra DB entries.
     * 
     * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
     * unless the `origin` falls below _existential deposit_ and gets removed as dust.
     * ------------------
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Staking.bond') === 'c0b607a5cbdc40ee9aed26b3c86cfe3159aeccd5ac4e9005210dd39d0317ba48'
    }

    /**
     * Take the origin account as a stash and lock up `value` of its balance. `controller` will
     * be the account that controls it.
     * 
     * `value` must be more than the `minimum_balance` specified by `T::Currency`.
     * 
     * The dispatch origin for this call must be _Signed_ by the stash account.
     * 
     * Emits `Bonded`.
     * # <weight>
     * - Independent of the arguments. Moderate complexity.
     * - O(1).
     * - Three extra DB entries.
     * 
     * NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
     * unless the `origin` falls below _existential deposit_ and gets removed as dust.
     * ------------------
     * # </weight>
     */
    get asV9111(): {controller: v9111.MultiAddress, value: bigint, payee: v9111.RewardDestination} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingBondExtraCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.bond_extra')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add some extra amount that have appeared in the stash `free_balance` into the balance up
     *  for staking.
     * 
     *  Use this if there are additional funds in your stash account that you wish to bond.
     *  Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount
     *  that can be added.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - O(1).
     *  - One DB entry.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.bond_extra') === 'f92c56c980d6a55c468653fc3149548edcf2481e5da53835a201cafa7dc02fd8'
    }

    /**
     *  Add some extra amount that have appeared in the stash `free_balance` into the balance up
     *  for staking.
     * 
     *  Use this if there are additional funds in your stash account that you wish to bond.
     *  Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount
     *  that can be added.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - O(1).
     *  - One DB entry.
     *  # </weight>
     */
    get asV1020(): {maxAdditional: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingCancelDeferredSlashCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.cancel_deferred_slash')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel enactment of a deferred slash. Can be called by either the root origin or
     *  the `T::SlashCancelOrigin`.
     *  passing the era and indices of the slashes for that era to kill.
     * 
     *  # <weight>
     *  - One storage write.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.cancel_deferred_slash') === 'fab176436ff709189f441a9c591b1e715361b4db2636055c0154e452e116feb0'
    }

    /**
     *  Cancel enactment of a deferred slash. Can be called by either the root origin or
     *  the `T::SlashCancelOrigin`.
     *  passing the era and indices of the slashes for that era to kill.
     * 
     *  # <weight>
     *  - One storage write.
     *  # </weight>
     */
    get asV1020(): {era: number, slashIndices: number[]} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingChillCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.chill')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Declare no desire to either validate or nominate.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains one read.
     *  - Writes are limited to the `origin` account key.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.chill') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Declare no desire to either validate or nominate.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains one read.
     *  - Writes are limited to the `origin` account key.
     *  # </weight>
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingChillOtherCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.chill_other')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Declare a `controller` as having no desire to either validator or nominate.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_, but can be called by anyone.
     * 
     *  If the caller is the same as the controller being targeted, then no further checks
     *  are enforced. However, this call can also be made by an third party user who witnesses
     *  that this controller does not satisfy the minimum bond requirements to be in their role.
     * 
     *  This can be helpful if bond requirements are updated, and we need to remove old users
     *  who do not satisfy these requirements.
     * 
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Staking.chill_other') === 'bbdd03dc244a9d87deceeb91d015d7ef52746b99580b1474586c8699a77574e1'
    }

    /**
     *  Declare a `controller` as having no desire to either validator or nominate.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_, but can be called by anyone.
     * 
     *  If the caller is the same as the controller being targeted, then no further checks
     *  are enforced. However, this call can also be made by an third party user who witnesses
     *  that this controller does not satisfy the minimum bond requirements to be in their role.
     * 
     *  This can be helpful if bond requirements are updated, and we need to remove old users
     *  who do not satisfy these requirements.
     * 
     */
    get asV9050(): {controller: Uint8Array} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingForceApplyMinCommissionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.force_apply_min_commission')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force a validator to have at least the minimum commission. This will not affect a
     * validator who already has a commission greater than or equal to the minimum. Any account
     * can call this.
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Staking.force_apply_min_commission') === 'ee412bb909d2500627205d4c5b741967883fb1ed7f64bdc95edae3852f63750e'
    }

    /**
     * Force a validator to have at least the minimum commission. This will not affect a
     * validator who already has a commission greater than or equal to the minimum. Any account
     * can call this.
     */
    get asV9170(): {validatorStash: Uint8Array} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingForceNewEraCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.force_new_era')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force there to be a new era at the end of the next session. After this, it will be
     *  reset to normal (non-forced) behaviour.
     * 
     *  # <weight>
     *  - No arguments.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.force_new_era') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Force there to be a new era at the end of the next session. After this, it will be
     *  reset to normal (non-forced) behaviour.
     * 
     *  # <weight>
     *  - No arguments.
     *  # </weight>
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingForceNewEraAlwaysCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.force_new_era_always')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force there to be a new era at the end of sessions indefinitely.
     * 
     *  # <weight>
     *  - One storage write
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.force_new_era_always') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Force there to be a new era at the end of sessions indefinitely.
     * 
     *  # <weight>
     *  - One storage write
     *  # </weight>
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingForceNoErasCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.force_no_eras')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force there to be no new eras indefinitely.
     * 
     *  # <weight>
     *  - No arguments.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.force_no_eras') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Force there to be no new eras indefinitely.
     * 
     *  # <weight>
     *  - No arguments.
     *  # </weight>
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingForceUnstakeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.force_unstake')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force a current staker to become completely unstaked, immediately.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.force_unstake') === '7f6c53511d7cf7d5d6d53c9bd68762f88e130eef3cdaff66e227fd21c493b12c'
    }

    /**
     *  Force a current staker to become completely unstaked, immediately.
     */
    get asV1020(): {stash: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Force a current staker to become completely unstaked, immediately.
     * 
     *  The dispatch origin must be Root.
     * 
     *  # <weight>
     *  O(S) where S is the number of slashing spans to be removed
     *  Base Weight: 53.07 + 2.365 * S µs
     *  Reads: Bonded, Slashing Spans, Account, Locks
     *  Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Account, Locks
     *  Writes Each: SpanSlash * S
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Staking.force_unstake') === '9d6e1257b3e6113f6cc99a4193f2fef8c6513a3d2a99ee686af751b5931f583b'
    }

    /**
     *  Force a current staker to become completely unstaked, immediately.
     * 
     *  The dispatch origin must be Root.
     * 
     *  # <weight>
     *  O(S) where S is the number of slashing spans to be removed
     *  Base Weight: 53.07 + 2.365 * S µs
     *  Reads: Bonded, Slashing Spans, Account, Locks
     *  Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Account, Locks
     *  Writes Each: SpanSlash * S
     *  # </weight>
     */
    get asV2005(): {stash: Uint8Array, numSlashingSpans: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingIncreaseValidatorCountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.increase_validator_count')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Increments the ideal number of validators.
     * 
     *  The dispatch origin must be Root.
     * 
     *  # <weight>
     *  Base Weight: 1.717 µs
     *  Read/Write: Validator Count
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Staking.increase_validator_count') === '1b5e15eec25101f7a4e4a63e4c35b1120c3147dac0ca34ddcab4e7e3bb6ef150'
    }

    /**
     *  Increments the ideal number of validators.
     * 
     *  The dispatch origin must be Root.
     * 
     *  # <weight>
     *  Base Weight: 1.717 µs
     *  Read/Write: Validator Count
     *  # </weight>
     */
    get asV2011(): {additional: number} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingKickCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.kick')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove the given nominations from the calling validator.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *  And, it can be only called when [`EraElectionStatus`] is `Closed`. The controller
     *  account should represent a validator.
     * 
     *  - `who`: A list of nominator stash accounts who are nominating this validator which
     *    should no longer be nominating this validator.
     * 
     *  Note: Making this call only makes sense if you first set the validator preferences to
     *  block any further nominations.
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Staking.kick') === '760f2d470d3cb5efbef130b8d79a202238d983a6680d5e2d4eee31ad48834e9f'
    }

    /**
     *  Remove the given nominations from the calling validator.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *  And, it can be only called when [`EraElectionStatus`] is `Closed`. The controller
     *  account should represent a validator.
     * 
     *  - `who`: A list of nominator stash accounts who are nominating this validator which
     *    should no longer be nominating this validator.
     * 
     *  Note: Making this call only makes sense if you first set the validator preferences to
     *  block any further nominations.
     */
    get asV2028(): {who: v2028.LookupSource[]} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove the given nominations from the calling validator.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * - `who`: A list of nominator stash accounts who are nominating this validator which
     *   should no longer be nominating this validator.
     * 
     * Note: Making this call only makes sense if you first set the validator preferences to
     * block any further nominations.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Staking.kick') === 'e538d9391f8376022db5c010fa7390c92954267b2d5ebc13e621f87adebe57b9'
    }

    /**
     * Remove the given nominations from the calling validator.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * - `who`: A list of nominator stash accounts who are nominating this validator which
     *   should no longer be nominating this validator.
     * 
     * Note: Making this call only makes sense if you first set the validator preferences to
     * block any further nominations.
     */
    get asV9111(): {who: v9111.MultiAddress[]} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingNominateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.nominate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Declare the desire to nominate `targets` for the origin controller.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  # <weight>
     *  - The transaction's complexity is proportional to the size of `targets`,
     *  which is capped at `MAX_NOMINATIONS`.
     *  - Both the reads and writes follow a similar pattern.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.nominate') === 'ef0d9859df5914c3ac406eb6255e894f22bdc249ab0f7f82c6f01029112924b1'
    }

    /**
     *  Declare the desire to nominate `targets` for the origin controller.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  # <weight>
     *  - The transaction's complexity is proportional to the size of `targets`,
     *  which is capped at `MAX_NOMINATIONS`.
     *  - Both the reads and writes follow a similar pattern.
     *  # </weight>
     */
    get asV1020(): {targets: v1020.LookupSource[]} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Declare the desire to nominate `targets` for the origin controller.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  # <weight>
     *  - The transaction's complexity is proportional to the size of `targets`,
     *  which is capped at `MAX_NOMINATIONS`.
     *  - Both the reads and writes follow a similar pattern.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Staking.nominate') === '730fc5a4090c1c566ea6d11126ba7258c98a461b0c6bfca8bf9e17e42f8801de'
    }

    /**
     *  Declare the desire to nominate `targets` for the origin controller.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  # <weight>
     *  - The transaction's complexity is proportional to the size of `targets`,
     *  which is capped at `MAX_NOMINATIONS`.
     *  - Both the reads and writes follow a similar pattern.
     *  # </weight>
     */
    get asV1050(): {targets: Uint8Array[]} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Declare the desire to nominate `targets` for the origin controller.
     * 
     *  Effects will be felt at the beginning of the next era. This can only be called when
     *  [`EraElectionStatus`] is `Closed`.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *  And, it can be only called when [`EraElectionStatus`] is `Closed`.
     * 
     *  # <weight>
     *  - The transaction's complexity is proportional to the size of `targets` (N)
     *  which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS).
     *  - Both the reads and writes follow a similar pattern.
     *  ---------
     *  Weight: O(N)
     *  where N is the number of targets
     *  DB Weight:
     *  - Reads: Era Election Status, Ledger, Current Era
     *  - Writes: Validators, Nominators
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Staking.nominate') === 'a653cde167810e73479047a5ef0738fdd0dc4e9afa5b310a19c8335e4378f706'
    }

    /**
     *  Declare the desire to nominate `targets` for the origin controller.
     * 
     *  Effects will be felt at the beginning of the next era. This can only be called when
     *  [`EraElectionStatus`] is `Closed`.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *  And, it can be only called when [`EraElectionStatus`] is `Closed`.
     * 
     *  # <weight>
     *  - The transaction's complexity is proportional to the size of `targets` (N)
     *  which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS).
     *  - Both the reads and writes follow a similar pattern.
     *  ---------
     *  Weight: O(N)
     *  where N is the number of targets
     *  DB Weight:
     *  - Reads: Era Election Status, Ledger, Current Era
     *  - Writes: Validators, Nominators
     *  # </weight>
     */
    get asV2028(): {targets: v2028.LookupSource[]} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Declare the desire to nominate `targets` for the origin controller.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * # <weight>
     * - The transaction's complexity is proportional to the size of `targets` (N)
     * which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS).
     * - Both the reads and writes follow a similar pattern.
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Staking.nominate') === '4b7eca27044655bd9da5cc614a4bf774babc00decbed9ca59d95298b300d72de'
    }

    /**
     * Declare the desire to nominate `targets` for the origin controller.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     * # <weight>
     * - The transaction's complexity is proportional to the size of `targets` (N)
     * which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS).
     * - Both the reads and writes follow a similar pattern.
     * # </weight>
     */
    get asV9111(): {targets: v9111.MultiAddress[]} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingPayoutNominatorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.payout_nominator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Make one nominator's payout for one era.
     * 
     *  - `who` is the controller account of the nominator to pay out.
     *  - `era` may not be lower than one following the most recently paid era. If it is higher,
     *    then it indicates an instruction to skip the payout of all previous eras.
     *  - `validators` is the list of all validators that `who` had exposure to during `era`.
     *    If it is incomplete, then less than the full reward will be paid out.
     *    It must not exceed `MAX_NOMINATIONS`.
     * 
     *  WARNING: once an era is payed for a validator such validator can't claim the payout of
     *  previous era.
     * 
     *  WARNING: Incorrect arguments here can result in loss of payout. Be very careful.
     * 
     *  # <weight>
     *  - Number of storage read of `O(validators)`; `validators` is the argument of the call,
     *    and is bounded by `MAX_NOMINATIONS`.
     *  - Each storage read is `O(N)` size and decode complexity; `N` is the  maximum
     *    nominations that can be given to a single validator.
     *  - Computation complexity: `O(MAX_NOMINATIONS * logN)`; `MAX_NOMINATIONS` is the
     *    maximum number of validators that may be nominated by a single nominator, it is
     *    bounded only economically (all nominators are required to place a minimum stake).
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Staking.payout_nominator') === 'cb05b65f029237c2e87e8a38aba14c07a52c2988e4bea21cce8a16dea2e8c127'
    }

    /**
     *  Make one nominator's payout for one era.
     * 
     *  - `who` is the controller account of the nominator to pay out.
     *  - `era` may not be lower than one following the most recently paid era. If it is higher,
     *    then it indicates an instruction to skip the payout of all previous eras.
     *  - `validators` is the list of all validators that `who` had exposure to during `era`.
     *    If it is incomplete, then less than the full reward will be paid out.
     *    It must not exceed `MAX_NOMINATIONS`.
     * 
     *  WARNING: once an era is payed for a validator such validator can't claim the payout of
     *  previous era.
     * 
     *  WARNING: Incorrect arguments here can result in loss of payout. Be very careful.
     * 
     *  # <weight>
     *  - Number of storage read of `O(validators)`; `validators` is the argument of the call,
     *    and is bounded by `MAX_NOMINATIONS`.
     *  - Each storage read is `O(N)` size and decode complexity; `N` is the  maximum
     *    nominations that can be given to a single validator.
     *  - Computation complexity: `O(MAX_NOMINATIONS * logN)`; `MAX_NOMINATIONS` is the
     *    maximum number of validators that may be nominated by a single nominator, it is
     *    bounded only economically (all nominators are required to place a minimum stake).
     *  # </weight>
     */
    get asV1050(): {era: number, validators: [Uint8Array, number][]} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingPayoutStakersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.payout_stakers')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Pay out all the stakers behind a single validator for a single era.
     * 
     *  - `validator_stash` is the stash account of the validator. Their nominators, up to
     *    `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.
     *  - `era` may be any era between `[current_era - history_depth; current_era]`.
     * 
     *  The origin of this call must be _Signed_. Any account can call this function, even if
     *  it is not one of the stakers.
     * 
     *  This can only be called when [`EraElectionStatus`] is `Closed`.
     * 
     *  # <weight>
     *  - Time complexity: at most O(MaxNominatorRewardedPerValidator).
     *  - Contains a limited number of reads and writes.
     *  # </weight>
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('Staking.payout_stakers') === '1a09dc413ed4b8ce5cbcdc282b798636ca24268cca001e43fc92d892de3b6a5f'
    }

    /**
     *  Pay out all the stakers behind a single validator for a single era.
     * 
     *  - `validator_stash` is the stash account of the validator. Their nominators, up to
     *    `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.
     *  - `era` may be any era between `[current_era - history_depth; current_era]`.
     * 
     *  The origin of this call must be _Signed_. Any account can call this function, even if
     *  it is not one of the stakers.
     * 
     *  This can only be called when [`EraElectionStatus`] is `Closed`.
     * 
     *  # <weight>
     *  - Time complexity: at most O(MaxNominatorRewardedPerValidator).
     *  - Contains a limited number of reads and writes.
     *  # </weight>
     */
    get asV1058(): {validatorStash: Uint8Array, era: number} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingPayoutValidatorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.payout_validator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Make one validator's payout for one era.
     * 
     *  - `who` is the controller account of the validator to pay out.
     *  - `era` may not be lower than one following the most recently paid era. If it is higher,
     *    then it indicates an instruction to skip the payout of all previous eras.
     * 
     *  WARNING: once an era is payed for a validator such validator can't claim the payout of
     *  previous era.
     * 
     *  WARNING: Incorrect arguments here can result in loss of payout. Be very careful.
     * 
     *  # <weight>
     *  - Time complexity: O(1).
     *  - Contains a limited number of reads and writes.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Staking.payout_validator') === '39115a13c53f2b1968fdc266219c33cc8b971dddad3e2b3c0f3848136e2368b7'
    }

    /**
     *  Make one validator's payout for one era.
     * 
     *  - `who` is the controller account of the validator to pay out.
     *  - `era` may not be lower than one following the most recently paid era. If it is higher,
     *    then it indicates an instruction to skip the payout of all previous eras.
     * 
     *  WARNING: once an era is payed for a validator such validator can't claim the payout of
     *  previous era.
     * 
     *  WARNING: Incorrect arguments here can result in loss of payout. Be very careful.
     * 
     *  # <weight>
     *  - Time complexity: O(1).
     *  - Contains a limited number of reads and writes.
     *  # </weight>
     */
    get asV1050(): {era: number} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingReapStashCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.reap_stash')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove all data structure concerning a staker/stash once its balance is zero.
     *  This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone
     *  and the target `stash` must have no funds left.
     * 
     *  This can be called from any origin.
     * 
     *  - `stash`: The stash account to reap. Its balance must be zero.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Staking.reap_stash') === '7f6c53511d7cf7d5d6d53c9bd68762f88e130eef3cdaff66e227fd21c493b12c'
    }

    /**
     *  Remove all data structure concerning a staker/stash once its balance is zero.
     *  This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone
     *  and the target `stash` must have no funds left.
     * 
     *  This can be called from any origin.
     * 
     *  - `stash`: The stash account to reap. Its balance must be zero.
     */
    get asV1050(): {stash: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Remove all data structure concerning a staker/stash once its balance is zero.
     *  This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone
     *  and the target `stash` must have no funds left.
     * 
     *  This can be called from any origin.
     * 
     *  - `stash`: The stash account to reap. Its balance must be zero.
     * 
     *  # <weight>
     *  Complexity: O(S) where S is the number of slashing spans on the account.
     *  Base Weight: 75.94 + 2.396 * S µs
     *  DB Weight:
     *  - Reads: Stash Account, Bonded, Slashing Spans, Locks
     *  - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Stash Account, Locks
     *  - Writes Each: SpanSlash * S
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Staking.reap_stash') === '9d6e1257b3e6113f6cc99a4193f2fef8c6513a3d2a99ee686af751b5931f583b'
    }

    /**
     *  Remove all data structure concerning a staker/stash once its balance is zero.
     *  This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone
     *  and the target `stash` must have no funds left.
     * 
     *  This can be called from any origin.
     * 
     *  - `stash`: The stash account to reap. Its balance must be zero.
     * 
     *  # <weight>
     *  Complexity: O(S) where S is the number of slashing spans on the account.
     *  Base Weight: 75.94 + 2.396 * S µs
     *  DB Weight:
     *  - Reads: Stash Account, Bonded, Slashing Spans, Locks
     *  - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Stash Account, Locks
     *  - Writes Each: SpanSlash * S
     *  # </weight>
     */
    get asV2005(): {stash: Uint8Array, numSlashingSpans: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingRebondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.rebond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Rebond a portion of the stash scheduled to be unlocked.
     * 
     *  # <weight>
     *  - Time complexity: O(1). Bounded by `MAX_UNLOCKING_CHUNKS`.
     *  - Storage changes: Can't increase storage, only decrease it.
     *  # </weight>
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('Staking.rebond') === 'd13cb91c3f61510beece366e7f7c2d0705f01d70f9bc28721d2437cd210a3372'
    }

    /**
     *  Rebond a portion of the stash scheduled to be unlocked.
     * 
     *  # <weight>
     *  - Time complexity: O(1). Bounded by `MAX_UNLOCKING_CHUNKS`.
     *  - Storage changes: Can't increase storage, only decrease it.
     *  # </weight>
     */
    get asV1038(): {value: bigint} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingScaleValidatorCountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.scale_validator_count')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Scale up the ideal number of validators by a factor.
     * 
     *  The dispatch origin must be Root.
     * 
     *  # <weight>
     *  Base Weight: 1.717 µs
     *  Read/Write: Validator Count
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Staking.scale_validator_count') === 'd5f5b0d2128c7dec0e2681f604f51d1657af9bf5eb7c704432075cb4655e0065'
    }

    /**
     *  Scale up the ideal number of validators by a factor.
     * 
     *  The dispatch origin must be Root.
     * 
     *  # <weight>
     *  Base Weight: 1.717 µs
     *  Read/Write: Validator Count
     *  # </weight>
     */
    get asV2011(): {factor: number} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetControllerCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_controller')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  (Re-)set the controller of a stash.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains a limited number of reads.
     *  - Writes are limited to the `origin` account key.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.set_controller') === 'ea495be34eb0363f94ad384fd20004dfec26ca760dc2776b92541482a1719f1b'
    }

    /**
     *  (Re-)set the controller of a stash.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains a limited number of reads.
     *  - Writes are limited to the `origin` account key.
     *  # </weight>
     */
    get asV1020(): {controller: v1020.LookupSource} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  (Re-)set the controller of a stash.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains a limited number of reads.
     *  - Writes are limited to the `origin` account key.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Staking.set_controller') === 'bbdd03dc244a9d87deceeb91d015d7ef52746b99580b1474586c8699a77574e1'
    }

    /**
     *  (Re-)set the controller of a stash.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains a limited number of reads.
     *  - Writes are limited to the `origin` account key.
     *  # </weight>
     */
    get asV1050(): {controller: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  (Re-)set the controller of a stash.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains a limited number of reads.
     *  - Writes are limited to the `origin` account key.
     *  ----------
     *  Weight: O(1)
     *  DB Weight:
     *  - Read: Bonded, Ledger New Controller, Ledger Old Controller
     *  - Write: Bonded, Ledger New Controller, Ledger Old Controller
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Staking.set_controller') === '61b4041aa7366e679d366d2062deb643451b64015c330746395765e6865e5af2'
    }

    /**
     *  (Re-)set the controller of a stash.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains a limited number of reads.
     *  - Writes are limited to the `origin` account key.
     *  ----------
     *  Weight: O(1)
     *  DB Weight:
     *  - Read: Bonded, Ledger New Controller, Ledger Old Controller
     *  - Write: Bonded, Ledger New Controller, Ledger Old Controller
     *  # </weight>
     */
    get asV2028(): {controller: v2028.LookupSource} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * (Re-)set the controller of a stash.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     * # <weight>
     * - Independent of the arguments. Insignificant complexity.
     * - Contains a limited number of reads.
     * - Writes are limited to the `origin` account key.
     * ----------
     * Weight: O(1)
     * DB Weight:
     * - Read: Bonded, Ledger New Controller, Ledger Old Controller
     * - Write: Bonded, Ledger New Controller, Ledger Old Controller
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Staking.set_controller') === '81dc3a18eb19c7f258654686fb92e5bf48185191f2c59179a5b4626965fc66cd'
    }

    /**
     * (Re-)set the controller of a stash.
     * 
     * Effects will be felt at the beginning of the next era.
     * 
     * The dispatch origin for this call must be _Signed_ by the stash, not the controller.
     * 
     * # <weight>
     * - Independent of the arguments. Insignificant complexity.
     * - Contains a limited number of reads.
     * - Writes are limited to the `origin` account key.
     * ----------
     * Weight: O(1)
     * DB Weight:
     * - Read: Bonded, Ledger New Controller, Ledger Old Controller
     * - Write: Bonded, Ledger New Controller, Ledger Old Controller
     * # </weight>
     */
    get asV9111(): {controller: v9111.MultiAddress} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetHistoryDepthCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_history_depth')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set history_depth value.
     * 
     *  Origin must be root.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Staking.set_history_depth') === '88efc6276ab5276c247109411b05ffb19a6f06d269aa107ad53651bce4bbdf37'
    }

    /**
     *  Set history_depth value.
     * 
     *  Origin must be root.
     */
    get asV1050(): {newHistoryDepth: number} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set `HistoryDepth` value. This function will delete any history information
     *  when `HistoryDepth` is reduced.
     * 
     *  Parameters:
     *  - `new_history_depth`: The new history depth you would like to set.
     *  - `era_items_deleted`: The number of items that will be deleted by this dispatch.
     *     This should report all the storage items that will be deleted by clearing old
     *     era history. Needed to report an accurate weight for the dispatch. Trusted by
     *     `Root` to report an accurate number.
     * 
     *  Origin must be root.
     * 
     *  # <weight>
     *  - E: Number of history depths removed, i.e. 10 -> 7 = 3
     *  - Base Weight: 29.13 * E µs
     *  - DB Weight:
     *      - Reads: Current Era, History Depth
     *      - Writes: History Depth
     *      - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs
     *      - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake, ErasStartSessionIndex
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Staking.set_history_depth') === 'aff387362bca2e77192ffecea0e2882e4c2722db15c54e48ddded4e0dafe3446'
    }

    /**
     *  Set `HistoryDepth` value. This function will delete any history information
     *  when `HistoryDepth` is reduced.
     * 
     *  Parameters:
     *  - `new_history_depth`: The new history depth you would like to set.
     *  - `era_items_deleted`: The number of items that will be deleted by this dispatch.
     *     This should report all the storage items that will be deleted by clearing old
     *     era history. Needed to report an accurate weight for the dispatch. Trusted by
     *     `Root` to report an accurate number.
     * 
     *  Origin must be root.
     * 
     *  # <weight>
     *  - E: Number of history depths removed, i.e. 10 -> 7 = 3
     *  - Base Weight: 29.13 * E µs
     *  - DB Weight:
     *      - Reads: Current Era, History Depth
     *      - Writes: History Depth
     *      - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs
     *      - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake, ErasStartSessionIndex
     *  # </weight>
     */
    get asV2005(): {newHistoryDepth: number, eraItemsDeleted: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetInvulnerablesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_invulnerables')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the validators who cannot be slashed (if any).
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.set_invulnerables') === '29f7c09ae365d68c20c11ff1fed7e18b97efdc9301be013378b2df5277f1557d'
    }

    /**
     *  Set the validators who cannot be slashed (if any).
     */
    get asV1020(): {validators: Uint8Array[]} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set the validators who cannot be slashed (if any).
     * 
     *  The dispatch origin must be Root.
     * 
     *  # <weight>
     *  - O(V)
     *  - Write: Invulnerables
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Staking.set_invulnerables') === '994c18897efc6a5b0e11aeb337b6c718ad03cb0eb182a442fc74b9c80dd56313'
    }

    /**
     *  Set the validators who cannot be slashed (if any).
     * 
     *  The dispatch origin must be Root.
     * 
     *  # <weight>
     *  - O(V)
     *  - Write: Invulnerables
     *  # </weight>
     */
    get asV2024(): {invulnerables: Uint8Array[]} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetMinCommissionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_min_commission')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Sets the minimum amount of commission that each validators must maintain.
     * 
     * This call has lower privilege requirements than `set_staking_config` and can be called
     * by the `T::AdminOrigin`. Root can always call this.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Staking.set_min_commission') === '56549a8e90ef70438b73ca659a6b72776495b4c60df84463168d148f5c52d05d'
    }

    /**
     * Sets the minimum amount of commission that each validators must maintain.
     * 
     * This call has lower privilege requirements than `set_staking_config` and can be called
     * by the `T::AdminOrigin`. Root can always call this.
     */
    get asV9370(): {new: number} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetPayeeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_payee')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  (Re-)set the payment target for a controller.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains a limited number of reads.
     *  - Writes are limited to the `origin` account key.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.set_payee') === 'e882138b8d0371da862d058ac00f1def3ca0f71ab72eda3fbfb7d75b5fa16515'
    }

    /**
     *  (Re-)set the payment target for a controller.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains a limited number of reads.
     *  - Writes are limited to the `origin` account key.
     *  # </weight>
     */
    get asV1020(): {payee: v1020.RewardDestination} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetStakingConfigsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_staking_configs')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Update the various staking configurations .
     * 
     * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     * * `min_validator_bond`: The minimum active bond needed to be a validator.
     * * `max_nominator_count`: The max number of users who can be a nominator at once. When
     *   set to `None`, no limit is enforced.
     * * `max_validator_count`: The max number of users who can be a validator at once. When
     *   set to `None`, no limit is enforced.
     * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
     *   should be filled in order for the `chill_other` transaction to work.
     * * `min_commission`: The minimum amount of commission that each validators must maintain.
     *   This is checked only upon calling `validate`. Existing validators are not affected.
     * 
     * Origin must be Root to call this function.
     * 
     * NOTE: Existing nominators and validators will not be affected by this update.
     * to kick people under the new limits, `chill_other` should be called.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Staking.set_staking_configs') === '9e1f5e9f9780cc13e65cde698605d2dca408a256d9bde2c073d2edc7c4e8559e'
    }

    /**
     * Update the various staking configurations .
     * 
     * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     * * `min_validator_bond`: The minimum active bond needed to be a validator.
     * * `max_nominator_count`: The max number of users who can be a nominator at once. When
     *   set to `None`, no limit is enforced.
     * * `max_validator_count`: The max number of users who can be a validator at once. When
     *   set to `None`, no limit is enforced.
     * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
     *   should be filled in order for the `chill_other` transaction to work.
     * * `min_commission`: The minimum amount of commission that each validators must maintain.
     *   This is checked only upon calling `validate`. Existing validators are not affected.
     * 
     * Origin must be Root to call this function.
     * 
     * NOTE: Existing nominators and validators will not be affected by this update.
     * to kick people under the new limits, `chill_other` should be called.
     */
    get asV9160(): {minNominatorBond: bigint, minValidatorBond: bigint, maxNominatorCount: (number | undefined), maxValidatorCount: (number | undefined), chillThreshold: (number | undefined), minCommission: number} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Update the various staking configurations .
     * 
     * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     * * `min_validator_bond`: The minimum active bond needed to be a validator.
     * * `max_nominator_count`: The max number of users who can be a nominator at once. When
     *   set to `None`, no limit is enforced.
     * * `max_validator_count`: The max number of users who can be a validator at once. When
     *   set to `None`, no limit is enforced.
     * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
     *   should be filled in order for the `chill_other` transaction to work.
     * * `min_commission`: The minimum amount of commission that each validators must maintain.
     *   This is checked only upon calling `validate`. Existing validators are not affected.
     * 
     * Origin must be Root to call this function.
     * 
     * NOTE: Existing nominators and validators will not be affected by this update.
     * to kick people under the new limits, `chill_other` should be called.
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Staking.set_staking_configs') === '67189d3ca60a3305c1159ea1c7b2cfcbc749ef2c16f16b4c876daab793efdf86'
    }

    /**
     * Update the various staking configurations .
     * 
     * * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     * * `min_validator_bond`: The minimum active bond needed to be a validator.
     * * `max_nominator_count`: The max number of users who can be a nominator at once. When
     *   set to `None`, no limit is enforced.
     * * `max_validator_count`: The max number of users who can be a validator at once. When
     *   set to `None`, no limit is enforced.
     * * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
     *   should be filled in order for the `chill_other` transaction to work.
     * * `min_commission`: The minimum amount of commission that each validators must maintain.
     *   This is checked only upon calling `validate`. Existing validators are not affected.
     * 
     * Origin must be Root to call this function.
     * 
     * NOTE: Existing nominators and validators will not be affected by this update.
     * to kick people under the new limits, `chill_other` should be called.
     */
    get asV9180(): {minNominatorBond: v9180.ConfigOp, minValidatorBond: v9180.ConfigOp, maxNominatorCount: v9180.Type_243, maxValidatorCount: v9180.Type_243, chillThreshold: v9180.Type_244, minCommission: v9180.Type_245} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetStakingLimitsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_staking_limits')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Update the various staking limits this pallet.
     * 
     *  * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     *  * `min_validator_bond`: The minimum active bond needed to be a validator.
     *  * `max_nominator_count`: The max number of users who can be a nominator at once.
     *    When set to `None`, no limit is enforced.
     *  * `max_validator_count`: The max number of users who can be a validator at once.
     *    When set to `None`, no limit is enforced.
     * 
     *  Origin must be Root to call this function.
     * 
     *  NOTE: Existing nominators and validators will not be affected by this update.
     *  to kick people under the new limits, `chill_other` should be called.
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Staking.set_staking_limits') === 'a02f000e828a17cbd3d1b2a16e57d8f64445b5bc9f029b636cd5bfef98e0ebdd'
    }

    /**
     *  Update the various staking limits this pallet.
     * 
     *  * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     *  * `min_validator_bond`: The minimum active bond needed to be a validator.
     *  * `max_nominator_count`: The max number of users who can be a nominator at once.
     *    When set to `None`, no limit is enforced.
     *  * `max_validator_count`: The max number of users who can be a validator at once.
     *    When set to `None`, no limit is enforced.
     * 
     *  Origin must be Root to call this function.
     * 
     *  NOTE: Existing nominators and validators will not be affected by this update.
     *  to kick people under the new limits, `chill_other` should be called.
     */
    get asV9080(): {minNominatorBond: bigint, minValidatorBond: bigint, maxNominatorCount: (number | undefined), maxValidatorCount: (number | undefined), threshold: (number | undefined)} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSetValidatorCountCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.set_validator_count')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  The ideal number of validators.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.set_validator_count') === 'e648274eb741b1a8ab74c4583589c621e8391cd9122c0f7063e1e18c4af71912'
    }

    /**
     *  The ideal number of validators.
     */
    get asV1020(): {new: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSubmitElectionSolutionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.submit_election_solution')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Submit a phragmen result to the chain. If the solution:
     * 
     *  1. is valid.
     *  2. has a better score than a potentially existing solution on chain.
     * 
     *  then, it will be _put_ on chain.
     * 
     *  A solution consists of two pieces of data:
     * 
     *  1. `winners`: a flat vector of all the winners of the round.
     *  2. `assignments`: the compact version of an assignment vector that encodes the edge
     *     weights.
     * 
     *  Both of which may be computed using [`phragmen`], or any other algorithm.
     * 
     *  Additionally, the submitter must provide:
     * 
     *  - The `score` that they claim their solution has.
     * 
     *  Both validators and nominators will be represented by indices in the solution. The
     *  indices should respect the corresponding types ([`ValidatorIndex`] and
     *  [`NominatorIndex`]). Moreover, they should be valid when used to index into
     *  [`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the
     *  solution to be rejected. These two storage items are set during the election window and
     *  may be used to determine the indices.
     * 
     *  A solution is valid if:
     * 
     *  0. It is submitted when [`EraElectionStatus`] is `Open`.
     *  1. Its claimed score is equal to the score computed on-chain.
     *  2. Presents the correct number of winners.
     *  3. All indexes must be value according to the snapshot vectors. All edge values must
     *     also be correct and should not overflow the granularity of the ratio type (i.e. 256
     *     or billion).
     *  4. For each edge, all targets are actually nominated by the voter.
     *  5. Has correct self-votes.
     * 
     *  A solutions score is consisted of 3 parameters:
     * 
     *  1. `min { support.total }` for each support of a winner. This value should be maximized.
     *  2. `sum { support.total }` for each support of a winner. This value should be minimized.
     *  3. `sum { support.total^2 }` for each support of a winner. This value should be
     *     minimized (to ensure less variance)
     * 
     *  # <weight>
     *  E: number of edges. m: size of winner committee. n: number of nominators. d: edge degree
     *  (16 for now) v: number of on-chain validator candidates.
     * 
     *  NOTE: given a solution which is reduced, we can enable a new check the ensure `|E| < n +
     *  m`. We don't do this _yet_, but our offchain worker code executes it nonetheless.
     * 
     *  major steps (all done in `check_and_replace_solution`):
     * 
     *  - Storage: O(1) read `ElectionStatus`.
     *  - Storage: O(1) read `PhragmenScore`.
     *  - Storage: O(1) read `ValidatorCount`.
     *  - Storage: O(1) length read from `SnapshotValidators`.
     * 
     *  - Storage: O(v) reads of `AccountId` to fetch `snapshot_validators`.
     *  - Memory: O(m) iterations to map winner index to validator id.
     *  - Storage: O(n) reads `AccountId` to fetch `snapshot_nominators`.
     *  - Memory: O(n + m) reads to map index to `AccountId` for un-compact.
     * 
     *  - Storage: O(e) accountid reads from `Nomination` to read correct nominations.
     *  - Storage: O(e) calls into `slashable_balance_of_vote_weight` to convert ratio to staked.
     * 
     *  - Memory: build_support_map. O(e).
     *  - Memory: evaluate_support: O(E).
     * 
     *  - Storage: O(e) writes to `QueuedElected`.
     *  - Storage: O(1) write to `QueuedScore`
     * 
     *  The weight of this call is 1/10th of the blocks total weight.
     *  # </weight>
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('Staking.submit_election_solution') === '0fcf57513e393fea665f8bbf820e6cdabcffa91512cd89ebf40465912bc165dc'
    }

    /**
     *  Submit a phragmen result to the chain. If the solution:
     * 
     *  1. is valid.
     *  2. has a better score than a potentially existing solution on chain.
     * 
     *  then, it will be _put_ on chain.
     * 
     *  A solution consists of two pieces of data:
     * 
     *  1. `winners`: a flat vector of all the winners of the round.
     *  2. `assignments`: the compact version of an assignment vector that encodes the edge
     *     weights.
     * 
     *  Both of which may be computed using [`phragmen`], or any other algorithm.
     * 
     *  Additionally, the submitter must provide:
     * 
     *  - The `score` that they claim their solution has.
     * 
     *  Both validators and nominators will be represented by indices in the solution. The
     *  indices should respect the corresponding types ([`ValidatorIndex`] and
     *  [`NominatorIndex`]). Moreover, they should be valid when used to index into
     *  [`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the
     *  solution to be rejected. These two storage items are set during the election window and
     *  may be used to determine the indices.
     * 
     *  A solution is valid if:
     * 
     *  0. It is submitted when [`EraElectionStatus`] is `Open`.
     *  1. Its claimed score is equal to the score computed on-chain.
     *  2. Presents the correct number of winners.
     *  3. All indexes must be value according to the snapshot vectors. All edge values must
     *     also be correct and should not overflow the granularity of the ratio type (i.e. 256
     *     or billion).
     *  4. For each edge, all targets are actually nominated by the voter.
     *  5. Has correct self-votes.
     * 
     *  A solutions score is consisted of 3 parameters:
     * 
     *  1. `min { support.total }` for each support of a winner. This value should be maximized.
     *  2. `sum { support.total }` for each support of a winner. This value should be minimized.
     *  3. `sum { support.total^2 }` for each support of a winner. This value should be
     *     minimized (to ensure less variance)
     * 
     *  # <weight>
     *  E: number of edges. m: size of winner committee. n: number of nominators. d: edge degree
     *  (16 for now) v: number of on-chain validator candidates.
     * 
     *  NOTE: given a solution which is reduced, we can enable a new check the ensure `|E| < n +
     *  m`. We don't do this _yet_, but our offchain worker code executes it nonetheless.
     * 
     *  major steps (all done in `check_and_replace_solution`):
     * 
     *  - Storage: O(1) read `ElectionStatus`.
     *  - Storage: O(1) read `PhragmenScore`.
     *  - Storage: O(1) read `ValidatorCount`.
     *  - Storage: O(1) length read from `SnapshotValidators`.
     * 
     *  - Storage: O(v) reads of `AccountId` to fetch `snapshot_validators`.
     *  - Memory: O(m) iterations to map winner index to validator id.
     *  - Storage: O(n) reads `AccountId` to fetch `snapshot_nominators`.
     *  - Memory: O(n + m) reads to map index to `AccountId` for un-compact.
     * 
     *  - Storage: O(e) accountid reads from `Nomination` to read correct nominations.
     *  - Storage: O(e) calls into `slashable_balance_of_vote_weight` to convert ratio to staked.
     * 
     *  - Memory: build_support_map. O(e).
     *  - Memory: evaluate_support: O(E).
     * 
     *  - Storage: O(e) writes to `QueuedElected`.
     *  - Storage: O(1) write to `QueuedScore`
     * 
     *  The weight of this call is 1/10th of the blocks total weight.
     *  # </weight>
     */
    get asV1058(): {winners: number[], compactAssignments: v1058.CompactAssignments, score: bigint[], era: number} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Submit an election result to the chain. If the solution:
     * 
     *  1. is valid.
     *  2. has a better score than a potentially existing solution on chain.
     * 
     *  then, it will be _put_ on chain.
     * 
     *  A solution consists of two pieces of data:
     * 
     *  1. `winners`: a flat vector of all the winners of the round.
     *  2. `assignments`: the compact version of an assignment vector that encodes the edge
     *     weights.
     * 
     *  Both of which may be computed using _phragmen_, or any other algorithm.
     * 
     *  Additionally, the submitter must provide:
     * 
     *  - The `score` that they claim their solution has.
     * 
     *  Both validators and nominators will be represented by indices in the solution. The
     *  indices should respect the corresponding types ([`ValidatorIndex`] and
     *  [`NominatorIndex`]). Moreover, they should be valid when used to index into
     *  [`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the
     *  solution to be rejected. These two storage items are set during the election window and
     *  may be used to determine the indices.
     * 
     *  A solution is valid if:
     * 
     *  0. It is submitted when [`EraElectionStatus`] is `Open`.
     *  1. Its claimed score is equal to the score computed on-chain.
     *  2. Presents the correct number of winners.
     *  3. All indexes must be value according to the snapshot vectors. All edge values must
     *     also be correct and should not overflow the granularity of the ratio type (i.e. 256
     *     or billion).
     *  4. For each edge, all targets are actually nominated by the voter.
     *  5. Has correct self-votes.
     * 
     *  A solutions score is consisted of 3 parameters:
     * 
     *  1. `min { support.total }` for each support of a winner. This value should be maximized.
     *  2. `sum { support.total }` for each support of a winner. This value should be minimized.
     *  3. `sum { support.total^2 }` for each support of a winner. This value should be
     *     minimized (to ensure less variance)
     * 
     *  # <weight>
     *  See `crate::weight` module.
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Staking.submit_election_solution') === '8b1c317477ee5c931c588d2c57c8b26b50b96be73c3cc3ce8617e2e61e33f6e3'
    }

    /**
     *  Submit an election result to the chain. If the solution:
     * 
     *  1. is valid.
     *  2. has a better score than a potentially existing solution on chain.
     * 
     *  then, it will be _put_ on chain.
     * 
     *  A solution consists of two pieces of data:
     * 
     *  1. `winners`: a flat vector of all the winners of the round.
     *  2. `assignments`: the compact version of an assignment vector that encodes the edge
     *     weights.
     * 
     *  Both of which may be computed using _phragmen_, or any other algorithm.
     * 
     *  Additionally, the submitter must provide:
     * 
     *  - The `score` that they claim their solution has.
     * 
     *  Both validators and nominators will be represented by indices in the solution. The
     *  indices should respect the corresponding types ([`ValidatorIndex`] and
     *  [`NominatorIndex`]). Moreover, they should be valid when used to index into
     *  [`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the
     *  solution to be rejected. These two storage items are set during the election window and
     *  may be used to determine the indices.
     * 
     *  A solution is valid if:
     * 
     *  0. It is submitted when [`EraElectionStatus`] is `Open`.
     *  1. Its claimed score is equal to the score computed on-chain.
     *  2. Presents the correct number of winners.
     *  3. All indexes must be value according to the snapshot vectors. All edge values must
     *     also be correct and should not overflow the granularity of the ratio type (i.e. 256
     *     or billion).
     *  4. For each edge, all targets are actually nominated by the voter.
     *  5. Has correct self-votes.
     * 
     *  A solutions score is consisted of 3 parameters:
     * 
     *  1. `min { support.total }` for each support of a winner. This value should be maximized.
     *  2. `sum { support.total }` for each support of a winner. This value should be minimized.
     *  3. `sum { support.total^2 }` for each support of a winner. This value should be
     *     minimized (to ensure less variance)
     * 
     *  # <weight>
     *  See `crate::weight` module.
     *  # </weight>
     */
    get asV2005(): {winners: number[], compact: v2005.CompactAssignments, score: bigint[], era: number, size: v2005.ElectionSize} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Submit an election result to the chain. If the solution:
     * 
     *  1. is valid.
     *  2. has a better score than a potentially existing solution on chain.
     * 
     *  then, it will be _put_ on chain.
     * 
     *  A solution consists of two pieces of data:
     * 
     *  1. `winners`: a flat vector of all the winners of the round.
     *  2. `assignments`: the compact version of an assignment vector that encodes the edge
     *     weights.
     * 
     *  Both of which may be computed using _phragmen_, or any other algorithm.
     * 
     *  Additionally, the submitter must provide:
     * 
     *  - The `score` that they claim their solution has.
     * 
     *  Both validators and nominators will be represented by indices in the solution. The
     *  indices should respect the corresponding types ([`ValidatorIndex`] and
     *  [`NominatorIndex`]). Moreover, they should be valid when used to index into
     *  [`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the
     *  solution to be rejected. These two storage items are set during the election window and
     *  may be used to determine the indices.
     * 
     *  A solution is valid if:
     * 
     *  0. It is submitted when [`EraElectionStatus`] is `Open`.
     *  1. Its claimed score is equal to the score computed on-chain.
     *  2. Presents the correct number of winners.
     *  3. All indexes must be value according to the snapshot vectors. All edge values must
     *     also be correct and should not overflow the granularity of the ratio type (i.e. 256
     *     or billion).
     *  4. For each edge, all targets are actually nominated by the voter.
     *  5. Has correct self-votes.
     * 
     *  A solutions score is consisted of 3 parameters:
     * 
     *  1. `min { support.total }` for each support of a winner. This value should be maximized.
     *  2. `sum { support.total }` for each support of a winner. This value should be minimized.
     *  3. `sum { support.total^2 }` for each support of a winner. This value should be
     *     minimized (to ensure less variance)
     * 
     *  # <weight>
     *  See `crate::weight` module.
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Staking.submit_election_solution') === '7bb9cd5dd08bc49e4a101b60cee9cd8847a9d04c218e0e179244a55b2485fd62'
    }

    /**
     *  Submit an election result to the chain. If the solution:
     * 
     *  1. is valid.
     *  2. has a better score than a potentially existing solution on chain.
     * 
     *  then, it will be _put_ on chain.
     * 
     *  A solution consists of two pieces of data:
     * 
     *  1. `winners`: a flat vector of all the winners of the round.
     *  2. `assignments`: the compact version of an assignment vector that encodes the edge
     *     weights.
     * 
     *  Both of which may be computed using _phragmen_, or any other algorithm.
     * 
     *  Additionally, the submitter must provide:
     * 
     *  - The `score` that they claim their solution has.
     * 
     *  Both validators and nominators will be represented by indices in the solution. The
     *  indices should respect the corresponding types ([`ValidatorIndex`] and
     *  [`NominatorIndex`]). Moreover, they should be valid when used to index into
     *  [`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the
     *  solution to be rejected. These two storage items are set during the election window and
     *  may be used to determine the indices.
     * 
     *  A solution is valid if:
     * 
     *  0. It is submitted when [`EraElectionStatus`] is `Open`.
     *  1. Its claimed score is equal to the score computed on-chain.
     *  2. Presents the correct number of winners.
     *  3. All indexes must be value according to the snapshot vectors. All edge values must
     *     also be correct and should not overflow the granularity of the ratio type (i.e. 256
     *     or billion).
     *  4. For each edge, all targets are actually nominated by the voter.
     *  5. Has correct self-votes.
     * 
     *  A solutions score is consisted of 3 parameters:
     * 
     *  1. `min { support.total }` for each support of a winner. This value should be maximized.
     *  2. `sum { support.total }` for each support of a winner. This value should be minimized.
     *  3. `sum { support.total^2 }` for each support of a winner. This value should be
     *     minimized (to ensure less variance)
     * 
     *  # <weight>
     *  See `crate::weight` module.
     *  # </weight>
     */
    get asV2023(): {winners: number[], compact: v2023.CompactAssignments, score: bigint[], era: number, size: v2023.ElectionSize} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingSubmitElectionSolutionUnsignedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.submit_election_solution_unsigned')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unsigned version of `submit_election_solution`.
     * 
     *  Note that this must pass the [`ValidateUnsigned`] check which only allows transactions
     *  from the local node to be included. In other words, only the block author can include a
     *  transaction in the block.
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('Staking.submit_election_solution_unsigned') === '0fcf57513e393fea665f8bbf820e6cdabcffa91512cd89ebf40465912bc165dc'
    }

    /**
     *  Unsigned version of `submit_election_solution`.
     * 
     *  Note that this must pass the [`ValidateUnsigned`] check which only allows transactions
     *  from the local node to be included. In other words, only the block author can include a
     *  transaction in the block.
     */
    get asV1058(): {winners: number[], compactAssignments: v1058.CompactAssignments, score: bigint[], era: number} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Unsigned version of `submit_election_solution`.
     * 
     *  Note that this must pass the [`ValidateUnsigned`] check which only allows transactions
     *  from the local node to be included. In other words, only the block author can include a
     *  transaction in the block.
     * 
     *  # <weight>
     *  See `crate::weight` module.
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Staking.submit_election_solution_unsigned') === '8b1c317477ee5c931c588d2c57c8b26b50b96be73c3cc3ce8617e2e61e33f6e3'
    }

    /**
     *  Unsigned version of `submit_election_solution`.
     * 
     *  Note that this must pass the [`ValidateUnsigned`] check which only allows transactions
     *  from the local node to be included. In other words, only the block author can include a
     *  transaction in the block.
     * 
     *  # <weight>
     *  See `crate::weight` module.
     *  # </weight>
     */
    get asV2005(): {winners: number[], compact: v2005.CompactAssignments, score: bigint[], era: number, size: v2005.ElectionSize} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Unsigned version of `submit_election_solution`.
     * 
     *  Note that this must pass the [`ValidateUnsigned`] check which only allows transactions
     *  from the local node to be included. In other words, only the block author can include a
     *  transaction in the block.
     * 
     *  # <weight>
     *  See `crate::weight` module.
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Staking.submit_election_solution_unsigned') === '7bb9cd5dd08bc49e4a101b60cee9cd8847a9d04c218e0e179244a55b2485fd62'
    }

    /**
     *  Unsigned version of `submit_election_solution`.
     * 
     *  Note that this must pass the [`ValidateUnsigned`] check which only allows transactions
     *  from the local node to be included. In other words, only the block author can include a
     *  transaction in the block.
     * 
     *  # <weight>
     *  See `crate::weight` module.
     *  # </weight>
     */
    get asV2023(): {winners: number[], compact: v2023.CompactAssignments, score: bigint[], era: number, size: v2023.ElectionSize} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingUnbondCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.unbond')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Schedule a portion of the stash to be unlocked ready for transfer out after the bond
     *  period ends. If this leaves an amount actively bonded less than
     *  T::Currency::minimum_balance(), then it is increased to the full amount.
     * 
     *  Once the unlock period is done, you can call `withdraw_unbonded` to actually move
     *  the funds out of management ready for transfer.
     * 
     *  No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)
     *  can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need
     *  to be called first to remove some of the chunks (if possible).
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  See also [`Call::withdraw_unbonded`].
     * 
     *  # <weight>
     *  - Independent of the arguments. Limited but potentially exploitable complexity.
     *  - Contains a limited number of reads.
     *  - Each call (requires the remainder of the bonded balance to be above `minimum_balance`)
     *    will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage.
     *    The only way to clean the aforementioned storage item is also user-controlled via `withdraw_unbonded`.
     *  - One DB entry.
     *  </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.unbond') === 'd13cb91c3f61510beece366e7f7c2d0705f01d70f9bc28721d2437cd210a3372'
    }

    /**
     *  Schedule a portion of the stash to be unlocked ready for transfer out after the bond
     *  period ends. If this leaves an amount actively bonded less than
     *  T::Currency::minimum_balance(), then it is increased to the full amount.
     * 
     *  Once the unlock period is done, you can call `withdraw_unbonded` to actually move
     *  the funds out of management ready for transfer.
     * 
     *  No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)
     *  can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need
     *  to be called first to remove some of the chunks (if possible).
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  See also [`Call::withdraw_unbonded`].
     * 
     *  # <weight>
     *  - Independent of the arguments. Limited but potentially exploitable complexity.
     *  - Contains a limited number of reads.
     *  - Each call (requires the remainder of the bonded balance to be above `minimum_balance`)
     *    will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage.
     *    The only way to clean the aforementioned storage item is also user-controlled via `withdraw_unbonded`.
     *  - One DB entry.
     *  </weight>
     */
    get asV1020(): {value: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingUpdateStakingLimitsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.update_staking_limits')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Update the various staking limits this pallet.
     * 
     *  * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     *  * `min_validator_bond`: The minimum active bond needed to be a validator.
     *  * `max_nominator_count`: The max number of users who can be a nominator at once.
     *    When set to `None`, no limit is enforced.
     *  * `max_validator_count`: The max number of users who can be a validator at once.
     *    When set to `None`, no limit is enforced.
     * 
     *  Origin must be Root to call this function.
     * 
     *  NOTE: Existing nominators and validators will not be affected by this update.
     *  to kick people under the new limits, `chill_other` should be called.
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Staking.update_staking_limits') === '582590bc49123c2f7d407267c6a271c54d9e0f063168b049248ec5b1464339b1'
    }

    /**
     *  Update the various staking limits this pallet.
     * 
     *  * `min_nominator_bond`: The minimum active bond needed to be a nominator.
     *  * `min_validator_bond`: The minimum active bond needed to be a validator.
     *  * `max_nominator_count`: The max number of users who can be a nominator at once.
     *    When set to `None`, no limit is enforced.
     *  * `max_validator_count`: The max number of users who can be a validator at once.
     *    When set to `None`, no limit is enforced.
     * 
     *  Origin must be Root to call this function.
     * 
     *  NOTE: Existing nominators and validators will not be affected by this update.
     *  to kick people under the new limits, `chill_other` should be called.
     */
    get asV9050(): {minNominatorBond: bigint, minValidatorBond: bigint, maxNominatorCount: (number | undefined), maxValidatorCount: (number | undefined)} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingValidateCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.validate')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Declare the desire to validate for the origin controller.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains a limited number of reads.
     *  - Writes are limited to the `origin` account key.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.validate') === 'a03cfe73ae98f87de904386556fc6e78943abbd5d595884756c4155f8694e080'
    }

    /**
     *  Declare the desire to validate for the origin controller.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains a limited number of reads.
     *  - Writes are limited to the `origin` account key.
     *  # </weight>
     */
    get asV1020(): {prefs: v1020.ValidatorPrefs} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Declare the desire to validate for the origin controller.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *  And, it can be only called when [`EraElectionStatus`] is `Closed`.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains a limited number of reads.
     *  - Writes are limited to the `origin` account key.
     *  -----------
     *  Weight: O(1)
     *  DB Weight:
     *  - Read: Era Election Status, Ledger
     *  - Write: Nominators, Validators
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Staking.validate') === '2a662df491d449985438edd4d2e6899fd06beebbaa59e759713811ade38308bf'
    }

    /**
     *  Declare the desire to validate for the origin controller.
     * 
     *  Effects will be felt at the beginning of the next era.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *  And, it can be only called when [`EraElectionStatus`] is `Closed`.
     * 
     *  # <weight>
     *  - Independent of the arguments. Insignificant complexity.
     *  - Contains a limited number of reads.
     *  - Writes are limited to the `origin` account key.
     *  -----------
     *  Weight: O(1)
     *  DB Weight:
     *  - Read: Era Election Status, Ledger
     *  - Write: Nominators, Validators
     *  # </weight>
     */
    get asV2028(): {prefs: v2028.ValidatorPrefs} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class StakingWithdrawUnbondedCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Staking.withdraw_unbonded')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove any unlocked chunks from the `unlocking` queue from our management.
     * 
     *  This essentially frees up that balance to be used by the stash account to do
     *  whatever it wants.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  See also [`Call::unbond`].
     * 
     *  # <weight>
     *  - Could be dependent on the `origin` argument and how much `unlocking` chunks exist.
     *   It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is
     *   indirectly user-controlled. See [`unbond`] for more detail.
     *  - Contains a limited number of reads, yet the size of which could be large based on `ledger`.
     *  - Writes are limited to the `origin` account key.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Staking.withdraw_unbonded') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Remove any unlocked chunks from the `unlocking` queue from our management.
     * 
     *  This essentially frees up that balance to be used by the stash account to do
     *  whatever it wants.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     * 
     *  See also [`Call::unbond`].
     * 
     *  # <weight>
     *  - Could be dependent on the `origin` argument and how much `unlocking` chunks exist.
     *   It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is
     *   indirectly user-controlled. See [`unbond`] for more detail.
     *  - Contains a limited number of reads, yet the size of which could be large based on `ledger`.
     *  - Writes are limited to the `origin` account key.
     *  # </weight>
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Remove any unlocked chunks from the `unlocking` queue from our management.
     * 
     *  This essentially frees up that balance to be used by the stash account to do
     *  whatever it wants.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *  And, it can be only called when [`EraElectionStatus`] is `Closed`.
     * 
     *  Emits `Withdrawn`.
     * 
     *  See also [`Call::unbond`].
     * 
     *  # <weight>
     *  - Could be dependent on the `origin` argument and how much `unlocking` chunks exist.
     *   It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is
     *   indirectly user-controlled. See [`unbond`] for more detail.
     *  - Contains a limited number of reads, yet the size of which could be large based on `ledger`.
     *  - Writes are limited to the `origin` account key.
     *  ---------------
     *  Complexity O(S) where S is the number of slashing spans to remove
     *  Base Weight:
     *  Update: 50.52 + .028 * S µs
     *  - Reads: EraElectionStatus, Ledger, Current Era, Locks, [Origin Account]
     *  - Writes: [Origin Account], Locks, Ledger
     *  Kill: 79.41 + 2.366 * S µs
     *  - Reads: EraElectionStatus, Ledger, Current Era, Bonded, Slashing Spans, [Origin Account], Locks
     *  - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, [Origin Account], Locks
     *  - Writes Each: SpanSlash * S
     *  NOTE: Weight annotation is the kill scenario, we refund otherwise.
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Staking.withdraw_unbonded') === '6a7f80eeb74b237a907212a84c7fbc3bbfc8155b3decc30afb4c65c3bcb3f317'
    }

    /**
     *  Remove any unlocked chunks from the `unlocking` queue from our management.
     * 
     *  This essentially frees up that balance to be used by the stash account to do
     *  whatever it wants.
     * 
     *  The dispatch origin for this call must be _Signed_ by the controller, not the stash.
     *  And, it can be only called when [`EraElectionStatus`] is `Closed`.
     * 
     *  Emits `Withdrawn`.
     * 
     *  See also [`Call::unbond`].
     * 
     *  # <weight>
     *  - Could be dependent on the `origin` argument and how much `unlocking` chunks exist.
     *   It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is
     *   indirectly user-controlled. See [`unbond`] for more detail.
     *  - Contains a limited number of reads, yet the size of which could be large based on `ledger`.
     *  - Writes are limited to the `origin` account key.
     *  ---------------
     *  Complexity O(S) where S is the number of slashing spans to remove
     *  Base Weight:
     *  Update: 50.52 + .028 * S µs
     *  - Reads: EraElectionStatus, Ledger, Current Era, Locks, [Origin Account]
     *  - Writes: [Origin Account], Locks, Ledger
     *  Kill: 79.41 + 2.366 * S µs
     *  - Reads: EraElectionStatus, Ledger, Current Era, Bonded, Slashing Spans, [Origin Account], Locks
     *  - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, [Origin Account], Locks
     *  - Writes Each: SpanSlash * S
     *  NOTE: Weight annotation is the kill scenario, we refund otherwise.
     *  # </weight>
     */
    get asV2005(): {numSlashingSpans: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class SudoSetKeyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Sudo.set_key')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Sudo.set_key') === '99fb23ead3148119615841917828d5eba57f475f320525e9e8d9e277d2d8d585'
    }

    /**
     *  Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get asV1020(): {new: v1020.LookupSource} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class SudoSudoCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Sudo.sudo')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Unknown weight of derivative `proposal` execution.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === 'd293bf72755f74e0a3c41405c24364f91ece4ae9f9232bac11a6f5affc83e757'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Unknown weight of derivative `proposal` execution.
     *  # </weight>
     */
    get asV1020(): {proposal: v1020.Proposal} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Unknown weight of derivative `proposal` execution.
     *  # </weight>
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === '8498bfdc84d1625d23edbd51ffcb13e409261b8fc8d521a5baf18e38a71d11bd'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Unknown weight of derivative `proposal` execution.
     *  # </weight>
     */
    get asV1022(): {proposal: v1022.Proposal} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Unknown weight of derivative `proposal` execution.
     *  # </weight>
     */
    get isV1024(): boolean {
        return this._chain.getCallHash('Sudo.sudo') === 'a063f98c85fa3aa21741ef693e7db4691f62d07662dafe2cfcdf078fd1183eff'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Root` origin.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Unknown weight of derivative `proposal` execution.
     *  # </weight>
     */
    get asV1024(): {proposal: v1024.Proposal} {
        assert(this.isV1024)
        return this._chain.decodeCall(this.call)
    }
}

export class SudoSudoAsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Sudo.sudo_as')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Unknown weight of derivative `proposal` execution.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === 'c1ad2313e4d70e9c09dea57f6346dc2b54fddbf223f9f4621cd529514383491c'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Unknown weight of derivative `proposal` execution.
     *  # </weight>
     */
    get asV1020(): {who: v1020.LookupSource, proposal: v1020.Proposal} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Unknown weight of derivative `proposal` execution.
     *  # </weight>
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '5ec202185bfbfae7eebe3b27fe667d33573f65dffe76c6aa2344e96cb721c311'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Unknown weight of derivative `proposal` execution.
     *  # </weight>
     */
    get asV1022(): {who: v1022.LookupSource, proposal: v1022.Proposal} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Unknown weight of derivative `proposal` execution.
     *  # </weight>
     */
    get isV1024(): boolean {
        return this._chain.getCallHash('Sudo.sudo_as') === '72cf84ba227d58b7617b95f9e9eaa9f01399a4aecf98cd04900938cf40df78db'
    }

    /**
     *  Authenticates the sudo key and dispatches a function call with `Signed` origin from
     *  a given account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB write (event).
     *  - Unknown weight of derivative `proposal` execution.
     *  # </weight>
     */
    get asV1024(): {who: v1024.LookupSource, proposal: v1024.Proposal} {
        assert(this.isV1024)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemFillBlockCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.fill_block')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  A big dispatch that will disallow any other transaction to be included.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('System.fill_block') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  A big dispatch that will disallow any other transaction to be included.
     */
    get asV1020(): null {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  A dispatch that will fill the block weight up to the given ratio.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('System.fill_block') === '41c1841312db092642508be699e4a3f54d52efe2dcaa8101ca9518398fb70c49'
    }

    /**
     *  A dispatch that will fill the block weight up to the given ratio.
     */
    get asV1050(): {ratio: number} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemKillPrefixCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.kill_prefix')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Kill all storage items with a key that starts with the given prefix.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('System.kill_prefix') === 'f848fd0e0542703f896e3ab1f91d388f8f7b19f44db5b001bb6bd5c3034ce972'
    }

    /**
     *  Kill all storage items with a key that starts with the given prefix.
     */
    get asV1020(): {prefix: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Kill all storage items with a key that starts with the given prefix.
     * 
     *  **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     *  the prefix we are removing to accurately calculate the weight of this function.
     * 
     *  # <weight>
     *  - `O(P)` where `P` amount of keys with prefix `prefix`
     *  - `P` storage deletions.
     *  - Base Weight: 0.834 * P µs
     *  - Writes: Number of subkeys + 1
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('System.kill_prefix') === 'dfbadd42bee8b18fc81cf78683511061181cffbf7a8ebfd3e5719c389b373d93'
    }

    /**
     *  Kill all storage items with a key that starts with the given prefix.
     * 
     *  **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     *  the prefix we are removing to accurately calculate the weight of this function.
     * 
     *  # <weight>
     *  - `O(P)` where `P` amount of keys with prefix `prefix`
     *  - `P` storage deletions.
     *  - Base Weight: 0.834 * P µs
     *  - Writes: Number of subkeys + 1
     *  # </weight>
     */
    get asV2005(): {prefix: Uint8Array, subkeys: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemKillStorageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.kill_storage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Kill some items from storage.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('System.kill_storage') === 'eac21dc14e927c003d9c634fb019d04128f71f8529d2914b10a56b85289c2c11'
    }

    /**
     *  Kill some items from storage.
     */
    get asV1020(): {keys: Uint8Array[]} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemMigrateAccountsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.migrate_accounts')
        this._chain = ctx._chain
        this.call = call
    }

    get isV1054(): boolean {
        return this._chain.getCallHash('System.migrate_accounts') === 'f991968966792a125cac7c888dc7194239a215e624de7c15edbe7afe0e683c8a'
    }

    get asV1054(): {accounts: Uint8Array[]} {
        assert(this.isV1054)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemRemarkCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.remark')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Make some on-chain remark.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('System.remark') === 'f4e9b5b7572eeae92978087ece9b4f57cb5cab4f16baf5625bb9ec4a432bad63'
    }

    /**
     *  Make some on-chain remark.
     */
    get asV1020(): {remark: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemRemarkWithEventCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.remark_with_event')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Make some on-chain remark and emit event.
     * 
     *  # <weight>
     *  - `O(b)` where b is the length of the remark.
     *  - 1 event.
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('System.remark_with_event') === 'f4e9b5b7572eeae92978087ece9b4f57cb5cab4f16baf5625bb9ec4a432bad63'
    }

    /**
     *  Make some on-chain remark and emit event.
     * 
     *  # <weight>
     *  - `O(b)` where b is the length of the remark.
     *  - 1 event.
     *  # </weight>
     */
    get asV2030(): {remark: Uint8Array} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetChangesTrieConfigCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_changes_trie_config')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the new changes trie configuration.
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('System.set_changes_trie_config') === 'ced137e2f8792ce87e1f2b20f97e1de9a31001f9c44069dc6e73b9e4c061c311'
    }

    /**
     *  Set the new changes trie configuration.
     */
    get asV1042(): {changesTrieConfig: (v1042.ChangesTrieConfiguration | undefined)} {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetCodeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_code')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the new code.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('System.set_code') === 'a0485098883557016016877c7c58078862acbbb38b72907c9686542aaa34fce8'
    }

    /**
     *  Set the new code.
     */
    get asV1020(): {new: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set the new runtime code.
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('System.set_code') === '7bf3d4785d9be7a4872f39cbd3702a66e16f7ee01e4446fb4a05624dc0ec4c93'
    }

    /**
     *  Set the new runtime code.
     */
    get asV1042(): {code: Uint8Array} {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetCodeWithoutChecksCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_code_without_checks')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the new runtime code without doing any checks of the given `code`.
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('System.set_code_without_checks') === '7bf3d4785d9be7a4872f39cbd3702a66e16f7ee01e4446fb4a05624dc0ec4c93'
    }

    /**
     *  Set the new runtime code without doing any checks of the given `code`.
     */
    get asV1042(): {code: Uint8Array} {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetHeapPagesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_heap_pages')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the number of pages in the WebAssembly environment's heap.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('System.set_heap_pages') === '130172e47c5e517627712b4d084768b98489d920284223ea8ef9c462339b5808'
    }

    /**
     *  Set the number of pages in the WebAssembly environment's heap.
     */
    get asV1020(): {pages: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSetStorageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.set_storage')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set some items of storage.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('System.set_storage') === 'a4fb507615d69849afb1b2ee654006f9be48bb6e960a4674624d6e46e4382083'
    }

    /**
     *  Set some items of storage.
     */
    get asV1020(): {items: [Uint8Array, Uint8Array][]} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class SystemSuicideCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'System.suicide')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Kill the sending account, assuming there are no references outstanding and the composite
     *  data is equal to its default value.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('System.suicide') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Kill the sending account, assuming there are no references outstanding and the composite
     *  data is equal to its default value.
     */
    get asV1050(): null {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeCloseCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.close')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  May be called by any signed account after the voting duration has ended in order to
     *  finish voting and close the proposal.
     * 
     *  Abstentions are counted as rejections unless there is a prime member set and the prime
     *  member cast an approval.
     * 
     *  - the weight of `proposal` preimage.
     *  - up to three events deposited.
     *  - one read, two removals, one mutation. (plus three static reads.)
     *  - computation and i/o `O(P + L + M)` where:
     *    - `M` is number of members,
     *    - `P` is number of active proposals,
     *    - `L` is the encoded length of `proposal` preimage.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.close') === 'fd20d3b556f7bbf9b7c10df80be10c41ffa28074b5360241d2572f30ee3e445e'
    }

    /**
     *  May be called by any signed account after the voting duration has ended in order to
     *  finish voting and close the proposal.
     * 
     *  Abstentions are counted as rejections unless there is a prime member set and the prime
     *  member cast an approval.
     * 
     *  - the weight of `proposal` preimage.
     *  - up to three events deposited.
     *  - one read, two removals, one mutation. (plus three static reads.)
     *  - computation and i/o `O(P + L + M)` where:
     *    - `M` is number of members,
     *    - `P` is number of active proposals,
     *    - `L` is the encoded length of `proposal` preimage.
     */
    get asV1050(): {proposal: Uint8Array, index: number} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     *  May be called by any signed account in order to finish voting and close the proposal.
     * 
     *  If called before the end of the voting period it will only close the vote if it is
     *  has enough votes to be approved or disapproved.
     * 
     *  If called after the end of the voting period abstentions are counted as rejections
     *  unless there is a prime member set and the prime member cast an approval.
     * 
     *  + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.
     *  + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     *                    `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1 + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - `P1` is the complexity of `proposal` preimage.
     *    - `P2` is proposal-count (code-bounded)
     *  - DB:
     *   - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *   - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)
     *   - any mutations done while executing `proposal` (`P1`)
     *  - up to 3 events
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.close') === '45a5978a11ceb5a8b2c51f7152abaa939cd8bd4bcdc5e1162029cedba4b598ea'
    }

    /**
     *  Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     *  May be called by any signed account in order to finish voting and close the proposal.
     * 
     *  If called before the end of the voting period it will only close the vote if it is
     *  has enough votes to be approved or disapproved.
     * 
     *  If called after the end of the voting period abstentions are counted as rejections
     *  unless there is a prime member set and the prime member cast an approval.
     * 
     *  + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.
     *  + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     *                    `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1 + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - `P1` is the complexity of `proposal` preimage.
     *    - `P2` is proposal-count (code-bounded)
     *  - DB:
     *   - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *   - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)
     *   - any mutations done while executing `proposal` (`P1`)
     *  - up to 3 events
     *  # </weight>
     */
    get asV2005(): {proposalHash: Uint8Array, index: number, proposalWeightBound: bigint, lengthBound: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.close') === '683905378cce329de8c5e9460bd36984188fb48a39207d985ea43cb10bd1eb81'
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get asV9291(): {proposalHash: Uint8Array, index: number, proposalWeightBound: bigint, lengthBound: number} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.close') === 'a88911953f51bddf0f0aeafa7caa7ca904d30cdb24f940ff177d2acf7088d3bd'
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get asV9320(): {proposalHash: Uint8Array, index: number, proposalWeightBound: v9320.Weight, lengthBound: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeCloseOldWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.close_old_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.close_old_weight') === '45a5978a11ceb5a8b2c51f7152abaa939cd8bd4bcdc5e1162029cedba4b598ea'
    }

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     * 
     * May be called by any signed account in order to finish voting and close the proposal.
     * 
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     * 
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     * 
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     * 
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1 + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - `P1` is the complexity of `proposal` preimage.
     *   - `P2` is proposal-count (code-bounded)
     * - DB:
     *  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)
     *  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec
     *    `O(P2)`)
     *  - any mutations done while executing `proposal` (`P1`)
     * - up to 3 events
     * # </weight>
     */
    get asV9320(): {proposalHash: Uint8Array, index: number, proposalWeightBound: bigint, lengthBound: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeDisapproveProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.disapprove_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Disapprove a proposal, close, and remove it from the system, regardless of its current state.
     * 
     *  Must be called by the Root origin.
     * 
     *  Parameters:
     *  * `proposal_hash`: The hash of the proposal that should be disapproved.
     * 
     *  # <weight>
     *  Complexity: O(P) where P is the number of max proposals
     *  Base Weight: .49 * P
     *  DB Weight:
     *  * Reads: Proposals
     *  * Writes: Voting, Proposals, ProposalOf
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.disapprove_proposal') === 'b8668610145a6851ad2d5b7dd4bfc15e29402d9a8558401ab955896007f866a5'
    }

    /**
     *  Disapprove a proposal, close, and remove it from the system, regardless of its current state.
     * 
     *  Must be called by the Root origin.
     * 
     *  Parameters:
     *  * `proposal_hash`: The hash of the proposal that should be disapproved.
     * 
     *  # <weight>
     *  Complexity: O(P) where P is the number of max proposals
     *  Base Weight: .49 * P
     *  DB Weight:
     *  * Reads: Proposals
     *  * Writes: Voting, Proposals, ProposalOf
     *  # </weight>
     */
    get asV2005(): {proposalHash: Uint8Array} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeExecuteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.execute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'd293bf72755f74e0a3c41405c24364f91ece4ae9f9232bac11a6f5affc83e757'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1020(): {proposal: v1020.Proposal} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '8498bfdc84d1625d23edbd51ffcb13e409261b8fc8d521a5baf18e38a71d11bd'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1022(): {proposal: v1022.Proposal} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1024(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'a063f98c85fa3aa21741ef693e7db4691f62d07662dafe2cfcdf078fd1183eff'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1024(): {proposal: v1024.Proposal} {
        assert(this.isV1024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1027(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '103c4ad4666083c5f76b2f94904c2baa1c2bf6791b8971bf7b5b6b11aa6ebfab'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1027(): {proposal: v1027.Proposal} {
        assert(this.isV1027)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1029(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '8f21ad8522bbc5f1d4f24c87782bb355026326f8223cccbeebb869d83aea5b85'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1029(): {proposal: v1029.Proposal} {
        assert(this.isV1029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '77c63f975f5c52c5687dae4c3c2fc5c50fca80036f94afdb29c46eca336016d5'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1030(): {proposal: v1030.Proposal} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1031(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'c019f5435be92b6c3c5aeb58c6fb52c15d46af90b84c35cb4058c97a3f185529'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1031(): {proposal: v1031.Proposal} {
        assert(this.isV1031)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1032(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '83dba0323feced5fb65e2f27a5cbb59b6a2f25bc3a0c48894cb9758404fe7968'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1032(): {proposal: v1032.Proposal} {
        assert(this.isV1032)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'abc3dca26b519e737066372b4701b35d06178df1e6817fcd308603f9f9981d27'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1038(): {proposal: v1038.Proposal} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1039(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '61fc47099099d3379e246ea412b5feb511714e8a678be8e7b9e24a2de774725d'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1039(): {proposal: v1039.Proposal} {
        assert(this.isV1039)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'ea230917623dcc803b4d219f89a7bd6d823cfd79d0ee1d8cd6a1a8ca8bbfdfed'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1040(): {proposal: v1040.Proposal} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '0f592c1c871cb7fc886d43c723f368759280e5a052de98a40096a0597cf34f12'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1042(): {proposal: v1042.Proposal} {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '15b95215355f7f34ae33745f598c387a1777391e8cbf8e7bd02b0660a63c66c7'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1050(): {proposal: v1050.Proposal} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1054(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'a86c1368b80f82d44ee1ebbb492e5293feb000bff5b32ad24f5c26d77057a539'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1054(): {proposal: v1054.Proposal} {
        assert(this.isV1054)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '9e22cb75a4d5393444662e9a4e942e2ab55987ab5e252989c01b568c4bd74109'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1055(): {proposal: v1055.Proposal} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '8a0db224817dca4f0f13046927b7f87c45016d4da748016f536d2a2a1899bc56'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1058(): {proposal: v1058.Proposal} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get isV1062(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '8614694c9bfa8d1acc7375a4a0e16f756a192a1ece3799da4065f5e72b82e96b'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     */
    get asV1062(): {proposal: v1062.Proposal} {
        assert(this.isV1062)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'a458cb574cf1d9cc0803104e1ca4f9380d67b4f8445191e6a4012f781605b15a'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2005(): {proposal: v2005.Proposal, lengthBound: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'fbf4b1d601c522a0e36ac8fae3ce1d2df578b4a562fa505aa2a93a11dab6532a'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2007(): {proposal: v2007.Proposal, lengthBound: number} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '40f6d8225192125c7d91a4bdb5dd49454bf91ac50421e32dd873bdb4acf6bbba'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2011(): {proposal: v2011.Proposal, lengthBound: number} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'aa6eab46863da4f4a9b4b1e37a2a52d192696563013a8e13c695b08e9cf30e77'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2013(): {proposal: v2013.Proposal, lengthBound: number} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '30017151b285b611e4242425e79c3758adbf0fff7fa580e0d5d7268c50dc27fb'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2015(): {proposal: v2015.Proposal, lengthBound: number} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '02ce2076feb62e6dc21a509e31b7ccaf5d44a2a39db203e3f2319528631443e9'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2022(): {proposal: v2022.Proposal, lengthBound: number} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'f46a3a2b6ddd28de79e6d129c654d456b3e1562d9452e4af2a7576fee30ca184'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2023(): {proposal: v2023.Proposal, lengthBound: number} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'fb31fdf1647e9c002f7fcc4121d45abea44505b3a5a48b6acafcfd34466e4920'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2024(): {proposal: v2024.Proposal, lengthBound: number} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '4e98dfe08733f7543c42bc6c939fdfbc9a328d1c45ff30c60e75f9e1dd9f8dfb'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2025(): {proposal: v2025.Proposal, lengthBound: number} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '85a9e0893c8558a38f60719d19c0e4240a6a3bbffaa6262f1da58e9b5101fa84'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2026(): {proposal: v2026.Proposal, lengthBound: number} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '2da779f50394a5b3fe50376f509407030422e09390f8f5b5ced47a7950abdedc'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2028(): {proposal: v2028.Proposal, lengthBound: number} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'c4c44a2562f0f9fa441167e2b0acc08f50d21c8b1b72171b4f0fe79eebdc66ea'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2029(): {proposal: v2029.Proposal, lengthBound: number} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'f9d0a73d4ef17b0f75d455d944edcbed8d1027b7d147cc146745877b1fd6b099'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV2030(): {proposal: v2030.Proposal, lengthBound: number} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '7294d1c45e4f8896b7807aca5fabbbe261da58896bfab8239f1808866b91f5be'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9010(): {proposal: v9010.Proposal, lengthBound: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'bef0f01aca31de0fa2637790f0cda4144b314d53e017159c69f3301385084833'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9030(): {proposal: v9030.Proposal, lengthBound: number} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '47011dd27a24a8cfa1287f2e276dd4c6f9a2b65f4e461278f1403d6df1754bb9'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9040(): {proposal: v9040.Proposal, lengthBound: number} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '894f34477e8f37516ed613128f63ffcaf1f1b11c87f9b41615fd51b050037980'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9050(): {proposal: v9050.Proposal, lengthBound: number} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '4f563ee3669dd563f135e9b6e425a078e3d5a813f60a564757b90063672d9309'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9080(): {proposal: v9080.Proposal, lengthBound: number} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '60dcf6426c033719d13484747b16687ef11066fc415b4d5bbe21bad3a294535a'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9090(): {proposal: v9090.Proposal, lengthBound: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '1cea735c8b9d18b31168c72901781f38bc6e93e1962e3dec4e3cfe8d7e6c2d90'
    }

    /**
     *  Dispatch a proposal from a member using the `Member` origin.
     * 
     *  Origin must be a member of the collective.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`
     *  - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     *  - 1 event
     *  # </weight>
     */
    get asV9100(): {proposal: v9100.Proposal, lengthBound: number} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '6ea0aeb4746df6cf971cd3daa3308d0ae9c873b9642c1e08926900a90f2de1af'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9111(): {proposal: v9111.Call, lengthBound: number} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '04664c341aecc03c7939cc84768c64dcd545e1d5277f6f8b2438cbcf098a7c70'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9122(): {proposal: v9122.Call, lengthBound: number} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'e731bfbe7a98093d91e1789d0969f1279046f02d7f3c13083a7591db3c4a581c'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9130(): {proposal: v9130.Call, lengthBound: number} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'c78119823f6fb94f49eebca2f9f892c3297144646e2a002f31c72cd7f2650f73'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9160(): {proposal: v9160.Call, lengthBound: number} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'fee3072f2f80e0b9f4997c37808ec64ac1528cd907b6ac3fbfbf02bf9dc0590f'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9170(): {proposal: v9170.Call, lengthBound: number} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '12f769688e4882e2f9782debf5b29ed428b78eac264683ccf373bd781a49c82d'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9180(): {proposal: v9180.Call, lengthBound: number} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'b6d471ea5c241b983a0a0e6ed7225121c9257b38ee1e370dd86bd3afd59ef148'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9190(): {proposal: v9190.Call, lengthBound: number} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '51454c962412d286c114ad11eb9d8059eeec294977285e508acf9c2413de48fe'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9220(): {proposal: v9220.Call, lengthBound: number} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '6448117ca202ff3d8c91097dba8e20a3f10650fc7222efe203f9f15c5d0c1f9f'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9230(): {proposal: v9230.Call, lengthBound: number} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '19b3887cab624d57389c8560c3901c5b9e956da8f3c405c30c8381d303a59c09'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9250(): {proposal: v9250.Call, lengthBound: number} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '8a8d5d325384eee66d0fdd23ff058ff574f550de0cb07f33d190f37d596f5b82'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9271(): {proposal: v9271.Call, lengthBound: number} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '2ae4824124910cb5d89e5f617ca87a763c5dfc3e44fef23506d7c5e5b171707e'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9291(): {proposal: v9291.Call, lengthBound: number} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'a695717a491a5cfe8b100d51a5eb5307234afcaba60440a290525ea938fb3f4b'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9300(): {proposal: v9300.Call, lengthBound: number} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '29581b33367202e06895de163f76752c2c2f4ed6903da981903ea2e995db9caa'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9320(): {proposal: v9320.Call, lengthBound: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === 'b71ddcdda6fdbd88f8e13bb78a4a7e5bf555f6ba167c039677aacdb8f29d2fab'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9340(): {proposal: v9340.Call, lengthBound: number} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '1aa6bf700a490e8b1941e0647c1c2643c2de2f958591b81369b2e16f3d511163'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9350(): {proposal: v9350.Call, lengthBound: number} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.execute') === '801aed297d7f67a9f5896061fe8366bdc91c6ec8aa4df7efe643a9a7a4981e8e'
    }

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     * 
     * Origin must be a member of the collective.
     * 
     * # <weight>
     * ## Weight
     * - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching
     *   `proposal`
     * - DB: 1 read (codec `O(M)`) + DB access of `proposal`
     * - 1 event
     * # </weight>
     */
    get asV9370(): {proposal: v9370.Call, lengthBound: number} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeProposeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.propose')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'b8ffa1d1417679324bb008beaf891bbac5aab9c65683a7f7fe19e5bd880540ad'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1020(): {threshold: number, proposal: v1020.Proposal} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1022(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '0733f77354596f9c073a9166590f01875ae078ec750297178588ac18ebccfcd1'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1022(): {threshold: number, proposal: v1022.Proposal} {
        assert(this.isV1022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1024(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'f2373a84f143f19aa4ceb0f0ffa356d36e64a8ee8781cabbc4fd5bb7e39a1086'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1024(): {threshold: number, proposal: v1024.Proposal} {
        assert(this.isV1024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1027(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '9740f05ac462f641fd3f66ba27922f4c616a30ba2a30f5f3dee3319b7e8d4c42'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1027(): {threshold: number, proposal: v1027.Proposal} {
        assert(this.isV1027)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1029(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'aa7229741a014afe80df7bace305287fba001ff889d95c8ef481eaf092b0aeb0'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1029(): {threshold: number, proposal: v1029.Proposal} {
        assert(this.isV1029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1030(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'bd750cd6777e89f5c24fa186b138a5167c0c5703bc2f880fb061d2ffcaac7485'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1030(): {threshold: number, proposal: v1030.Proposal} {
        assert(this.isV1030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1031(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'ab2408e2e9f60521f8ced9cfb8986b6b0a5224716ec6036b472bee571ffb20d3'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1031(): {threshold: number, proposal: v1031.Proposal} {
        assert(this.isV1031)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1032(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '67c2fe1dfdbe4e0c3524f6bbdb5cfa78a3180250fdc9b90bd23d1d6fdd106170'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1032(): {threshold: number, proposal: v1032.Proposal} {
        assert(this.isV1032)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '34a8413001e080189c80438ed529b307dc454b4fff47f83a74fcce9abb0f16d8'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1038(): {threshold: number, proposal: v1038.Proposal} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1039(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '6b5faf71789e3dff5d5ba6b345526dbd1c2008916dec8b4375a5ae8abd33a0ff'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1039(): {threshold: number, proposal: v1039.Proposal} {
        assert(this.isV1039)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '2a426d9da44cb5bcab3c3334ae315836a9a46bbdffe0472c278b0ad2e7b65c47'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1040(): {threshold: number, proposal: v1040.Proposal} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '4dac6093a9fda8aa08e86a0a3d10b8bd4d7bed3ef08753c90140de37d5f804c3'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1042(): {threshold: number, proposal: v1042.Proposal} {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '360d54bbd3add22d251b1e7b5a8159bf8b7805a44bad6ffc4f495ffb37a29aa3'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1050(): {threshold: number, proposal: v1050.Proposal} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1054(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'b7ed71d5de49cf512c52c5534643f51df2a0ed3e1ba35cb45f1302ca70d3d1dd'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1054(): {threshold: number, proposal: v1054.Proposal} {
        assert(this.isV1054)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'c9d83d3d10bfd5ef50ad610885c72863a5802065b8fd28a4f7c6c686932329f8'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1055(): {threshold: number, proposal: v1055.Proposal} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '39d267dc2baec569e413fbab4230df769aef9c59980ff208e266e1bac3c0ccb8'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1058(): {threshold: number, proposal: v1058.Proposal} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get isV1062(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'f092bdb8159b1e16f939a8ac6bd7d66fd0b919a8097ab17e1e1352da914e8cf4'
    }

    /**
     *  # <weight>
     *  - Bounded storage reads and writes.
     *  - Argument `threshold` has bearing on weight.
     *  # </weight>
     */
    get asV1062(): {threshold: number, proposal: v1062.Proposal} {
        assert(this.isV1062)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '0211294356c41641323a2e0eb77df577362fdde27f14467e1f5e1734c321fa6b'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2005(): {threshold: number, proposal: v2005.Proposal, lengthBound: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '093f0fb90388dac3b4c97ffbc60402f85ca2fc3e2be7f64b33707fe88c1483c0'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2007(): {threshold: number, proposal: v2007.Proposal, lengthBound: number} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'e5b4049febde77b7dbe5ae724daf9a70110572f324c6a957b78de0e7e7de5e87'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2011(): {threshold: number, proposal: v2011.Proposal, lengthBound: number} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '4571aa24bfc4fd4775b78411fc0a36c9a287df16903ce3cb30634c6ca1adebc8'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2013(): {threshold: number, proposal: v2013.Proposal, lengthBound: number} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'c28794823d43711b64190d421d876cfecc8e127458ff8c2eaa6f1e87ae7628f0'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2015(): {threshold: number, proposal: v2015.Proposal, lengthBound: number} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'd180a7800b68f8cc27fbd9f0d24b640cb9ead8e9a7a7906eeab0cb3f45f80b14'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2022(): {threshold: number, proposal: v2022.Proposal, lengthBound: number} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'a899b60732f05ff785a2560ff27467fd3abb9c3e540fef09163d82c1e1aef31b'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2023(): {threshold: number, proposal: v2023.Proposal, lengthBound: number} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '487809b0870920ea2d48c3504a542c83d3fdc91466937bec7aab15bacf5478b5'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2024(): {threshold: number, proposal: v2024.Proposal, lengthBound: number} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'ce4c6b7550cb4d0446071af036bf50d160c2249fd23acd5ced06da863357f1d4'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2025(): {threshold: number, proposal: v2025.Proposal, lengthBound: number} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '4890b73ff8fb119cda121ce7f8be70e4e156edce353f9745720708758e7f018e'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2026(): {threshold: number, proposal: v2026.Proposal, lengthBound: number} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'e12119568ab0eb9e69e060fdd185f9a95183776fb763e4e5cef2f6e75df29978'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2028(): {threshold: number, proposal: v2028.Proposal, lengthBound: number} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'ac82f7f3517c6fa971647213b5e6d5141c270634845528a59a26ebdf75e662b8'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2029(): {threshold: number, proposal: v2029.Proposal, lengthBound: number} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '4d17d810aa29765ae2f09fbf5194e0e89e8010bf502290d0415ca33d7002c971'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV2030(): {threshold: number, proposal: v2030.Proposal, lengthBound: number} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '46176c5c57d9b0009711479e5f95dccaaeed53bced22b5810c4b4fed0d1c57ac'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9010(): {threshold: number, proposal: v9010.Proposal, lengthBound: number} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'd8a670318591c03ccab97275e1b235ae9ea970b3a4178e63b1ae51c25fe6b9d9'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9030(): {threshold: number, proposal: v9030.Proposal, lengthBound: number} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'a25a8620dc53ceeb150c13a91ff242718de0c6c789b51a67c0dff0f0f2ea8086'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9040(): {threshold: number, proposal: v9040.Proposal, lengthBound: number} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'd314ccac1e5ba5752a74b24f613a8f1d639720e8c54e14fc72c9801862b77523'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9050(): {threshold: number, proposal: v9050.Proposal, lengthBound: number} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '931f349041e9545a02a924f75dde7a551ae5c27e256f30a017e59918dbc5f590'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9080(): {threshold: number, proposal: v9080.Proposal, lengthBound: number} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'c3bf8fc02b712455b03d218f5a7c82ddfa3a1ba9ce90b3ac5e358d4ac38331e0'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9090(): {threshold: number, proposal: v9090.Proposal, lengthBound: number} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'c01ef6c0598d3165c9c4c86d63035adfa3458dbde434ce52c94b507f2ee10fdc'
    }

    /**
     *  Add a new proposal to either be voted on or executed directly.
     * 
     *  Requires the sender to be member.
     * 
     *  `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     *  or put up for voting.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(B + M + P1)` or `O(B + M + P2)` where:
     *    - `B` is `proposal` size in bytes (length-fee-bounded)
     *    - `M` is members-count (code- and governance-bounded)
     *    - branching is influenced by `threshold` where:
     *      - `P1` is proposal execution complexity (`threshold < 2`)
     *      - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *  - DB:
     *    - 1 storage read `is_member` (codec `O(M)`)
     *    - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *    - DB accesses influenced by `threshold`:
     *      - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *      - OR proposal insertion (`threshold <= 2`)
     *        - 1 storage mutation `Proposals` (codec `O(P2)`)
     *        - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *        - 1 storage write `ProposalOf` (codec `O(B)`)
     *        - 1 storage write `Voting` (codec `O(M)`)
     *    - 1 event
     *  # </weight>
     */
    get asV9100(): {threshold: number, proposal: v9100.Proposal, lengthBound: number} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '0c0257cda4b8453fb7606e6618e78afa7f767980399eda27db7479577baed06c'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9111(): {threshold: number, proposal: v9111.Call, lengthBound: number} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '7acb9a65dea691f181c3406898de9c0b1376a3c3808b7a3463661b80c806db03'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9122(): {threshold: number, proposal: v9122.Call, lengthBound: number} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'faa84e3a68f0ba3cc1226056db374cbd0bb402fc12e1fd7355d7246f5b5f5290'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9130(): {threshold: number, proposal: v9130.Call, lengthBound: number} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'c4d5e6a24d87d13f39fe70614f1631f20cf6108f71d1bf193993ed81340e21c0'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9160(): {threshold: number, proposal: v9160.Call, lengthBound: number} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'a85430d1b6982cea0328c3f23342466a313eed3f7cb9078d2c66060ee1639bb5'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9170(): {threshold: number, proposal: v9170.Call, lengthBound: number} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '4fe8c479e88f7b05ed10e25b2ff005138b6ba93f382c60a92dfcce703dfdefa3'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9180(): {threshold: number, proposal: v9180.Call, lengthBound: number} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '2cad573db30e8e37e99e07e40b03c9b7ba7ebd10e2c47d081e2ba6a820f90a47'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9190(): {threshold: number, proposal: v9190.Call, lengthBound: number} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '8ac7d297c3f78781aa250eb00585ddc0f3dfe25e4541faaaad85ea28d7b8b1e5'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9220(): {threshold: number, proposal: v9220.Call, lengthBound: number} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '9e5016f74d7cc7b8cb97996b4134eecf5af38baab32cf3d5e1b6756ce93915a8'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9230(): {threshold: number, proposal: v9230.Call, lengthBound: number} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '43e82fd1806795f866e4db0eaf6d16cfec23e0f6d8ef2115f93841e357ed02d9'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9250(): {threshold: number, proposal: v9250.Call, lengthBound: number} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '5d00c76b3c55b81fcd856165e07529c0771418ae70fe8ff25877028f3b3cc4ab'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9271(): {threshold: number, proposal: v9271.Call, lengthBound: number} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'ad0813495d84c471e4f14492855dad7c377b8687ed5be0c9d1071d9b6c91860d'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9291(): {threshold: number, proposal: v9291.Call, lengthBound: number} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === 'c85d0cb8ba24bf2c879cec22c7b3d30f30d2d1771aaa03ae59a907a2acde9644'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9300(): {threshold: number, proposal: v9300.Call, lengthBound: number} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '767d7e9520a1aabdd80e2ce3e71fecb78c5fa41461902130d69acbf4f4b6d9e6'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9320(): {threshold: number, proposal: v9320.Call, lengthBound: number} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '6df14b1a9d6bad672da91dfa576a6017a3b9a3eefee3dbf83715e70e7ff3e309'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9340(): {threshold: number, proposal: v9340.Call, lengthBound: number} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '546041b4a7d2787f39f47b6c5533e3f05829f3c58c33edc6b45cffe46ea9ace1'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9350(): {threshold: number, proposal: v9350.Call, lengthBound: number} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.propose') === '54b6347b1f98cfc052d855b25ddfb9b5f86c484cd2356ad3e5cd0319aa44c075'
    }

    /**
     * Add a new proposal to either be voted on or executed directly.
     * 
     * Requires the sender to be member.
     * 
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     * 
     * # <weight>
     * ## Weight
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     *   - `B` is `proposal` size in bytes (length-fee-bounded)
     *   - `M` is members-count (code- and governance-bounded)
     *   - branching is influenced by `threshold` where:
     *     - `P1` is proposal execution complexity (`threshold < 2`)
     *     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     * - DB:
     *   - 1 storage read `is_member` (codec `O(M)`)
     *   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)
     *   - DB accesses influenced by `threshold`:
     *     - EITHER storage accesses done by `proposal` (`threshold < 2`)
     *     - OR proposal insertion (`threshold <= 2`)
     *       - 1 storage mutation `Proposals` (codec `O(P2)`)
     *       - 1 storage mutation `ProposalCount` (codec `O(1)`)
     *       - 1 storage write `ProposalOf` (codec `O(B)`)
     *       - 1 storage write `Voting` (codec `O(M)`)
     *   - 1 event
     * # </weight>
     */
    get asV9370(): {threshold: number, proposal: v9370.Call, lengthBound: number} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeSetMembersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.set_members')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the collective's membership manually to `new_members`. Be nice to the chain and
     *  provide it pre-sorted.
     * 
     *  Requires root origin.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.set_members') === '03fec7f5be686ca7cc3fd5b0b1c734db606d398a0df652a8f6616373ca22b16d'
    }

    /**
     *  Set the collective's membership manually to `new_members`. Be nice to the chain and
     *  provide it pre-sorted.
     * 
     *  Requires root origin.
     */
    get asV1020(): {newMembers: Uint8Array[]} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set the collective's membership.
     * 
     *  - `new_members`: The new member list. Be nice to the chain and
     *  - `prime`: The prime member whose vote sets the default.
     * 
     *  Requires root origin.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.set_members') === '02ef632f438c777250038911ea2704e117cd9e01f7dd93874a32d835cfbf2057'
    }

    /**
     *  Set the collective's membership.
     * 
     *  - `new_members`: The new member list. Be nice to the chain and
     *  - `prime`: The prime member whose vote sets the default.
     * 
     *  Requires root origin.
     */
    get asV1050(): {newMembers: Uint8Array[], prime: (Uint8Array | undefined)} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Set the collective's membership.
     * 
     *  - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     *  - `prime`: The prime member whose vote sets the default.
     *  - `old_count`: The upper bound for the previous number of members in storage.
     *                 Used for weight estimation.
     * 
     *  Requires root origin.
     * 
     *  NOTE: Does not enforce the expected `MAX_MEMBERS` limit on the amount of members, but
     *        the weight estimations rely on it to estimate dispatchable weight.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(MP + N)` where:
     *    - `M` old-members-count (code- and governance-bounded)
     *    - `N` new-members-count (code- and governance-bounded)
     *    - `P` proposals-count (code-bounded)
     *  - DB:
     *    - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members
     *    - 1 storage read (codec `O(P)`) for reading the proposals
     *    - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
     *    - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.set_members') === '71b7fcb1d8a62eff96a9ef006517578ce9189e6d931948a256a04ca75ff68d4a'
    }

    /**
     *  Set the collective's membership.
     * 
     *  - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     *  - `prime`: The prime member whose vote sets the default.
     *  - `old_count`: The upper bound for the previous number of members in storage.
     *                 Used for weight estimation.
     * 
     *  Requires root origin.
     * 
     *  NOTE: Does not enforce the expected `MAX_MEMBERS` limit on the amount of members, but
     *        the weight estimations rely on it to estimate dispatchable weight.
     * 
     *  # <weight>
     *  ## Weight
     *  - `O(MP + N)` where:
     *    - `M` old-members-count (code- and governance-bounded)
     *    - `N` new-members-count (code- and governance-bounded)
     *    - `P` proposals-count (code-bounded)
     *  - DB:
     *    - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members
     *    - 1 storage read (codec `O(P)`) for reading the proposals
     *    - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal
     *    - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one
     *  # </weight>
     */
    get asV2005(): {newMembers: Uint8Array[], prime: (Uint8Array | undefined), oldCount: number} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalCommitteeVoteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalCommittee.vote')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  # <weight>
     *  - Bounded storage read and writes.
     *  - Will be slightly heavier if the proposal is approved / disapproved after the vote.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('TechnicalCommittee.vote') === 'f8a1069a57f7b721f47c086d08b6838ae1a0c08f58caddb82428ba5f1407540f'
    }

    /**
     *  # <weight>
     *  - Bounded storage read and writes.
     *  - Will be slightly heavier if the proposal is approved / disapproved after the vote.
     *  # </weight>
     */
    get asV1020(): {proposal: Uint8Array, index: number, approve: boolean} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipAddMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.add_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Add a member `who` to the set.
     * 
     *  May only be called from `AddOrigin` or root.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('TechnicalMembership.add_member') === 'b8a0d2208835f6ada60dd21cd93533d703777b3779109a7c6a2f26bad68c2f3b'
    }

    /**
     *  Add a member `who` to the set.
     * 
     *  May only be called from `AddOrigin` or root.
     */
    get asV1020(): {who: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Add a member `who` to the set.
     * 
     * May only be called from `T::AddOrigin`.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('TechnicalMembership.add_member') === '1642934df325db16ad3ad3f83bb2200cdde93b508c653dc7b78049e7e8d67223'
    }

    /**
     * Add a member `who` to the set.
     * 
     * May only be called from `T::AddOrigin`.
     */
    get asV9291(): {who: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipChangeKeyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.change_key')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Swap out the sending member for some other key `new`.
     * 
     *  May only be called from `Signed` origin of a current member.
     */
    get isV1029(): boolean {
        return this._chain.getCallHash('TechnicalMembership.change_key') === 'f866dcb3e8857987a2d21e57c13216c10bb21546a718b81d5e2c0989d6e95df7'
    }

    /**
     *  Swap out the sending member for some other key `new`.
     * 
     *  May only be called from `Signed` origin of a current member.
     */
    get asV1029(): {new: Uint8Array} {
        assert(this.isV1029)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Swap out the sending member for some other key `new`.
     * 
     * May only be called from `Signed` origin of a current member.
     * 
     * Prime membership is passed from the origin account to `new`, if extant.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('TechnicalMembership.change_key') === 'e634aac3331d47a56ff572c52ad90a648769dfbf2c00d7bd44498b4ee41f6ac7'
    }

    /**
     * Swap out the sending member for some other key `new`.
     * 
     * May only be called from `Signed` origin of a current member.
     * 
     * Prime membership is passed from the origin account to `new`, if extant.
     */
    get asV9291(): {new: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipClearPrimeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.clear_prime')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove the prime member if it exists.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('TechnicalMembership.clear_prime') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Remove the prime member if it exists.
     */
    get asV1050(): null {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipRemoveMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.remove_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove a member `who` from the set.
     * 
     *  May only be called from `RemoveOrigin` or root.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('TechnicalMembership.remove_member') === 'b8a0d2208835f6ada60dd21cd93533d703777b3779109a7c6a2f26bad68c2f3b'
    }

    /**
     *  Remove a member `who` from the set.
     * 
     *  May only be called from `RemoveOrigin` or root.
     */
    get asV1020(): {who: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Remove a member `who` from the set.
     * 
     * May only be called from `T::RemoveOrigin`.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('TechnicalMembership.remove_member') === '1642934df325db16ad3ad3f83bb2200cdde93b508c653dc7b78049e7e8d67223'
    }

    /**
     * Remove a member `who` from the set.
     * 
     * May only be called from `T::RemoveOrigin`.
     */
    get asV9291(): {who: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipResetMembersCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.reset_members')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Change the membership to a new set, disregarding the existing membership. Be nice and
     *  pass `members` pre-sorted.
     * 
     *  May only be called from `ResetOrigin` or root.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('TechnicalMembership.reset_members') === 'd8adca14f9b9cadeaf2b2e6dd47991d05cb423ce3a00dccbb9efa35e36f5a65a'
    }

    /**
     *  Change the membership to a new set, disregarding the existing membership. Be nice and
     *  pass `members` pre-sorted.
     * 
     *  May only be called from `ResetOrigin` or root.
     */
    get asV1020(): {members: Uint8Array[]} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipSetPrimeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.set_prime')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the prime member. Must be a current member.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('TechnicalMembership.set_prime') === 'b8a0d2208835f6ada60dd21cd93533d703777b3779109a7c6a2f26bad68c2f3b'
    }

    /**
     *  Set the prime member. Must be a current member.
     */
    get asV1050(): {who: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Set the prime member. Must be a current member.
     * 
     * May only be called from `T::PrimeOrigin`.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('TechnicalMembership.set_prime') === '1642934df325db16ad3ad3f83bb2200cdde93b508c653dc7b78049e7e8d67223'
    }

    /**
     * Set the prime member. Must be a current member.
     * 
     * May only be called from `T::PrimeOrigin`.
     */
    get asV9291(): {who: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class TechnicalMembershipSwapMemberCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'TechnicalMembership.swap_member')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Swap out one member `remove` for another `add`.
     * 
     *  May only be called from `SwapOrigin` or root.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('TechnicalMembership.swap_member') === 'f9cf5ef851567c52b54f359126b80e6fa967b49f082dd77310b8461819cd13df'
    }

    /**
     *  Swap out one member `remove` for another `add`.
     * 
     *  May only be called from `SwapOrigin` or root.
     */
    get asV1020(): {remove: Uint8Array, add: Uint8Array} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Swap out one member `remove` for another `add`.
     * 
     * May only be called from `T::SwapOrigin`.
     * 
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('TechnicalMembership.swap_member') === '5efd724fae29eef6393e039bf2dbfd2d5a3081770cc9cc8a80a1475fd6b40cf4'
    }

    /**
     * Swap out one member `remove` for another `add`.
     * 
     * May only be called from `T::SwapOrigin`.
     * 
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     */
    get asV9291(): {remove: v9291.MultiAddress, add: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class TimestampSetCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Timestamp.set')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Set the current time.
     * 
     *  This call should be invoked exactly once per block. It will panic at the finalization
     *  phase, if this call hasn't been invoked by that time.
     * 
     *  The timestamp should be greater than the previous one by the amount specified by
     *  `MinimumPeriod`.
     * 
     *  The dispatch origin for this call must be `Inherent`.
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Timestamp.set') === '6a8b8ba2be107f0853b674eec0026cc440b314db44d0e2c59b36e353355aed14'
    }

    /**
     *  Set the current time.
     * 
     *  This call should be invoked exactly once per block. It will panic at the finalization
     *  phase, if this call hasn't been invoked by that time.
     * 
     *  The timestamp should be greater than the previous one by the amount specified by
     *  `MinimumPeriod`.
     * 
     *  The dispatch origin for this call must be `Inherent`.
     */
    get asV1020(): {now: bigint} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class TipsCloseTipCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tips.close_tip')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Close and payout a tip.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  The tip identified by `hash` must have finished its countdown period.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
     * 
     *  # <weight>
     *  - Complexity: `O(T)` where `T` is the number of tippers.
     *    decoding `Tipper` vec of length `T`.
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     *  - DbReads: `Tips`, `Tippers`, `tip finder`
     *  - DbWrites: `Reasons`, `Tips`, `Tippers`, `tip finder`
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Tips.close_tip') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     *  Close and payout a tip.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  The tip identified by `hash` must have finished its countdown period.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
     * 
     *  # <weight>
     *  - Complexity: `O(T)` where `T` is the number of tippers.
     *    decoding `Tipper` vec of length `T`.
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     *  - DbReads: `Tips`, `Tippers`, `tip finder`
     *  - DbWrites: `Reasons`, `Tips`, `Tippers`, `tip finder`
     *  # </weight>
     */
    get asV2028(): {hash: Uint8Array} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class TipsReportAwesomeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tips.report_awesome')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Report something `reason` that deserves a tip and claim any eventual the finder's fee.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     *  `DataDepositPerByte` for each byte in `reason`.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(R)` where `R` length of `reason`.
     *    - encoding and hashing of 'reason'
     *  - DbReads: `Reasons`, `Tips`
     *  - DbWrites: `Reasons`, `Tips`
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Tips.report_awesome') === '5f39cdb6a1bab5505c2717a3d34b1ad66c35bb6aca421780ce60b4e9017fe886'
    }

    /**
     *  Report something `reason` that deserves a tip and claim any eventual the finder's fee.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     *  `DataDepositPerByte` for each byte in `reason`.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(R)` where `R` length of `reason`.
     *    - encoding and hashing of 'reason'
     *  - DbReads: `Reasons`, `Tips`
     *  - DbWrites: `Reasons`, `Tips`
     *  # </weight>
     */
    get asV2028(): {reason: Uint8Array, who: Uint8Array} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Report something `reason` that deserves a tip and claim any eventual the finder's fee.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     * `DataDepositPerByte` for each byte in `reason`.
     * 
     * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *   a UTF-8-encoded URL.
     * - `who`: The account which should be credited for the tip.
     * 
     * Emits `NewTip` if successful.
     * 
     * # <weight>
     * - Complexity: `O(R)` where `R` length of `reason`.
     *   - encoding and hashing of 'reason'
     * - DbReads: `Reasons`, `Tips`
     * - DbWrites: `Reasons`, `Tips`
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Tips.report_awesome') === '14964738e276e95e94f6efa5fe953428f7537f27815f688365f6275f4cea67df'
    }

    /**
     * Report something `reason` that deserves a tip and claim any eventual the finder's fee.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     * `DataDepositPerByte` for each byte in `reason`.
     * 
     * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *   a UTF-8-encoded URL.
     * - `who`: The account which should be credited for the tip.
     * 
     * Emits `NewTip` if successful.
     * 
     * # <weight>
     * - Complexity: `O(R)` where `R` length of `reason`.
     *   - encoding and hashing of 'reason'
     * - DbReads: `Reasons`, `Tips`
     * - DbWrites: `Reasons`, `Tips`
     * # </weight>
     */
    get asV9291(): {reason: Uint8Array, who: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class TipsRetractTipCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tips.retract_tip')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
     * 
     *  If successful, the original deposit will be unreserved.
     * 
     *  The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
     *  must have been reported by the signing account through `report_awesome` (and not
     *  through `tip_new`).
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
     * 
     *  Emits `TipRetracted` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(1)`
     *    - Depends on the length of `T::Hash` which is fixed.
     *  - DbReads: `Tips`, `origin account`
     *  - DbWrites: `Reasons`, `Tips`, `origin account`
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Tips.retract_tip') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     *  Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
     * 
     *  If successful, the original deposit will be unreserved.
     * 
     *  The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
     *  must have been reported by the signing account through `report_awesome` (and not
     *  through `tip_new`).
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
     * 
     *  Emits `TipRetracted` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(1)`
     *    - Depends on the length of `T::Hash` which is fixed.
     *  - DbReads: `Tips`, `origin account`
     *  - DbWrites: `Reasons`, `Tips`, `origin account`
     *  # </weight>
     */
    get asV2028(): {hash: Uint8Array} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class TipsSlashTipCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tips.slash_tip')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Remove and slash an already-open tip.
     * 
     *  May only be called from `T::RejectOrigin`.
     * 
     *  As a result, the finder is slashed and the deposits are lost.
     * 
     *  Emits `TipSlashed` if successful.
     * 
     *  # <weight>
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Tips.slash_tip') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     *  Remove and slash an already-open tip.
     * 
     *  May only be called from `T::RejectOrigin`.
     * 
     *  As a result, the finder is slashed and the deposits are lost.
     * 
     *  Emits `TipSlashed` if successful.
     * 
     *  # <weight>
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     *  # </weight>
     */
    get asV2028(): {hash: Uint8Array} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class TipsTipCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tips.tip')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Declare a tip value for an already-open tip.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
     *    account ID.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
     *  has started.
     * 
     *  # <weight>
     *  - Complexity: `O(T)` where `T` is the number of tippers.
     *    decoding `Tipper` vec of length `T`, insert tip and check closing,
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     * 
     *    Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
     *    is weighted as if almost full i.e of length `T-1`.
     *  - DbReads: `Tippers`, `Tips`
     *  - DbWrites: `Tips`
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Tips.tip') === 'f3795cdab18c292963e0e30ece37a15a2900030efc315a8e3f28ba886b2b9f58'
    }

    /**
     *  Declare a tip value for an already-open tip.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
     *    account ID.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
     *  has started.
     * 
     *  # <weight>
     *  - Complexity: `O(T)` where `T` is the number of tippers.
     *    decoding `Tipper` vec of length `T`, insert tip and check closing,
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     * 
     *    Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
     *    is weighted as if almost full i.e of length `T-1`.
     *  - DbReads: `Tippers`, `Tips`
     *  - DbWrites: `Tips`
     *  # </weight>
     */
    get asV2028(): {hash: Uint8Array, tipValue: bigint} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }
}

export class TipsTipNewCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Tips.tip_new')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Give a tip for something new; no finder's fee will be taken.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
     *    - `O(T)`: decoding `Tipper` vec of length `T`
     *      `T` is charged as upper bound given by `ContainsLengthBound`.
     *      The actual cost depends on the implementation of `T::Tippers`.
     *    - `O(R)`: hashing and encoding of reason of length `R`
     *  - DbReads: `Tippers`, `Reasons`
     *  - DbWrites: `Reasons`, `Tips`
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Tips.tip_new') === '367b1dcdffb32d8c4b26e342e9b515c65f2589dec81f4a3f6f336faaa7e127ac'
    }

    /**
     *  Give a tip for something new; no finder's fee will be taken.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
     *    - `O(T)`: decoding `Tipper` vec of length `T`
     *      `T` is charged as upper bound given by `ContainsLengthBound`.
     *      The actual cost depends on the implementation of `T::Tippers`.
     *    - `O(R)`: hashing and encoding of reason of length `R`
     *  - DbReads: `Tippers`, `Reasons`
     *  - DbWrites: `Reasons`, `Tips`
     *  # </weight>
     */
    get asV2028(): {reason: Uint8Array, who: Uint8Array, tipValue: bigint} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Give a tip for something new; no finder's fee will be taken.
     * 
     * The dispatch origin for this call must be _Signed_ and the signing account must be a
     * member of the `Tippers` set.
     * 
     * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *   a UTF-8-encoded URL.
     * - `who`: The account which should be credited for the tip.
     * - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *   value of active tippers will be given to the `who`.
     * 
     * Emits `NewTip` if successful.
     * 
     * # <weight>
     * - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
     *   - `O(T)`: decoding `Tipper` vec of length `T`. `T` is charged as upper bound given by
     *     `ContainsLengthBound`. The actual cost depends on the implementation of
     *     `T::Tippers`.
     *   - `O(R)`: hashing and encoding of reason of length `R`
     * - DbReads: `Tippers`, `Reasons`
     * - DbWrites: `Reasons`, `Tips`
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Tips.tip_new') === '340063926daebcdd5ba139252081f24472426696cfbff5aeda54953ca2048d2e'
    }

    /**
     * Give a tip for something new; no finder's fee will be taken.
     * 
     * The dispatch origin for this call must be _Signed_ and the signing account must be a
     * member of the `Tippers` set.
     * 
     * - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *   a UTF-8-encoded URL.
     * - `who`: The account which should be credited for the tip.
     * - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *   value of active tippers will be given to the `who`.
     * 
     * Emits `NewTip` if successful.
     * 
     * # <weight>
     * - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
     *   - `O(T)`: decoding `Tipper` vec of length `T`. `T` is charged as upper bound given by
     *     `ContainsLengthBound`. The actual cost depends on the implementation of
     *     `T::Tippers`.
     *   - `O(R)`: hashing and encoding of reason of length `R`
     * - DbReads: `Tippers`, `Reasons`
     * - DbWrites: `Reasons`, `Tips`
     * # </weight>
     */
    get asV9291(): {reason: Uint8Array, who: v9291.MultiAddress, tipValue: bigint} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryAcceptCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.accept_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Accept the curator role for a bounty.
     *  A deposit will be reserved from curator and refund upon successful payout.
     * 
     *  May only be called from the curator.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Treasury.accept_curator') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Accept the curator role for a bounty.
     *  A deposit will be reserved from curator and refund upon successful payout.
     * 
     *  May only be called from the curator.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get asV2025(): {bountyId: number} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryApproveBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.approve_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Approve a bounty proposal. At a later time, the bounty will be funded and become active
     *  and the original deposit will be returned.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Treasury.approve_bounty') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Approve a bounty proposal. At a later time, the bounty will be funded and become active
     *  and the original deposit will be returned.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get asV2025(): {bountyId: number} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryApproveProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.approve_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
     *  and the original deposit will be returned.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Treasury.approve_proposal') === 'd31c3c178e65331a6ccd6f8dca07268f945f39b38e51421afd1c9e1f5bc0f6c8'
    }

    /**
     *  Approve a proposal. At a later time, the proposal will be allocated to the beneficiary
     *  and the original deposit will be returned.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get asV1020(): {proposalId: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryAwardBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.award_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Award bounty to a beneficiary account. The beneficiary will be able to claim the funds after a delay.
     * 
     *  The dispatch origin for this call must be the curator of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to award.
     *  - `beneficiary`: The beneficiary account whom will receive the payout.
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Treasury.award_bounty') === 'c430d5052cab44856cf7a7fecef43daea8b6f02b68c1049ae34de276f6f7f19f'
    }

    /**
     *  Award bounty to a beneficiary account. The beneficiary will be able to claim the funds after a delay.
     * 
     *  The dispatch origin for this call must be the curator of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to award.
     *  - `beneficiary`: The beneficiary account whom will receive the payout.
     */
    get asV2025(): {bountyId: number, beneficiary: Uint8Array} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryClaimBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.claim_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Claim the payout from an awarded bounty after payout delay.
     * 
     *  The dispatch origin for this call must be the beneficiary of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to claim.
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Treasury.claim_bounty') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Claim the payout from an awarded bounty after payout delay.
     * 
     *  The dispatch origin for this call must be the beneficiary of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to claim.
     */
    get asV2025(): {bountyId: number} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryCloseBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.close_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel a proposed or active bounty. All the funds will be sent to treasury and
     *  the curator deposit will be unreserved if possible.
     * 
     *  Only `T::RejectOrigin` is able to cancel a bounty.
     * 
     *  - `bounty_id`: Bounty ID to cancel.
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Treasury.close_bounty') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Cancel a proposed or active bounty. All the funds will be sent to treasury and
     *  the curator deposit will be unreserved if possible.
     * 
     *  Only `T::RejectOrigin` is able to cancel a bounty.
     * 
     *  - `bounty_id`: Bounty ID to cancel.
     */
    get asV2025(): {bountyId: number} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryCloseTipCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.close_tip')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Close and payout a tip.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  The tip identified by `hash` must have finished its countdown period.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
     * 
     *  # <weight>
     *  - `O(T)`
     *  - One storage retrieval (codec `O(T)`) and two removals.
     *  - Up to three balance operations.
     *  # </weight>
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('Treasury.close_tip') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     *  Close and payout a tip.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  The tip identified by `hash` must have finished its countdown period.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
     * 
     *  # <weight>
     *  - `O(T)`
     *  - One storage retrieval (codec `O(T)`) and two removals.
     *  - Up to three balance operations.
     *  # </weight>
     */
    get asV1038(): {hash: Uint8Array} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryExtendBountyExpiryCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.extend_bounty_expiry')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Extend the expiry time of an active bounty.
     * 
     *  The dispatch origin for this call must be the curator of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to extend.
     *  - `remark`: additional information.
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Treasury.extend_bounty_expiry') === '710d6b76ffcee45bd9bffc1f299fa0b621450769559963379fa259c0f427f1bb'
    }

    /**
     *  Extend the expiry time of an active bounty.
     * 
     *  The dispatch origin for this call must be the curator of this bounty.
     * 
     *  - `bounty_id`: Bounty ID to extend.
     *  - `remark`: additional information.
     */
    get asV2025(): {bountyId: number, remark: Uint8Array} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryProposeBountyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.propose_bounty')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Propose a new bounty.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     *  `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
     *  or slashed when rejected.
     * 
     *  - `curator`: The curator account whom will manage this bounty.
     *  - `fee`: The curator fee.
     *  - `value`: The total payment amount of this bounty, curator fee included.
     *  - `description`: The description of this bounty.
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Treasury.propose_bounty') === '6a012b4069a991972d0d3268cb20dfba3163919c325c7ebbe980b2dc15f1b1f5'
    }

    /**
     *  Propose a new bounty.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     *  `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,
     *  or slashed when rejected.
     * 
     *  - `curator`: The curator account whom will manage this bounty.
     *  - `fee`: The curator fee.
     *  - `value`: The total payment amount of this bounty, curator fee included.
     *  - `description`: The description of this bounty.
     */
    get asV2025(): {value: bigint, description: Uint8Array} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryProposeCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.propose_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Assign a curator to a funded bounty.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Treasury.propose_curator') === 'b721292832d9b9903a368ecbd3d5abe3ce4c762724d34ca59a92a6af7496daf5'
    }

    /**
     *  Assign a curator to a funded bounty.
     * 
     *  May only be called from `T::ApproveOrigin`.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get asV2025(): {bountyId: number, curator: Uint8Array, fee: bigint} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryProposeSpendCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.propose_spend')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Put forward a suggestion for spending. A deposit proportional to the value
     *  is reserved and slashed if the proposal is rejected. It is returned once the
     *  proposal is awarded.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change, one extra DB entry.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Treasury.propose_spend') === '716689a9bf600e2a2fed633501a80e9ae7082f3d19352663230c0a56fa8652c3'
    }

    /**
     *  Put forward a suggestion for spending. A deposit proportional to the value
     *  is reserved and slashed if the proposal is rejected. It is returned once the
     *  proposal is awarded.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change, one extra DB entry.
     *  # </weight>
     */
    get asV1020(): {value: bigint, beneficiary: v1020.LookupSource} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Put forward a suggestion for spending. A deposit proportional to the value
     *  is reserved and slashed if the proposal is rejected. It is returned once the
     *  proposal is awarded.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change, one extra DB entry.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Treasury.propose_spend') === '98e9af32f46010396e58ac70ce7c017f7e95d81b05c03d5e5aeb94ce27732909'
    }

    /**
     *  Put forward a suggestion for spending. A deposit proportional to the value
     *  is reserved and slashed if the proposal is rejected. It is returned once the
     *  proposal is awarded.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change, one extra DB entry.
     *  # </weight>
     */
    get asV1050(): {value: bigint, beneficiary: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Put forward a suggestion for spending. A deposit proportional to the value
     *  is reserved and slashed if the proposal is rejected. It is returned once the
     *  proposal is awarded.
     * 
     *  # <weight>
     *  - Complexity: O(1)
     *  - DbReads: `ProposalCount`, `origin account`
     *  - DbWrites: `ProposalCount`, `Proposals`, `origin account`
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Treasury.propose_spend') === 'c9f0fb5ad91e84a77c5f948f4140d239e238788ae3191c594dc1e6592472d5a7'
    }

    /**
     *  Put forward a suggestion for spending. A deposit proportional to the value
     *  is reserved and slashed if the proposal is rejected. It is returned once the
     *  proposal is awarded.
     * 
     *  # <weight>
     *  - Complexity: O(1)
     *  - DbReads: `ProposalCount`, `origin account`
     *  - DbWrites: `ProposalCount`, `Proposals`, `origin account`
     *  # </weight>
     */
    get asV2028(): {value: bigint, beneficiary: v2028.LookupSource} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Put forward a suggestion for spending. A deposit proportional to the value
     * is reserved and slashed if the proposal is rejected. It is returned once the
     * proposal is awarded.
     * 
     * # <weight>
     * - Complexity: O(1)
     * - DbReads: `ProposalCount`, `origin account`
     * - DbWrites: `ProposalCount`, `Proposals`, `origin account`
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Treasury.propose_spend') === 'ffef9f31e8ae5085e7c0a55a685daef52218f0bf7083015ac904dafceedf09ee'
    }

    /**
     * Put forward a suggestion for spending. A deposit proportional to the value
     * is reserved and slashed if the proposal is rejected. It is returned once the
     * proposal is awarded.
     * 
     * # <weight>
     * - Complexity: O(1)
     * - DbReads: `ProposalCount`, `origin account`
     * - DbWrites: `ProposalCount`, `Proposals`, `origin account`
     * # </weight>
     */
    get asV9111(): {value: bigint, beneficiary: v9111.MultiAddress} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryRejectProposalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.reject_proposal')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Reject a proposed spend. The original deposit will be slashed.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB clear.
     *  # </weight>
     */
    get isV1020(): boolean {
        return this._chain.getCallHash('Treasury.reject_proposal') === 'd31c3c178e65331a6ccd6f8dca07268f945f39b38e51421afd1c9e1f5bc0f6c8'
    }

    /**
     *  Reject a proposed spend. The original deposit will be slashed.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB clear.
     *  # </weight>
     */
    get asV1020(): {proposalId: number} {
        assert(this.isV1020)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryRemoveApprovalCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.remove_approval')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     * The original deposit will no longer be returned.
     * 
     * May only be called from `T::RejectOrigin`.
     * - `proposal_id`: The index of a proposal
     * 
     * # <weight>
     * - Complexity: O(A) where `A` is the number of approvals
     * - Db reads and writes: `Approvals`
     * # </weight>
     * 
     * Errors:
     * - `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
     * i.e., the proposal has not been approved. This could also mean the proposal does not
     * exist altogether, thus there is no way it would have been approved in the first place.
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Treasury.remove_approval') === 'd31c3c178e65331a6ccd6f8dca07268f945f39b38e51421afd1c9e1f5bc0f6c8'
    }

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     * The original deposit will no longer be returned.
     * 
     * May only be called from `T::RejectOrigin`.
     * - `proposal_id`: The index of a proposal
     * 
     * # <weight>
     * - Complexity: O(A) where `A` is the number of approvals
     * - Db reads and writes: `Approvals`
     * # </weight>
     * 
     * Errors:
     * - `ProposalNotApproved`: The `proposal_id` supplied was not found in the approval queue,
     * i.e., the proposal has not been approved. This could also mean the proposal does not
     * exist altogether, thus there is no way it would have been approved in the first place.
     */
    get asV9220(): {proposalId: number} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryReportAwesomeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.report_awesome')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Report something `reason` that deserves a tip and claim any eventual the finder's fee.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     *  `TipReportDepositPerByte` for each byte in `reason`.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - `O(R)` where `R` length of `reason`.
     *  - One balance operation.
     *  - One storage mutation (codec `O(R)`).
     *  - One event.
     *  # </weight>
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('Treasury.report_awesome') === '5f39cdb6a1bab5505c2717a3d34b1ad66c35bb6aca421780ce60b4e9017fe886'
    }

    /**
     *  Report something `reason` that deserves a tip and claim any eventual the finder's fee.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  Payment: `TipReportDepositBase` will be reserved from the origin account, as well as
     *  `TipReportDepositPerByte` for each byte in `reason`.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - `O(R)` where `R` length of `reason`.
     *  - One balance operation.
     *  - One storage mutation (codec `O(R)`).
     *  - One event.
     *  # </weight>
     */
    get asV1038(): {reason: Uint8Array, who: Uint8Array} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryRetractTipCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.retract_tip')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
     * 
     *  If successful, the original deposit will be unreserved.
     * 
     *  The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
     *  must have been reported by the signing account through `report_awesome` (and not
     *  through `tip_new`).
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
     * 
     *  Emits `TipRetracted` if successful.
     * 
     *  # <weight>
     *  - `O(T)`
     *  - One balance operation.
     *  - Two storage removals (one read, codec `O(T)`).
     *  - One event.
     *  # </weight>
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('Treasury.retract_tip') === '19b8576fc9fe9553b0b5ad154324ccae0d0d43fdccbdffddf2bb6066a9b37b5c'
    }

    /**
     *  Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.
     * 
     *  If successful, the original deposit will be unreserved.
     * 
     *  The dispatch origin for this call must be _Signed_ and the tip identified by `hash`
     *  must have been reported by the signing account through `report_awesome` (and not
     *  through `tip_new`).
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the original tip `reason` and the beneficiary account ID.
     * 
     *  Emits `TipRetracted` if successful.
     * 
     *  # <weight>
     *  - `O(T)`
     *  - One balance operation.
     *  - Two storage removals (one read, codec `O(T)`).
     *  - One event.
     *  # </weight>
     */
    get asV1038(): {hash: Uint8Array} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasurySpendCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.spend')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Propose and approve a spend of treasury funds.
     * 
     * - `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     * 
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Treasury.spend') === '18a5bcfd718b2b225ac128952f0fc34fff8371520e0ab5bac3a0ab20286b496d'
    }

    /**
     * Propose and approve a spend of treasury funds.
     * 
     * - `origin`: Must be `SpendOrigin` with the `Success` value being at least `amount`.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     * 
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     */
    get asV9250(): {amount: bigint, beneficiary: v9250.MultiAddress} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryTipCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.tip')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Declare a tip value for an already-open tip.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
     *    account ID.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
     *  has started.
     * 
     *  # <weight>
     *  - `O(T)`
     *  - One storage mutation (codec `O(T)`), one storage read `O(1)`.
     *  - Up to one event.
     *  # </weight>
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('Treasury.tip') === '2111563b3ac5541651b53f665a96e00e00bd7257eee2b159ec7f437d63c69299'
    }

    /**
     *  Declare a tip value for an already-open tip.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
     *    account ID.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
     *  has started.
     * 
     *  # <weight>
     *  - `O(T)`
     *  - One storage mutation (codec `O(T)`), one storage read `O(1)`.
     *  - Up to one event.
     *  # </weight>
     */
    get asV1038(): {hash: Uint8Array, tipValue: bigint} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Declare a tip value for an already-open tip.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
     *    account ID.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
     *  has started.
     * 
     *  # <weight>
     *  - Complexity: `O(T)` where `T` is the number of tippers.
     *    decoding `Tipper` vec of length `T`, insert tip and check closing,
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     * 
     *    Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
     *    is weighted as if almost full i.e of length `T-1`.
     *  - DbReads: `Tippers`, `Tips`
     *  - DbWrites: `Tips`
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Treasury.tip') === 'f3795cdab18c292963e0e30ece37a15a2900030efc315a8e3f28ba886b2b9f58'
    }

    /**
     *  Declare a tip value for an already-open tip.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `hash`: The identity of the open tip for which a tip value is declared. This is formed
     *    as the hash of the tuple of the hash of the original tip `reason` and the beneficiary
     *    account ID.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `TipClosing` if the threshold of tippers has been reached and the countdown period
     *  has started.
     * 
     *  # <weight>
     *  - Complexity: `O(T)` where `T` is the number of tippers.
     *    decoding `Tipper` vec of length `T`, insert tip and check closing,
     *    `T` is charged as upper bound given by `ContainsLengthBound`.
     *    The actual cost depends on the implementation of `T::Tippers`.
     * 
     *    Actually weight could be lower as it depends on how many tips are in `OpenTip` but it
     *    is weighted as if almost full i.e of length `T-1`.
     *  - DbReads: `Tippers`, `Tips`
     *  - DbWrites: `Tips`
     *  # </weight>
     */
    get asV2025(): {hash: Uint8Array, tipValue: bigint} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryTipNewCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.tip_new')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Give a tip for something new; no finder's fee will be taken.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - `O(R + T)` where `R` length of `reason`, `T` is the number of tippers. `T` is
     *    naturally capped as a membership set, `R` is limited through transaction-size.
     *  - Two storage insertions (codecs `O(R)`, `O(T)`), one read `O(1)`.
     *  - One event.
     *  # </weight>
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('Treasury.tip_new') === 'e800a1887710a34a2c35db4f1ff41ff8bb8b71f5bb060338930197784c9a17b3'
    }

    /**
     *  Give a tip for something new; no finder's fee will be taken.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - `O(R + T)` where `R` length of `reason`, `T` is the number of tippers. `T` is
     *    naturally capped as a membership set, `R` is limited through transaction-size.
     *  - Two storage insertions (codecs `O(R)`, `O(T)`), one read `O(1)`.
     *  - One event.
     *  # </weight>
     */
    get asV1038(): {reason: Uint8Array, who: Uint8Array, tipValue: bigint} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Give a tip for something new; no finder's fee will be taken.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
     *    - `O(T)`: decoding `Tipper` vec of length `T`
     *      `T` is charged as upper bound given by `ContainsLengthBound`.
     *      The actual cost depends on the implementation of `T::Tippers`.
     *    - `O(R)`: hashing and encoding of reason of length `R`
     *  - DbReads: `Tippers`, `Reasons`
     *  - DbWrites: `Reasons`, `Tips`
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Treasury.tip_new') === '367b1dcdffb32d8c4b26e342e9b515c65f2589dec81f4a3f6f336faaa7e127ac'
    }

    /**
     *  Give a tip for something new; no finder's fee will be taken.
     * 
     *  The dispatch origin for this call must be _Signed_ and the signing account must be a
     *  member of the `Tippers` set.
     * 
     *  - `reason`: The reason for, or the thing that deserves, the tip; generally this will be
     *    a UTF-8-encoded URL.
     *  - `who`: The account which should be credited for the tip.
     *  - `tip_value`: The amount of tip that the sender would like to give. The median tip
     *    value of active tippers will be given to the `who`.
     * 
     *  Emits `NewTip` if successful.
     * 
     *  # <weight>
     *  - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.
     *    - `O(T)`: decoding `Tipper` vec of length `T`
     *      `T` is charged as upper bound given by `ContainsLengthBound`.
     *      The actual cost depends on the implementation of `T::Tippers`.
     *    - `O(R)`: hashing and encoding of reason of length `R`
     *  - DbReads: `Tippers`, `Reasons`
     *  - DbWrites: `Reasons`, `Tips`
     *  # </weight>
     */
    get asV2025(): {reason: Uint8Array, who: Uint8Array, tipValue: bigint} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class TreasuryUnassignCuratorCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Treasury.unassign_curator')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unassign curator from a bounty.
     * 
     *  This function can only be called by the `RejectOrigin` a signed origin.
     * 
     *  If this function is called by the `RejectOrigin`, we assume that the curator is malicious
     *  or inactive. As a result, we will slash the curator when possible.
     * 
     *  If the origin is the curator, we take this as a sign they are unable to do their job and
     *  they willingly give up. We could slash them, but for now we allow them to recover their
     *  deposit and exit without issue. (We may want to change this if it is abused.)
     * 
     *  Finally, the origin can be anyone if and only if the curator is "inactive". This allows
     *  anyone in the community to call out that a curator is not doing their due diligence, and
     *  we should pick a new curator. In this case the curator should also be slashed.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Treasury.unassign_curator') === '77b779cfa161e4e6eeffa4c35f55ae2bd68aba06e4b5d48766892991c97064c9'
    }

    /**
     *  Unassign curator from a bounty.
     * 
     *  This function can only be called by the `RejectOrigin` a signed origin.
     * 
     *  If this function is called by the `RejectOrigin`, we assume that the curator is malicious
     *  or inactive. As a result, we will slash the curator when possible.
     * 
     *  If the origin is the curator, we take this as a sign they are unable to do their job and
     *  they willingly give up. We could slash them, but for now we allow them to recover their
     *  deposit and exit without issue. (We may want to change this if it is abused.)
     * 
     *  Finally, the origin can be anyone if and only if the curator is "inactive". This allows
     *  anyone in the community to call out that a curator is not doing their due diligence, and
     *  we should pick a new curator. In this case the curator should also be slashed.
     * 
     *  # <weight>
     *  - O(1).
     *  - Limited storage reads.
     *  - One DB change.
     *  # </weight>
     */
    get asV2025(): {bountyId: number} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }
}

export class UmpServiceOverweightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Ump.service_overweight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Service a single overweight upward message.
     * 
     *  - `origin`: Must pass `ExecuteOverweightOrigin`.
     *  - `index`: The index of the overweight message to service.
     *  - `weight_limit`: The amount of weight that message execution may take.
     * 
     *  Errors:
     *  - `UnknownMessageIndex`: Message of `index` is unknown.
     *  - `WeightOverLimit`: Message execution may use greater than `weight_limit`.
     * 
     *  Events:
     *  - `OverweightServiced`: On success.
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Ump.service_overweight') === 'f6b281f58290b6af96ac2dda36163d81223f37d0a8a100877e2526969a57d772'
    }

    /**
     *  Service a single overweight upward message.
     * 
     *  - `origin`: Must pass `ExecuteOverweightOrigin`.
     *  - `index`: The index of the overweight message to service.
     *  - `weight_limit`: The amount of weight that message execution may take.
     * 
     *  Errors:
     *  - `UnknownMessageIndex`: Message of `index` is unknown.
     *  - `WeightOverLimit`: Message execution may use greater than `weight_limit`.
     * 
     *  Events:
     *  - `OverweightServiced`: On success.
     */
    get asV9100(): {index: bigint, weightLimit: bigint} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Service a single overweight upward message.
     * 
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight message to service.
     * - `weight_limit`: The amount of weight that message execution may take.
     * 
     * Errors:
     * - `UnknownMessageIndex`: Message of `index` is unknown.
     * - `WeightOverLimit`: Message execution may use greater than `weight_limit`.
     * 
     * Events:
     * - `OverweightServiced`: On success.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Ump.service_overweight') === '3e0d440993be1d69328adae3a1b30f3261ca945f8f307c396f4de7f51796a0c6'
    }

    /**
     * Service a single overweight upward message.
     * 
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight message to service.
     * - `weight_limit`: The amount of weight that message execution may take.
     * 
     * Errors:
     * - `UnknownMessageIndex`: Message of `index` is unknown.
     * - `WeightOverLimit`: Message execution may use greater than `weight_limit`.
     * 
     * Events:
     * - `OverweightServiced`: On success.
     */
    get asV9291(): {index: bigint, weightLimit: v9291.Weight} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Service a single overweight upward message.
     * 
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight message to service.
     * - `weight_limit`: The amount of weight that message execution may take.
     * 
     * Errors:
     * - `UnknownMessageIndex`: Message of `index` is unknown.
     * - `WeightOverLimit`: Message execution may use greater than `weight_limit`.
     * 
     * Events:
     * - `OverweightServiced`: On success.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Ump.service_overweight') === '80fae8875bf513efc1e06b7dac547fccfc1e5fc45888cc8afd9b43812cf51bf5'
    }

    /**
     * Service a single overweight upward message.
     * 
     * - `origin`: Must pass `ExecuteOverweightOrigin`.
     * - `index`: The index of the overweight message to service.
     * - `weight_limit`: The amount of weight that message execution may take.
     * 
     * Errors:
     * - `UnknownMessageIndex`: Message of `index` is unknown.
     * - `WeightOverLimit`: Message execution may use greater than `weight_limit`.
     * 
     * Events:
     * - `OverweightServiced`: On success.
     */
    get asV9320(): {index: bigint, weightLimit: v9320.Weight} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityApproveAsMultiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.approve_as_multi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get isV1032(): boolean {
        return this._chain.getCallHash('Utility.approve_as_multi') === '3c68db997397f75e3ae5e9c2d20a1518a8d503aa31785d4ef6db71bf1ecb0136'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  NOTE: If this is the final approval, you will want to use `as_multi` instead.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get asV1032(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1032.Timepoint | undefined), callHash: Uint8Array} {
        assert(this.isV1032)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityAsDerivativeCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.as_derivative')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '0f88fee4912a8681b9e5ecd15568926ffe249ea6e0bd3c26afe06b1328cd0f97'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2013(): {index: number, call: v2013.Type_190} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'fba12de1735ce69595dfd43afd117380dd28594899110a3b662eec8cc0d8d117'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2015(): {index: number, call: v2015.Type_192} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'c9072bf9ec58de3a3c11ad9b82154f4249f310f5385a382715bc1123a0afc2e7'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2022(): {index: number, call: v2022.Type_192} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '41a8ee8b6d146c89bb2d4c1e7a05e910651a81d4a8c893ac9afdf9785b16e954'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV2023(): {index: number, call: v2023.Type_194} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '4da2d79488f01ebb708a44e04a467f04571e06fbb6f726b1d4ce0414c9c95b60'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV2024(): {index: number, call: v2024.Type_194} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '74f243368435d8c1bc9594fe3f831b0894433196aafd154c2970d189b025080f'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV2025(): {index: number, call: v2025.Type_195} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '17678b75f4e80d6cfe9612c5cf4e252eef0c978aac057dd993b167ed0f48d2a9'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV2026(): {index: number, call: v2026.Type_194} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '6067d079309983d68d0b24309a8a16d581c3b5907db94cc552606681f456285c'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV2028(): {index: number, call: v2028.Type_199} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '5521e7219d74db1e17d51d5df2b167a3e8025c6e4bbf7a1f509db4a5149d98b4'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV2029(): {index: number, call: v2029.Type_199} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'c37af34a1920a1fa424362b1bb631c022782ebb5e6cc7ef54f78ce5fbb8d6caf'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV2030(): {index: number, call: v2030.Type_138} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '1ae3388309594f9ee3f98b42d8e819834c21c74e8af79a95748141ad1c4efda1'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV9010(): {index: number, call: v9010.Type_138} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'f19bd54ccf1e76ff0fca76cede3f55f914bcd129ada0de2b40f3faf3fedb0aa0'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV9030(): {index: number, call: v9030.Type_138} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'd844e753863ec6d4ccd77a4b26889fcc6b602579c6d397f0e91d89f215045e8f'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV9040(): {index: number, call: v9040.Type_138} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '776515bb5c09a8c6db995ec3f0820cb0f5e86a78fa8587b2cb12bba2f7166528'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV9050(): {index: number, call: v9050.Type_139} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '9291f378dfc49e9c0832f34988dbbc5a079e7c3bc90849cee14bb37ca657a28d'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV9080(): {index: number, call: v9080.Type_138} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '4e8c33d9b2ce2ee4f69dd94c4c0db16d7254d4316ea88997d1ee2feba8c4a7cf'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV9090(): {index: number, call: v9090.Type_138} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '1827429800f4ea3d007697a5eadae959d26d09c21739b023e3714bfdd401454d'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     *  in the Multisig pallet instead.
     * 
     *  NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     *  The dispatch origin for this call must be _Signed_.
     */
    get asV9100(): {index: number, call: v9100.Type_138} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'd2ece7dda5a1f22c3f89c18cdd3aa4985bc90d5456f54f5c19c64c11ec976b0d'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9111(): {index: number, call: v9111.Call} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '03d79fe7e2884d2e3e961ac31f52c9dae2850951737bc06a8d371a029598f984'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9122(): {index: number, call: v9122.Call} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '1a4946f2bc2312c948de3d168b8baeec7b281dc3b7338f15ae97e0c318e7f457'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9130(): {index: number, call: v9130.Call} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '50b4e0a548fae2f49b24d053dfff727558264ca413f9fe1c62015d17304df122'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9160(): {index: number, call: v9160.Call} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '0f1830bde4ed8a997ace70311a6031bab819bcc9fa26faa57173393fa215b6c0'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9170(): {index: number, call: v9170.Call} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '3f09b4353ab8f7e8c75265f3574445686215fd72a1eb8880d3d6586d58cf26d0'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9180(): {index: number, call: v9180.Call} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '99a7f09b7064f4d19d1d0a22235e703c5567695593b23babf5deae0102385745'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9190(): {index: number, call: v9190.Call} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '5571b29daf321842fd8ef2f531c3f76723304ded7db9ddecdfae795c484db2c9'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9220(): {index: number, call: v9220.Call} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '566eacf13243e8152de7e0dab7a784ebf73a2efb6dcea0ea108af870e2f25151'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9230(): {index: number, call: v9230.Call} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'de2260ddcd0e0bb2b2f40fdcf4f4415f92a7826624cb0b863c1c83336d0838ed'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9250(): {index: number, call: v9250.Call} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'c9db2e39cdf046f27a6d525871e9bf17bdb8d605968587f56e569b8c3a71ea91'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9271(): {index: number, call: v9271.Call} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '1dd40a7d719579f85950d5307e23092fd470000bf880a4ce56e370d3b6bfa200'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9291(): {index: number, call: v9291.Call} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '14be5e508c458920237526110b6653cd31f4893857b96594025ec6a90d498cb5'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9300(): {index: number, call: v9300.Call} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '7716438eb208c4bf6557cebee86b689eaacc343d19b27219fc17f1ed697f4306'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9320(): {index: number, call: v9320.Call} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '687500f0e96a5bfd0dba84cf198344c6989d7dbb0506cc08e9e357b5f87cc827'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9340(): {index: number, call: v9340.Call} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === 'cad902df7310211bc7c68b58f1f5fbb623eced9fab9ce6d5b8e99ac435c63290'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9350(): {index: number, call: v9350.Call} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Utility.as_derivative') === '0b7ad05e99556c382297a612e991dc9b04078e8b2b465fa0b65dde25baa95847'
    }

    /**
     * Send a call through an indexed pseudonym of the sender.
     * 
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     * 
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     * 
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     * 
     * The dispatch origin for this call must be _Signed_.
     */
    get asV9370(): {index: number, call: v9370.Call} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityAsLimitedSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.as_limited_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Calls must each fulfil the `IsCallable` filter; it is not cleared before.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_sub` instead.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Utility.as_limited_sub') === '5910af480fb93a41b19a9bdb899397ad2c7ae8d6ec6e11025665fa2eea2645be'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Calls must each fulfil the `IsCallable` filter; it is not cleared before.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_sub` instead.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2005(): {index: number, call: v2005.Type_188} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Calls must each fulfil the `IsCallable` filter; it is not cleared before.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_sub` instead.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('Utility.as_limited_sub') === '2eb14ac5f0e9f702c4c503d88e0040c0adbe8c1cdeebba3d5e5f40eaa1d2d38d'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Calls must each fulfil the `IsCallable` filter; it is not cleared before.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_sub` instead.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2007(): {index: number, call: v2007.Type_189} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_sub` instead.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Utility.as_limited_sub') === '7423fbd677de900802ed8551571c1b936ccd5d6a04c4cab0e960b3e09cfcc482'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  Filter from origin are passed along. The call will be dispatched with an origin which
     *  use the same filter as the origin of this call.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     *  because you expect `proxy` to have been used prior in the call stack and you do not want
     *  the call restrictions to apply to any sub-accounts), then use `as_sub` instead.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2011(): {index: number, call: v2011.Type_190} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityAsMultiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.as_multi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get isV1032(): boolean {
        return this._chain.getCallHash('Utility.as_multi') === 'd9b08179894cda112694144045b3fa1f78c37405395bd432ae24aa81b3ed4c55'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get asV1032(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1032.Timepoint | undefined), call: v1032.Type_110} {
        assert(this.isV1032)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('Utility.as_multi') === 'd5e56c96df573d1b88a8c0efb2cb1ae39ce8ebcc95a69ebfbb634fcc23290172'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get asV1038(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1038.Timepoint | undefined), call: v1038.Type_110} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get isV1039(): boolean {
        return this._chain.getCallHash('Utility.as_multi') === 'ac3d9c66889dce694852f0e09de524cd08e15275e28735bed96cf76916046db2'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get asV1039(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1039.Timepoint | undefined), call: v1039.Type_110} {
        assert(this.isV1039)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Utility.as_multi') === 'e4ecb5d945526edf5e165eee0e0f30ce6f9ff4457608400201f6be6517dfd9a4'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get asV1040(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1040.Timepoint | undefined), call: v1040.Type_110} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('Utility.as_multi') === '4ee886b985acb8d6a2244d984e1af5539c6ad2041a64f78ed28cedc647b28469'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get asV1042(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1042.Timepoint | undefined), call: v1042.Type_110} {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Utility.as_multi') === 'b5a7b92d6e2defd9b36b878d0ace25ce4bd2a00ce5e11e3716855c60018bf1ef'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get asV1050(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1050.Timepoint | undefined), call: v1050.Type_113} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get isV1054(): boolean {
        return this._chain.getCallHash('Utility.as_multi') === '8e4253d138652bdeb7bd817da95aa87a7b6a7e4182543b46c5a6e534796e1e89'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get asV1054(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1054.Timepoint | undefined), call: v1054.Type_113} {
        assert(this.isV1054)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Utility.as_multi') === 'b7e1e5a75e2a0bea579e5626bc6c014c51e2699f650b601e001546e7938bf757'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get asV1055(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1055.Timepoint | undefined), call: v1055.Type_116} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('Utility.as_multi') === '5a5465d2812a25cc61d8544ba1898368446b15948eab26f2f945299d311f8e26'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  # </weight>
     */
    get asV1058(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1058.Timepoint | undefined), call: v1058.Type_176} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  -------------------------------
     *  - Base Weight:
     *      - Create: 46.55 + 0.089 * S µs
     *      - Approve: 34.03 + .112 * S µs
     *      - Complete: 40.36 + .225 * S µs
     *  - DB Weight:
     *      - Reads: Multisig Storage, [Caller Account]
     *      - Writes: Multisig Storage, [Caller Account]
     *  - Plus Call Weight
     *  # </weight>
     */
    get isV1062(): boolean {
        return this._chain.getCallHash('Utility.as_multi') === 'debc03929758998906d936dabffc0a49161f2bdd62704c2913155c8e4c9a8ae9'
    }

    /**
     *  Register approval for a dispatch to be made from a deterministic composite account if
     *  approved by a total of `threshold - 1` of `other_signatories`.
     * 
     *  If there are enough, then dispatch the call.
     * 
     *  Payment: `MultisigDepositBase` will be reserved if this is the first approval, plus
     *  `threshold` times `MultisigDepositFactor`. It is returned once this dispatch happens or
     *  is cancelled.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     *  not the first approval, then it must be `Some`, with the timepoint (block number and
     *  transaction index) of the first approval transaction.
     *  - `call`: The call to be executed.
     * 
     *  NOTE: Unless this is the final approval, you will generally want to use
     *  `approve_as_multi` instead, since it only requires a hash of the call.
     * 
     *  Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     *  on success, result is `Ok` and the result from the interior call, if it was executed,
     *  may be found in the deposited `MultisigExecuted` event.
     * 
     *  # <weight>
     *  - `O(S + Z + Call)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - Up to one binary search and insert (`O(logS + S)`).
     *  - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     *  - One event.
     *  - The weight of the `call`.
     *  - Storage: inserts one item, value size bounded by `MaxSignatories`, with a
     *    deposit taken for its lifetime of
     *    `MultisigDepositBase + threshold * MultisigDepositFactor`.
     *  -------------------------------
     *  - Base Weight:
     *      - Create: 46.55 + 0.089 * S µs
     *      - Approve: 34.03 + .112 * S µs
     *      - Complete: 40.36 + .225 * S µs
     *  - DB Weight:
     *      - Reads: Multisig Storage, [Caller Account]
     *      - Writes: Multisig Storage, [Caller Account]
     *  - Plus Call Weight
     *  # </weight>
     */
    get asV1062(): {threshold: number, otherSignatories: Uint8Array[], maybeTimepoint: (v1062.Timepoint | undefined), call: v1062.Type_175} {
        assert(this.isV1062)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityAsSubCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.as_sub')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  # </weight>
     */
    get isV1032(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === '063f7f595417e0c45593d2b989372ecc976b829d2caa228aee7a05ddcb2786c4'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  # </weight>
     */
    get asV1032(): {index: number, call: v1032.Type_110} {
        assert(this.isV1032)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  # </weight>
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === '0d4cf8c510b4676b31be712ac8fe952e48580b9b78e5e656ad1aca0567189426'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  # </weight>
     */
    get asV1038(): {index: number, call: v1038.Type_110} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  # </weight>
     */
    get isV1039(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === 'f6d346e0c7de296b405fc1d3329b1511ac54dcf44830c5d80d3c8e045df9ea52'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  # </weight>
     */
    get asV1039(): {index: number, call: v1039.Type_110} {
        assert(this.isV1039)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  # </weight>
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === '3e0a10ec7a0e29079388566b6649686a491b2adf7907497b318e1eb8b8c5412b'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  # </weight>
     */
    get asV1040(): {index: number, call: v1040.Type_110} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  # </weight>
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === 'b4e45e01870f72eb837e582e46597219a6e39df0b86f67f508fc221b739bbd1c'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call`.
     *  # </weight>
     */
    get asV1042(): {index: number, call: v1042.Type_110} {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === '06fc59d2c900a2d19e84df7b27738f9b5617a99f34a0a2671ec617f5f4c59582'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  # </weight>
     */
    get asV1050(): {index: number, call: v1050.Type_113} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  # </weight>
     */
    get isV1054(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === '2d170f99a1503ebae25b45f41833f42fe6983b50e1a893adf843f470c7755c17'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  # </weight>
     */
    get asV1054(): {index: number, call: v1054.Type_113} {
        assert(this.isV1054)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  # </weight>
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === 'bc24e8bee2f4805bd39bf6e6045022f35ed191c0c7e70dc93c04ce3537848a47'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  # </weight>
     */
    get asV1055(): {index: number, call: v1055.Type_116} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  # </weight>
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === 'f6770a3c7b6289815ab8f7229a96f07ffee455f73b414420c38dcbebb04cc7b6'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - The weight of the `call` + 10,000.
     *  # </weight>
     */
    get asV1058(): {index: number, call: v1058.Type_176} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV1062(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === '366477ee03884244e18c52f5afec15b917ebb280231548660ec4f46917d3824a'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV1062(): {index: number, call: v1062.Type_175} {
        assert(this.isV1062)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The call must fulfil only the pre-cleared `IsCallable` filter (i.e. only the level of
     *  filtering that remains after calling `take()`).
     * 
     *  NOTE: If you need to ensure that any account-based filtering is honored (i.e. because
     *  you expect `proxy` to have been used prior in the call stack and you want it to apply to
     *  any sub-accounts), then use `as_limited_sub` instead.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === '5910af480fb93a41b19a9bdb899397ad2c7ae8d6ec6e11025665fa2eea2645be'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The call must fulfil only the pre-cleared `IsCallable` filter (i.e. only the level of
     *  filtering that remains after calling `take()`).
     * 
     *  NOTE: If you need to ensure that any account-based filtering is honored (i.e. because
     *  you expect `proxy` to have been used prior in the call stack and you want it to apply to
     *  any sub-accounts), then use `as_limited_sub` instead.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2005(): {index: number, call: v2005.Type_188} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The call must fulfil only the pre-cleared `IsCallable` filter (i.e. only the level of
     *  filtering that remains after calling `take()`).
     * 
     *  NOTE: If you need to ensure that any account-based filtering is honored (i.e. because
     *  you expect `proxy` to have been used prior in the call stack and you want it to apply to
     *  any sub-accounts), then use `as_limited_sub` instead.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === '2eb14ac5f0e9f702c4c503d88e0040c0adbe8c1cdeebba3d5e5f40eaa1d2d38d'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  The call must fulfil only the pre-cleared `IsCallable` filter (i.e. only the level of
     *  filtering that remains after calling `take()`).
     * 
     *  NOTE: If you need to ensure that any account-based filtering is honored (i.e. because
     *  you expect `proxy` to have been used prior in the call stack and you want it to apply to
     *  any sub-accounts), then use `as_limited_sub` instead.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2007(): {index: number, call: v2007.Type_189} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is honored (i.e. because
     *  you expect `proxy` to have been used prior in the call stack and you want it to apply to
     *  any sub-accounts), then use `as_limited_sub` instead.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Utility.as_sub') === '7423fbd677de900802ed8551571c1b936ccd5d6a04c4cab0e960b3e09cfcc482'
    }

    /**
     *  Send a call through an indexed pseudonym of the sender.
     * 
     *  NOTE: If you need to ensure that any account-based filtering is honored (i.e. because
     *  you expect `proxy` to have been used prior in the call stack and you want it to apply to
     *  any sub-accounts), then use `as_limited_sub` instead.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  # <weight>
     *  - Base weight: 2.861 µs
     *  - Plus the weight of the `call`
     *  # </weight>
     */
    get asV2011(): {index: number, call: v2011.Type_190} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityBatchCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.batch')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV1032(): boolean {
        return this._chain.getCallHash('Utility.batch') === '97249c14a5e3e8a0a8e7880e84e36378e5ababf4c91a88f2961b8e6b333e6d69'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV1032(): {calls: v1032.Type_110[]} {
        assert(this.isV1032)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV1038(): boolean {
        return this._chain.getCallHash('Utility.batch') === '8a8d88f148817a72b361ed77634448db8151724ced4652015bec61d835414606'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV1038(): {calls: v1038.Type_110[]} {
        assert(this.isV1038)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV1039(): boolean {
        return this._chain.getCallHash('Utility.batch') === '33d84a33061cb929ba0307af72355c74f11fc06d6ff6c940438f23f799ee5fdd'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV1039(): {calls: v1039.Type_110[]} {
        assert(this.isV1039)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV1040(): boolean {
        return this._chain.getCallHash('Utility.batch') === '15c677900d5f22acd76963ce65c301aeaaa73c90edbc5130be6bdd29969afb9b'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV1040(): {calls: v1040.Type_110[]} {
        assert(this.isV1040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV1042(): boolean {
        return this._chain.getCallHash('Utility.batch') === '0f87b3ddc44aad3584b147cfc219d55971c1dedc1de550b6366cc679ebe859ea'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV1042(): {calls: v1042.Type_110[]} {
        assert(this.isV1042)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Utility.batch') === '6bcb64dca31cbd9dbbb86876f43bd2c793c2bcec2b51c27d682c23c91cbc37bb'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV1050(): {calls: v1050.Type_113[]} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV1054(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'a0f9b1700bfb19f74f943f2ed910d8534ed6b5e763403edccc5b52eb33ae83ec'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV1054(): {calls: v1054.Type_113[]} {
        assert(this.isV1054)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV1055(): boolean {
        return this._chain.getCallHash('Utility.batch') === '4c3b92f0ec0232ee9d8aa8e594c00325acf150ed94a50835afd904df4e6f9648'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV1055(): {calls: v1055.Type_116[]} {
        assert(this.isV1055)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV1058(): boolean {
        return this._chain.getCallHash('Utility.batch') === '12d93d0adbd68324a9502f14566bd4dc533253d494f43b40e35e544eac68182f'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - The sum of the weights of the `calls`.
     *  - One event.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV1058(): {calls: v1058.Type_176[]} {
        assert(this.isV1058)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV1062(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'afac64351ee6401957ee2de0e2ecc6b2454ea49026385a0536b21c00c05409b2'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV1062(): {calls: v1062.Type_175[]} {
        assert(this.isV1062)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop. Calls must fulfil the
     *  `IsCallable` filter unless the origin is `Root`.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2005(): boolean {
        return this._chain.getCallHash('Utility.batch') === '0a34af2ef6b09cd8dc173e19670b94fca5ce5f884c457bf0db76a75c6716a993'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop. Calls must fulfil the
     *  `IsCallable` filter unless the origin is `Root`.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2005(): {calls: v2005.Type_188[]} {
        assert(this.isV2005)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop. Calls must fulfil the
     *  `IsCallable` filter unless the origin is `Root`.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2007(): boolean {
        return this._chain.getCallHash('Utility.batch') === '44ca22c43ec941098d45650a4d72ebc40ed3d9e92a0e6f9cb12f770d93ec9429'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  This will execute until the first one fails and then stop. Calls must fulfil the
     *  `IsCallable` filter unless the origin is `Root`.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2007(): {calls: v2007.Type_189[]} {
        assert(this.isV2007)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Utility.batch') === '1d53bdd09ab321f6d22de1a9d3dd7d430f3b8b23dff59b52d0a800f8b629af1d'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2011(): {calls: v2011.Type_190[]} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2013(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'f3854541346fb47eca2f85d2015bb747aff7555440edf0bde9ac5c7a2c101aad'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2013(): {calls: v2013.Type_190[]} {
        assert(this.isV2013)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2015(): boolean {
        return this._chain.getCallHash('Utility.batch') === '369581b3b7d6c9ba3ac6a245aa294e30371168d6bc58ac01ad5bc9ce9249916f'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2015(): {calls: v2015.Type_192[]} {
        assert(this.isV2015)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2022(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'fd92551c184085340c46804748c06780d252ffec8a6674721502448883da7e68'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2022(): {calls: v2022.Type_192[]} {
        assert(this.isV2022)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2023(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'edb5f12781c04576bdd6d38e03a909e99a34b27dce41bb74e023fafdc877658f'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2023(): {calls: v2023.Type_194[]} {
        assert(this.isV2023)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2024(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'a22da0a397f85948a1d720a429a25f506b27403216d63731f98fc38231c5553b'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2024(): {calls: v2024.Type_194[]} {
        assert(this.isV2024)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2025(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'bd42918841fcf279e207c50b295ed204fe73e96342fb1dd42eddac0f204271c0'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Base weight: 14.39 + .987 * c µs
     *  - Plus the sum of the weights of the `calls`.
     *  - Plus one additional event. (repeat read/write)
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2025(): {calls: v2025.Type_195[]} {
        assert(this.isV2025)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'bc180154fd79ec11bcdf31c9dc500f15f4ba6601dbb5dc7053112b370ba59e29'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2026(): {calls: v2026.Type_194[]} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Utility.batch') === '6ed3664172ef54c4b83e1b2626120267fd25b693b5b3af67bd10bf663f46b33c'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2028(): {calls: v2028.Type_199[]} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Utility.batch') === '399cb3182299d6a9a530a2b65a4cd65938e7c3512fdb3dc99967d3f0528215b4'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2029(): {calls: v2029.Type_199[]} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'd142cd203f5160a5a271c87363278358a6c7af74ef05aa220717ee046138508a'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV2030(): {calls: v2030.Type_138[]} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Utility.batch') === '858e180a9c9aabe16c6940951f018f98a4368e50748304088c251420bede34cc'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV9010(): {calls: v9010.Type_138[]} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Utility.batch') === '7f494e9a70ec230cefeb1e5baf52f6ff9e4982cc4358d745e6bd475c70418117'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV9030(): {calls: v9030.Type_138[]} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Utility.batch') === '23e9dc8610df96dd6e3348beef93a7ebff9634be78a6388e2ae852f229736fd2'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV9040(): {calls: v9040.Type_138[]} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Utility.batch') === '821cb9dd204ccbb7005a38b46e31c9de3ac115ddc25ada602e93732db9f2a46b'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV9050(): {calls: v9050.Type_139[]} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'c1edba32f4f7288c35b0f624e638d908a83aa0503acc2d7e0d142cbaf16cb492'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV9080(): {calls: v9080.Type_138[]} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Utility.batch') === '7b87010240185067e8fb7e2c551fb8aed9b5866b98f469ce5b7a85cbc2307adb'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV9090(): {calls: v9090.Type_138[]} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Utility.batch') === '45a345f026cf0ecdd1b165ef335bfc1045c673925bd1b2f11ec81407b76042b0'
    }

    /**
     *  Send a batch of dispatch calls.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     * 
     *  This will return `Ok` in all circumstances. To determine the success of the batch, an
     *  event is deposited. If a call failed and the batch was interrupted, then the
     *  `BatchInterrupted` event is deposited, along with the number of successful calls made
     *  and the error of the failed call. If all were successful, then the `BatchCompleted`
     *  event is deposited.
     */
    get asV9100(): {calls: v9100.Type_138[]} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Utility.batch') === '24d45e7a735cd630cb9f3c7155c2fcfe1b70b4e4ba1d7bb26c8188817b942754'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9111(): {calls: v9111.Call[]} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Utility.batch') === '424dc12dcacdf2d18ca16ecfeae1992dd87f3f05f67dab37f0781666c8a40531'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9122(): {calls: v9122.Call[]} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Utility.batch') === '6afa798966c56bc7e09249626850aab68b3eeb35ccc064af07e09e26c01deb2c'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9130(): {calls: v9130.Call[]} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'a55e731beed553bb087c8b7922c434f0ea14c4e41ab3a342ec2f1bf30e621cc2'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9160(): {calls: v9160.Call[]} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Utility.batch') === '6d5b2934570a471748c938a09b2a2438e6917356046dc1893c47643192073589'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9170(): {calls: v9170.Call[]} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Utility.batch') === '2793f6a8e899897ca1d832db6e5bf6344c67b7a423c1d5cba129353f009e7dcc'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9180(): {calls: v9180.Call[]} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'b5270f999a871e326ad541c56996a9f657ad6720e8e583d79d8facd27ca6353a'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9190(): {calls: v9190.Call[]} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'db09500e18053f79448a005faa37117c2b42e4c663873a09e88018eb2aff335f'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9220(): {calls: v9220.Call[]} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Utility.batch') === '466b18f848629bae32e70a8495e6e3908caaa9481e17aad0c09f77f55953e69a'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9230(): {calls: v9230.Call[]} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Utility.batch') === '4b85c1b4abbf31729c1453912a5f3442c46aaa9d12df0689c53772e112c5de5f'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9250(): {calls: v9250.Call[]} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Utility.batch') === '617d40d3a60757264fd521f30fc767ba5fa091ef38923207ad906110326c1af2'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9271(): {calls: v9271.Call[]} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'ed655ce179022fd12df3c2d35816f3ef516d03e0f801ed8f6ad39d4d63284ab4'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9291(): {calls: v9291.Call[]} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Utility.batch') === 'f82da1b6e1cb8187be486f8831c8972330088e92184cba9b64a14d4e726c7887'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9300(): {calls: v9300.Call[]} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Utility.batch') === '3b71c6a302c8cfcf60384062233797fa096f6bd568f351be02636bccdf39fbb2'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9320(): {calls: v9320.Call[]} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Utility.batch') === '14032a7e2608284e4330f508c1d234118fb8b4c43c3f714a7477bd01ba98212d'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9340(): {calls: v9340.Call[]} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Utility.batch') === '4e79443fe37f45ebb7efb230f6c2f30c15d5c3292ed1365a195a28a7a9b137a6'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9350(): {calls: v9350.Call[]} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Utility.batch') === '1befd5cadcf0f7560e8f4f0f1ce1e0cc377cf04b50d0cc25a7926e71b1515bd8'
    }

    /**
     * Send a batch of dispatch calls.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     * 
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     */
    get asV9370(): {calls: v9370.Call[]} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityBatchAllCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.batch_all')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV2026(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'bc180154fd79ec11bcdf31c9dc500f15f4ba6601dbb5dc7053112b370ba59e29'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Trait::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV2026(): {calls: v2026.Type_194[]} {
        assert(this.isV2026)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '6ed3664172ef54c4b83e1b2626120267fd25b693b5b3af67bd10bf663f46b33c'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV2028(): {calls: v2028.Type_199[]} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV2029(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '399cb3182299d6a9a530a2b65a4cd65938e7c3512fdb3dc99967d3f0528215b4'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV2029(): {calls: v2029.Type_199[]} {
        assert(this.isV2029)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV2030(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'd142cd203f5160a5a271c87363278358a6c7af74ef05aa220717ee046138508a'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV2030(): {calls: v2030.Type_138[]} {
        assert(this.isV2030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '858e180a9c9aabe16c6940951f018f98a4368e50748304088c251420bede34cc'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV9010(): {calls: v9010.Type_138[]} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '7f494e9a70ec230cefeb1e5baf52f6ff9e4982cc4358d745e6bd475c70418117'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV9030(): {calls: v9030.Type_138[]} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV9040(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '23e9dc8610df96dd6e3348beef93a7ebff9634be78a6388e2ae852f229736fd2'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV9040(): {calls: v9040.Type_138[]} {
        assert(this.isV9040)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV9050(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '821cb9dd204ccbb7005a38b46e31c9de3ac115ddc25ada602e93732db9f2a46b'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV9050(): {calls: v9050.Type_139[]} {
        assert(this.isV9050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV9080(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'c1edba32f4f7288c35b0f624e638d908a83aa0503acc2d7e0d142cbaf16cb492'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin.
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV9080(): {calls: v9080.Type_138[]} {
        assert(this.isV9080)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV9090(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '7b87010240185067e8fb7e2c551fb8aed9b5866b98f469ce5b7a85cbc2307adb'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV9090(): {calls: v9090.Type_138[]} {
        assert(this.isV9090)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '45a345f026cf0ecdd1b165ef335bfc1045c673925bd1b2f11ec81407b76042b0'
    }

    /**
     *  Send a batch of dispatch calls and atomically execute them.
     *  The whole transaction will rollback and fail if any of the calls failed.
     * 
     *  May be called from any origin.
     * 
     *  - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *    exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     *  If origin is root then call are dispatch without checking origin filter. (This includes
     *  bypassing `frame_system::Config::BaseCallFilter`).
     * 
     *  # <weight>
     *  - Complexity: O(C) where C is the number of calls to be batched.
     *  # </weight>
     */
    get asV9100(): {calls: v9100.Type_138[]} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '24d45e7a735cd630cb9f3c7155c2fcfe1b70b4e4ba1d7bb26c8188817b942754'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9111(): {calls: v9111.Call[]} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '424dc12dcacdf2d18ca16ecfeae1992dd87f3f05f67dab37f0781666c8a40531'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9122(): {calls: v9122.Call[]} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '6afa798966c56bc7e09249626850aab68b3eeb35ccc064af07e09e26c01deb2c'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9130(): {calls: v9130.Call[]} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'a55e731beed553bb087c8b7922c434f0ea14c4e41ab3a342ec2f1bf30e621cc2'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9160(): {calls: v9160.Call[]} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '6d5b2934570a471748c938a09b2a2438e6917356046dc1893c47643192073589'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9170(): {calls: v9170.Call[]} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '2793f6a8e899897ca1d832db6e5bf6344c67b7a423c1d5cba129353f009e7dcc'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9180(): {calls: v9180.Call[]} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'b5270f999a871e326ad541c56996a9f657ad6720e8e583d79d8facd27ca6353a'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9190(): {calls: v9190.Call[]} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'db09500e18053f79448a005faa37117c2b42e4c663873a09e88018eb2aff335f'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9220(): {calls: v9220.Call[]} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '466b18f848629bae32e70a8495e6e3908caaa9481e17aad0c09f77f55953e69a'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9230(): {calls: v9230.Call[]} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '4b85c1b4abbf31729c1453912a5f3442c46aaa9d12df0689c53772e112c5de5f'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9250(): {calls: v9250.Call[]} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '617d40d3a60757264fd521f30fc767ba5fa091ef38923207ad906110326c1af2'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9271(): {calls: v9271.Call[]} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'ed655ce179022fd12df3c2d35816f3ef516d03e0f801ed8f6ad39d4d63284ab4'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9291(): {calls: v9291.Call[]} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === 'f82da1b6e1cb8187be486f8831c8972330088e92184cba9b64a14d4e726c7887'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9300(): {calls: v9300.Call[]} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '3b71c6a302c8cfcf60384062233797fa096f6bd568f351be02636bccdf39fbb2'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9320(): {calls: v9320.Call[]} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '14032a7e2608284e4330f508c1d234118fb8b4c43c3f714a7477bd01ba98212d'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9340(): {calls: v9340.Call[]} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '4e79443fe37f45ebb7efb230f6c2f30c15d5c3292ed1365a195a28a7a9b137a6'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9350(): {calls: v9350.Call[]} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Utility.batch_all') === '1befd5cadcf0f7560e8f4f0f1ce1e0cc377cf04b50d0cc25a7926e71b1515bd8'
    }

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9370(): {calls: v9370.Call[]} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityCancelAsMultiCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.cancel_as_multi')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     *  for this operation will be unreserved on success.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `timepoint`: The timepoint (block number and transaction index) of the first approval
     *  transaction for this dispatch.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - One event.
     *  - I/O: 1 read `O(S)`, one remove.
     *  - Storage: removes one item.
     *  # </weight>
     */
    get isV1032(): boolean {
        return this._chain.getCallHash('Utility.cancel_as_multi') === '4ccc75a4f739c659f177e3df98fba2ea59ddade74c4ebccd51b2fc4c52e923af'
    }

    /**
     *  Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     *  for this operation will be unreserved on success.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `threshold`: The total number of approvals for this dispatch before it is executed.
     *  - `other_signatories`: The accounts (other than the sender) who can approve this
     *  dispatch. May not be empty.
     *  - `timepoint`: The timepoint (block number and transaction index) of the first approval
     *  transaction for this dispatch.
     *  - `call_hash`: The hash of the call to be executed.
     * 
     *  # <weight>
     *  - `O(S)`.
     *  - Up to one balance-reserve or unreserve operation.
     *  - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     *    signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     *  - One encode & hash, both of complexity `O(S)`.
     *  - One event.
     *  - I/O: 1 read `O(S)`, one remove.
     *  - Storage: removes one item.
     *  # </weight>
     */
    get asV1032(): {threshold: number, otherSignatories: Uint8Array[], timepoint: v1032.Timepoint, callHash: Uint8Array} {
        assert(this.isV1032)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityDispatchAsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.dispatch_as')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9130(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '2de0291a9f2c54b8ea7d12c1374d708432df0dbeec3a1291b31767e00c2bf332'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9130(): {asOrigin: v9130.OriginCaller, call: v9130.Call} {
        assert(this.isV9130)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '1d4dcc19515ebe67b9ca249dc4a27d4bb9cda9338c7866da560e806e5a6cc6af'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9160(): {asOrigin: v9160.OriginCaller, call: v9160.Call} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9170(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'defdc577ede77b2e032f4e1687276debea911428daaf39dbf385e589b41b27f8'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9170(): {asOrigin: v9170.OriginCaller, call: v9170.Call} {
        assert(this.isV9170)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9180(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'cef1528071d7013aa6b46d838ad3bb5296c9301a7ceb8a2ee6cc67ac3f9bc06a'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9180(): {asOrigin: v9180.OriginCaller, call: v9180.Call} {
        assert(this.isV9180)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9190(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'f1f9f12bbab30348ffa569b2f409672ecf910f6245699ede6145f9cc7bf66952'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9190(): {asOrigin: v9190.OriginCaller, call: v9190.Call} {
        assert(this.isV9190)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '213d1674bb334f8bbcf3a2f4db2331e667e1e43b27e4f29abb817d04823eca30'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9220(): {asOrigin: v9220.OriginCaller, call: v9220.Call} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '852d40c5161f065765ad407b61fc1c9efb7f88c4197aa4794efcb314adfdbe26'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9230(): {asOrigin: v9230.OriginCaller, call: v9230.Call} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '437d521b5c870599d3864688a8fdc6c6acd2ccace003945e67c88a691a9fe665'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9250(): {asOrigin: v9250.OriginCaller, call: v9250.Call} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'c41890cf9dfbecd3fc43b5502c6c899845cbcd60d02c581120119e92480671b2'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9271(): {asOrigin: v9271.OriginCaller, call: v9271.Call} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '7b8e18e83fa827e3a3a9ab35c9f754ec4f2b597998c240e0f7699ea65b056884'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9291(): {asOrigin: v9291.OriginCaller, call: v9291.Call} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === 'c888051b1b67acf5413bf1502e5b01e20ea21eca71c9dfae4566cc5427ae56bd'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9300(): {asOrigin: v9300.OriginCaller, call: v9300.Call} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '668d132bdb622df0a1cac4663674ece510ad02bc0e38dd8cca8d445092be2949'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9320(): {asOrigin: v9320.OriginCaller, call: v9320.Call} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '03d8131ecf3fcb4d919a3ae5f4c96b4b264aed48fcaee084da6328d066758396'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9340(): {asOrigin: v9340.OriginCaller, call: v9340.Call} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '0e5b5687471ec3c4a8d2760a2c01b397de14c494200783bd8ceb8cb8be806d2d'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9350(): {asOrigin: v9350.OriginCaller, call: v9350.Call} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Utility.dispatch_as') === '378b86c985c3967183c20eaae55b745813a9ee16db271436a9493239444fd959'
    }

    /**
     * Dispatches a function call with a provided origin.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * # <weight>
     * - O(1).
     * - Limited storage reads.
     * - One DB write (event).
     * - Weight of derivative `call` execution + T::WeightInfo::dispatch_as().
     * # </weight>
     */
    get asV9370(): {asOrigin: v9370.OriginCaller, call: v9370.Call} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityForceBatchCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.force_batch')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9220(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === 'db09500e18053f79448a005faa37117c2b42e4c663873a09e88018eb2aff335f'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9220(): {calls: v9220.Call[]} {
        assert(this.isV9220)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '466b18f848629bae32e70a8495e6e3908caaa9481e17aad0c09f77f55953e69a'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9230(): {calls: v9230.Call[]} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9250(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '4b85c1b4abbf31729c1453912a5f3442c46aaa9d12df0689c53772e112c5de5f'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9250(): {calls: v9250.Call[]} {
        assert(this.isV9250)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9271(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '617d40d3a60757264fd521f30fc767ba5fa091ef38923207ad906110326c1af2'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9271(): {calls: v9271.Call[]} {
        assert(this.isV9271)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === 'ed655ce179022fd12df3c2d35816f3ef516d03e0f801ed8f6ad39d4d63284ab4'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9291(): {calls: v9291.Call[]} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9300(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === 'f82da1b6e1cb8187be486f8831c8972330088e92184cba9b64a14d4e726c7887'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9300(): {calls: v9300.Call[]} {
        assert(this.isV9300)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '3b71c6a302c8cfcf60384062233797fa096f6bd568f351be02636bccdf39fbb2'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then call are dispatch without checking origin filter. (This includes
     * bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9320(): {calls: v9320.Call[]} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '14032a7e2608284e4330f508c1d234118fb8b4c43c3f714a7477bd01ba98212d'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9340(): {calls: v9340.Call[]} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '4e79443fe37f45ebb7efb230f6c2f30c15d5c3292ed1365a195a28a7a9b137a6'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9350(): {calls: v9350.Call[]} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Utility.force_batch') === '1befd5cadcf0f7560e8f4f0f1ce1e0cc377cf04b50d0cc25a7926e71b1515bd8'
    }

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     * 
     * May be called from any origin except `None`.
     * 
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     *   exceed the constant: `batched_calls_limit` (available in constant metadata).
     * 
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     * 
     * # <weight>
     * - Complexity: O(C) where C is the number of calls to be batched.
     * # </weight>
     */
    get asV9370(): {calls: v9370.Call[]} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class UtilityWithWeightCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Utility.with_weight')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV9340(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '4b82c024fa7ca8fca9be78a3888bcb98abf93d317454ce3910842d4222b2a129'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV9340(): {call: v9340.Call, weight: v9340.Weight} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV9350(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === 'd67e7c8299aba64cb2a9e8fdaa0a72b955bebf0269211ab885d2db9120e2734e'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV9350(): {call: v9350.Call, weight: v9350.Weight} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('Utility.with_weight') === '88a66429a9f28f90662006f9565ec0675de1701c9692b9b8447768a826df1f13'
    }

    /**
     * Dispatch a function call with a specified weight.
     * 
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     * 
     * The dispatch origin for this call must be _Root_.
     */
    get asV9370(): {call: v9370.Call, weight: v9370.Weight} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingForceVestedTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.force_vested_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Force a vested transfer.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `source`: The account whose funds should be transferred.
     *  - `target`: The account that should be transferred the vested funds.
     *  - `amount`: The amount of funds to transfer and will be vested.
     *  - `schedule`: The vesting schedule attached to the transfer.
     * 
     *  Emits `VestingCreated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 4 Reads, 4 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account, Source Account
     *      - Writes: Vesting Storage, Balances Locks, Target Account, Source Account
     *  - Benchmark: 100.3 + .365 * l µs (min square analysis)
     *  - Using 100 µs fixed. Assuming less than 50 locks on any user, else we may want factor in number of locks.
     *  # </weight>
     */
    get isV2011(): boolean {
        return this._chain.getCallHash('Vesting.force_vested_transfer') === 'fcf674438435841ae531ade33d5da929e15b8eb77d9e7e57de7e3ab4349cd5de'
    }

    /**
     *  Force a vested transfer.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `source`: The account whose funds should be transferred.
     *  - `target`: The account that should be transferred the vested funds.
     *  - `amount`: The amount of funds to transfer and will be vested.
     *  - `schedule`: The vesting schedule attached to the transfer.
     * 
     *  Emits `VestingCreated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 4 Reads, 4 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account, Source Account
     *      - Writes: Vesting Storage, Balances Locks, Target Account, Source Account
     *  - Benchmark: 100.3 + .365 * l µs (min square analysis)
     *  - Using 100 µs fixed. Assuming less than 50 locks on any user, else we may want factor in number of locks.
     *  # </weight>
     */
    get asV2011(): {source: Uint8Array, target: Uint8Array, schedule: v2011.VestingInfo} {
        assert(this.isV2011)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Force a vested transfer.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `source`: The account whose funds should be transferred.
     *  - `target`: The account that should be transferred the vested funds.
     *  - `amount`: The amount of funds to transfer and will be vested.
     *  - `schedule`: The vesting schedule attached to the transfer.
     * 
     *  Emits `VestingCreated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 4 Reads, 4 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account, Source Account
     *      - Writes: Vesting Storage, Balances Locks, Target Account, Source Account
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Vesting.force_vested_transfer') === '554d1f39e9f4e4663daedd61474fa370dcb45b83a4deb1389e96844935fd266e'
    }

    /**
     *  Force a vested transfer.
     * 
     *  The dispatch origin for this call must be _Root_.
     * 
     *  - `source`: The account whose funds should be transferred.
     *  - `target`: The account that should be transferred the vested funds.
     *  - `amount`: The amount of funds to transfer and will be vested.
     *  - `schedule`: The vesting schedule attached to the transfer.
     * 
     *  Emits `VestingCreated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 4 Reads, 4 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account, Source Account
     *      - Writes: Vesting Storage, Balances Locks, Target Account, Source Account
     *  # </weight>
     */
    get asV2028(): {source: v2028.LookupSource, target: v2028.LookupSource, schedule: v2028.VestingInfo} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Force a vested transfer.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The account whose funds should be transferred.
     * - `target`: The account that should be transferred the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     * 
     * Emits `VestingCreated`.
     * 
     * NOTE: This will unlock all schedules through the current block.
     * 
     * # <weight>
     * - `O(1)`.
     * - DbWeight: 4 Reads, 4 Writes
     *     - Reads: Vesting Storage, Balances Locks, Target Account, Source Account
     *     - Writes: Vesting Storage, Balances Locks, Target Account, Source Account
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Vesting.force_vested_transfer') === 'fcf875d71f02d4cc33d9f1e8fc540430de8155209696fe7c9996d5d479e3d5c3'
    }

    /**
     * Force a vested transfer.
     * 
     * The dispatch origin for this call must be _Root_.
     * 
     * - `source`: The account whose funds should be transferred.
     * - `target`: The account that should be transferred the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     * 
     * Emits `VestingCreated`.
     * 
     * NOTE: This will unlock all schedules through the current block.
     * 
     * # <weight>
     * - `O(1)`.
     * - DbWeight: 4 Reads, 4 Writes
     *     - Reads: Vesting Storage, Balances Locks, Target Account, Source Account
     *     - Writes: Vesting Storage, Balances Locks, Target Account, Source Account
     * # </weight>
     */
    get asV9111(): {source: v9111.MultiAddress, target: v9111.MultiAddress, schedule: v9111.VestingInfo} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingMergeSchedulesCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.merge_schedules')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
     * the highest possible start and end blocks. If both schedules have already started the
     * current block will be used as the schedule start; with the caveat that if one schedule
     * is finished by the current block, the other will be treated as the new merged schedule,
     * unmodified.
     * 
     * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
     * NOTE: This will unlock all schedules through the current block prior to merging.
     * NOTE: If both schedules have ended by the current block, no new schedule will be created
     * and both will be removed.
     * 
     * Merged schedule attributes:
     * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
     *   current_block)`.
     * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
     * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `schedule1_index`: index of the first schedule to merge.
     * - `schedule2_index`: index of the second schedule to merge.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Vesting.merge_schedules') === 'fc0db27e3f68971976c0913a7fc03f1b8221d054fbbbca956c367c00c0639eea'
    }

    /**
     * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
     * the highest possible start and end blocks. If both schedules have already started the
     * current block will be used as the schedule start; with the caveat that if one schedule
     * is finished by the current block, the other will be treated as the new merged schedule,
     * unmodified.
     * 
     * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
     * NOTE: This will unlock all schedules through the current block prior to merging.
     * NOTE: If both schedules have ended by the current block, no new schedule will be created
     * and both will be removed.
     * 
     * Merged schedule attributes:
     * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
     *   current_block)`.
     * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
     * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `schedule1_index`: index of the first schedule to merge.
     * - `schedule2_index`: index of the second schedule to merge.
     */
    get asV9111(): {schedule1Index: number, schedule2Index: number} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingVestCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.vest')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unlock any vested funds of the sender account.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have funds still
     *  locked under this module.
     * 
     *  Emits either `VestingCompleted` or `VestingUpdated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One balance-lock operation.
     *  - One storage read (codec `O(1)`) and up to one removal.
     *  - One event.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Vesting.vest') === '01f2f9c28aa1d4d36a81ff042620b6677d25bf07c2bf4acc37b58658778a4fca'
    }

    /**
     *  Unlock any vested funds of the sender account.
     * 
     *  The dispatch origin for this call must be _Signed_ and the sender must have funds still
     *  locked under this module.
     * 
     *  Emits either `VestingCompleted` or `VestingUpdated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - One balance-lock operation.
     *  - One storage read (codec `O(1)`) and up to one removal.
     *  - One event.
     *  # </weight>
     */
    get asV1050(): null {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingVestOtherCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.vest_other')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Unlock any vested funds of a `target` account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `target`: The account whose vested funds should be unlocked. Must have funds still
     *  locked under this module.
     * 
     *  Emits either `VestingCompleted` or `VestingUpdated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - Up to one account lookup.
     *  - One balance-lock operation.
     *  - One storage read (codec `O(1)`) and up to one removal.
     *  - One event.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Vesting.vest_other') === '66d8abf7976ff596d8d614948b9d84cb24f0b898d88d24eb2cc035ae5e93c7b8'
    }

    /**
     *  Unlock any vested funds of a `target` account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `target`: The account whose vested funds should be unlocked. Must have funds still
     *  locked under this module.
     * 
     *  Emits either `VestingCompleted` or `VestingUpdated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - Up to one account lookup.
     *  - One balance-lock operation.
     *  - One storage read (codec `O(1)`) and up to one removal.
     *  - One event.
     *  # </weight>
     */
    get asV1050(): {target: Uint8Array} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Unlock any vested funds of a `target` account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `target`: The account whose vested funds should be unlocked. Must have funds still
     *  locked under this module.
     * 
     *  Emits either `VestingCompleted` or `VestingUpdated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 3 Reads, 3 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account
     *      - Writes: Vesting Storage, Balances Locks, Target Account
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Vesting.vest_other') === 'b473bcbba83335e310f2f681307dcf6b16b8d79ec99a4fb2202c34bed7de3b65'
    }

    /**
     *  Unlock any vested funds of a `target` account.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `target`: The account whose vested funds should be unlocked. Must have funds still
     *  locked under this module.
     * 
     *  Emits either `VestingCompleted` or `VestingUpdated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 3 Reads, 3 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account
     *      - Writes: Vesting Storage, Balances Locks, Target Account
     *  # </weight>
     */
    get asV2028(): {target: v2028.LookupSource} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Unlock any vested funds of a `target` account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `target`: The account whose vested funds should be unlocked. Must have funds still
     * locked under this pallet.
     * 
     * Emits either `VestingCompleted` or `VestingUpdated`.
     * 
     * # <weight>
     * - `O(1)`.
     * - DbWeight: 3 Reads, 3 Writes
     *     - Reads: Vesting Storage, Balances Locks, Target Account
     *     - Writes: Vesting Storage, Balances Locks, Target Account
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Vesting.vest_other') === '8142da248a3023c20f65ce8f6287f9eaf75336ab8815cb15537149abcdd0c20c'
    }

    /**
     * Unlock any vested funds of a `target` account.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `target`: The account whose vested funds should be unlocked. Must have funds still
     * locked under this pallet.
     * 
     * Emits either `VestingCompleted` or `VestingUpdated`.
     * 
     * # <weight>
     * - `O(1)`.
     * - DbWeight: 3 Reads, 3 Writes
     *     - Reads: Vesting Storage, Balances Locks, Target Account
     *     - Writes: Vesting Storage, Balances Locks, Target Account
     * # </weight>
     */
    get asV9111(): {target: v9111.MultiAddress} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class VestingVestedTransferCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Vesting.vested_transfer')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Create a vested transfer. 
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `target`: The account that should be transferred the vested funds.
     *  - `amount`: The amount of funds to transfer and will be vested.
     *  - `schedule`: The vesting schedule attached to the transfer.
     * 
     *  Emits `VestingCreated`.
     * 
     *  # <weight>
     *  - Creates a new storage entry, but is protected by a minimum transfer
     * 	   amount needed to succeed.
     *  # </weight>
     */
    get isV1050(): boolean {
        return this._chain.getCallHash('Vesting.vested_transfer') === '188228eb2dfaa5e9c0f746e0eca8994098b3ac9b34810216e603d8147428161b'
    }

    /**
     *  Create a vested transfer. 
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `target`: The account that should be transferred the vested funds.
     *  - `amount`: The amount of funds to transfer and will be vested.
     *  - `schedule`: The vesting schedule attached to the transfer.
     * 
     *  Emits `VestingCreated`.
     * 
     *  # <weight>
     *  - Creates a new storage entry, but is protected by a minimum transfer
     * 	   amount needed to succeed.
     *  # </weight>
     */
    get asV1050(): {target: Uint8Array, schedule: v1050.VestingInfo} {
        assert(this.isV1050)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Create a vested transfer.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `target`: The account that should be transferred the vested funds.
     *  - `amount`: The amount of funds to transfer and will be vested.
     *  - `schedule`: The vesting schedule attached to the transfer.
     * 
     *  Emits `VestingCreated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 3 Reads, 3 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]
     *      - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]
     *  # </weight>
     */
    get isV2028(): boolean {
        return this._chain.getCallHash('Vesting.vested_transfer') === '0f6872962312eb70cc69daaab6af7934f93006a324730cd95bfebe233c99e338'
    }

    /**
     *  Create a vested transfer.
     * 
     *  The dispatch origin for this call must be _Signed_.
     * 
     *  - `target`: The account that should be transferred the vested funds.
     *  - `amount`: The amount of funds to transfer and will be vested.
     *  - `schedule`: The vesting schedule attached to the transfer.
     * 
     *  Emits `VestingCreated`.
     * 
     *  # <weight>
     *  - `O(1)`.
     *  - DbWeight: 3 Reads, 3 Writes
     *      - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]
     *      - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]
     *  # </weight>
     */
    get asV2028(): {target: v2028.LookupSource, schedule: v2028.VestingInfo} {
        assert(this.isV2028)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Create a vested transfer.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `target`: The account receiving the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     * 
     * Emits `VestingCreated`.
     * 
     * NOTE: This will unlock all schedules through the current block.
     * 
     * # <weight>
     * - `O(1)`.
     * - DbWeight: 3 Reads, 3 Writes
     *     - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]
     *     - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]
     * # </weight>
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('Vesting.vested_transfer') === 'e10524b55ce1ea33d3b1d4a103e874a701990c6659bea3d0b8c94248699fe975'
    }

    /**
     * Create a vested transfer.
     * 
     * The dispatch origin for this call must be _Signed_.
     * 
     * - `target`: The account receiving the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     * 
     * Emits `VestingCreated`.
     * 
     * NOTE: This will unlock all schedules through the current block.
     * 
     * # <weight>
     * - `O(1)`.
     * - DbWeight: 3 Reads, 3 Writes
     *     - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]
     *     - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]
     * # </weight>
     */
    get asV9111(): {target: v9111.MultiAddress, schedule: v9111.VestingInfo} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class VoterListPutInFrontOfCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VoterList.put_in_front_of')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Move the caller's Id directly in front of `lighter`.
     * 
     * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
     * the account going in front of `lighter`.
     * 
     * Only works if
     * - both nodes are within the same bag,
     * - and `origin` has a greater `Score` than `lighter`.
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('VoterList.put_in_front_of') === '1c9b6f4fe2c3f09518b5cf691b90a9cfbbb049860f2d665fdf2f18450ebe9b2f'
    }

    /**
     * Move the caller's Id directly in front of `lighter`.
     * 
     * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
     * the account going in front of `lighter`.
     * 
     * Only works if
     * - both nodes are within the same bag,
     * - and `origin` has a greater `Score` than `lighter`.
     */
    get asV9230(): {lighter: Uint8Array} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Move the caller's Id directly in front of `lighter`.
     * 
     * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
     * the account going in front of `lighter`.
     * 
     * Only works if
     * - both nodes are within the same bag,
     * - and `origin` has a greater `Score` than `lighter`.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('VoterList.put_in_front_of') === '7e9287cfca368105d1ffcdf529d05020ce712c640b68f9f0b0e8791c224766ff'
    }

    /**
     * Move the caller's Id directly in front of `lighter`.
     * 
     * The dispatch origin for this call must be _Signed_ and can only be called by the Id of
     * the account going in front of `lighter`.
     * 
     * Only works if
     * - both nodes are within the same bag,
     * - and `origin` has a greater `Score` than `lighter`.
     */
    get asV9291(): {lighter: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class VoterListRebagCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'VoterList.rebag')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
     * changed its score that it should properly fall into a different bag than its current
     * one.
     * 
     * Anyone can call this function about any potentially dislocated account.
     * 
     * Will always update the stored score of `dislocated` to the correct score, based on
     * `ScoreProvider`.
     * 
     * If `dislocated` does not exists, it returns an error.
     */
    get isV9230(): boolean {
        return this._chain.getCallHash('VoterList.rebag') === '6f1b791f1be804afc4e38eb1e926ba86935e013132cb323a061f4b76a89cbd3e'
    }

    /**
     * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
     * changed its score that it should properly fall into a different bag than its current
     * one.
     * 
     * Anyone can call this function about any potentially dislocated account.
     * 
     * Will always update the stored score of `dislocated` to the correct score, based on
     * `ScoreProvider`.
     * 
     * If `dislocated` does not exists, it returns an error.
     */
    get asV9230(): {dislocated: Uint8Array} {
        assert(this.isV9230)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
     * changed its score that it should properly fall into a different bag than its current
     * one.
     * 
     * Anyone can call this function about any potentially dislocated account.
     * 
     * Will always update the stored score of `dislocated` to the correct score, based on
     * `ScoreProvider`.
     * 
     * If `dislocated` does not exists, it returns an error.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('VoterList.rebag') === 'a58fcb324a2ede36cc16fb0fd8f25f392cc3d269670833be7cb969809a50d729'
    }

    /**
     * Declare that some `dislocated` account has, through rewards or penalties, sufficiently
     * changed its score that it should properly fall into a different bag than its current
     * one.
     * 
     * Anyone can call this function about any potentially dislocated account.
     * 
     * Will always update the stored score of `dislocated` to the correct score, based on
     * `ScoreProvider`.
     * 
     * If `dislocated` does not exists, it returns an error.
     */
    get asV9291(): {dislocated: v9291.MultiAddress} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }
}

export class WhitelistDispatchWhitelistedCallCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Whitelist.dispatch_whitelisted_call')
        this._chain = ctx._chain
        this.call = call
    }

    get isV9320(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call') === '8bb6d35aae5bc2e1a494513bdb1a02b950f2f388cf40b29eb38a4966d6c9f78f'
    }

    get asV9320(): {callHash: Uint8Array, callWeightWitness: v9320.Weight} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    get isV9350(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call') === '467e7b2aa84bd235d9f3a7f5ad68eb8b90858874c09d752f1eb716382fc6b96e'
    }

    get asV9350(): {callHash: Uint8Array, callEncodedLen: number, callWeightWitness: v9350.Weight} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }
}

export class WhitelistDispatchWhitelistedCallWithPreimageCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Whitelist.dispatch_whitelisted_call_with_preimage')
        this._chain = ctx._chain
        this.call = call
    }

    get isV9320(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === '5bf91185f80d49c2953e99e69fb19b452576cbecd27b5f836250f36620649f9c'
    }

    get asV9320(): {call: v9320.Call} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    get isV9340(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === '366990dacc670afbb1755d8529b6f3b93e0f5531e5933d7dbaf62f417d97229e'
    }

    get asV9340(): {call: v9340.Call} {
        assert(this.isV9340)
        return this._chain.decodeCall(this.call)
    }

    get isV9350(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === 'beeab7c5ecd3f8c8cf3944791f80151827ea86304099fa2c0192f16e7e380a69'
    }

    get asV9350(): {call: v9350.Call} {
        assert(this.isV9350)
        return this._chain.decodeCall(this.call)
    }

    get isV9370(): boolean {
        return this._chain.getCallHash('Whitelist.dispatch_whitelisted_call_with_preimage') === '1a84475e5c559241fa3bf697903f2c32a9e86a49ec89b03e6ee5b6c3b91bb7a2'
    }

    get asV9370(): {call: v9370.Call} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class WhitelistRemoveWhitelistedCallCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Whitelist.remove_whitelisted_call')
        this._chain = ctx._chain
        this.call = call
    }

    get isV9320(): boolean {
        return this._chain.getCallHash('Whitelist.remove_whitelisted_call') === 'b44e90452a13e65d907b0cefbea166547546a12683e4c0df57032f38a10e78b3'
    }

    get asV9320(): {callHash: Uint8Array} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class WhitelistWhitelistCallCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'Whitelist.whitelist_call')
        this._chain = ctx._chain
        this.call = call
    }

    get isV9320(): boolean {
        return this._chain.getCallHash('Whitelist.whitelist_call') === 'b44e90452a13e65d907b0cefbea166547546a12683e4c0df57032f38a10e78b3'
    }

    get asV9320(): {callHash: Uint8Array} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletExecuteCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.execute')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Execute an XCM message from a local, signed, origin.
     * 
     *  An event is deposited indicating whether `msg` could be executed completely or only
     *  partially.
     * 
     *  No more than `max_weight` will be used in its attempted execution. If this is less than the
     *  maximum amount of weight that the message could take to be executed, then no execution
     *  attempt will be made.
     * 
     *  NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     *  to completion; only that *some* of it was executed.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('XcmPallet.execute') === 'df2dfbde05a8ace8b2a2ddf274c7229a888f9eb53c9e8576e045c819642e9aea'
    }

    /**
     *  Execute an XCM message from a local, signed, origin.
     * 
     *  An event is deposited indicating whether `msg` could be executed completely or only
     *  partially.
     * 
     *  No more than `max_weight` will be used in its attempted execution. If this is less than the
     *  maximum amount of weight that the message could take to be executed, then no execution
     *  attempt will be made.
     * 
     *  NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     *  to completion; only that *some* of it was executed.
     */
    get asV9010(): {message: v9010.Xcm, maxWeight: bigint} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Execute an XCM message from a local, signed, origin.
     * 
     *  An event is deposited indicating whether `msg` could be executed completely or only
     *  partially.
     * 
     *  No more than `max_weight` will be used in its attempted execution. If this is less than the
     *  maximum amount of weight that the message could take to be executed, then no execution
     *  attempt will be made.
     * 
     *  NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     *  to completion; only that *some* of it was executed.
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('XcmPallet.execute') === '1ffde01afb18b1a97929d4a10da3c986b82c27846dbac20bc988ae3c255b1cba'
    }

    /**
     *  Execute an XCM message from a local, signed, origin.
     * 
     *  An event is deposited indicating whether `msg` could be executed completely or only
     *  partially.
     * 
     *  No more than `max_weight` will be used in its attempted execution. If this is less than the
     *  maximum amount of weight that the message could take to be executed, then no execution
     *  attempt will be made.
     * 
     *  NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     *  to completion; only that *some* of it was executed.
     */
    get asV9100(): {message: v9100.VersionedXcm, maxWeight: bigint} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('XcmPallet.execute') === '41f7d0295efed5db73229cbd1e9f1fdc0e7f9e159af3b17a10880e74bcdb3ad4'
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get asV9111(): {message: v9111.Type_513, maxWeight: bigint} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get isV9160(): boolean {
        return this._chain.getCallHash('XcmPallet.execute') === 'c6251691ab3319ecee95442d381c308f9ada155e423798c908cbd6b063aa26b4'
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get asV9160(): {message: v9160.Type_529, maxWeight: bigint} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get isV9291(): boolean {
        return this._chain.getCallHash('XcmPallet.execute') === '76149fbd7c3d18753d366687484d7bf651dd9b444cec7c11b944262b7ee4dcf5'
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get asV9291(): {message: v9291.Type_553, maxWeight: v9291.Weight} {
        assert(this.isV9291)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get isV9320(): boolean {
        return this._chain.getCallHash('XcmPallet.execute') === 'c6251691ab3319ecee95442d381c308f9ada155e423798c908cbd6b063aa26b4'
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get asV9320(): {message: v9320.Type_424, maxWeight: bigint} {
        assert(this.isV9320)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('XcmPallet.execute') === '411d5e9bce7727b0b767af3f3f77a5cbe27fe9dcd7cdfca4c3ad0d0c05ac13e1'
    }

    /**
     * Execute an XCM message from a local, signed, origin.
     * 
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     * 
     * No more than `max_weight` will be used in its attempted execution. If this is less than the
     * maximum amount of weight that the message could take to be executed, then no execution
     * attempt will be made.
     * 
     * NOTE: A successful return to this does *not* imply that the `msg` was executed successfully
     * to completion; only that *some* of it was executed.
     */
    get asV9370(): {message: v9370.Type_425, maxWeight: bigint} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletForceDefaultXcmVersionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.force_default_xcm_version')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     * 
     * - `origin`: Must be Root.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('XcmPallet.force_default_xcm_version') === 'd4bcd64cc4c940eafd14296ec6cbfb7d27e4ca42a4c7dab4c0b89f6c8102257e'
    }

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     * 
     * - `origin`: Must be Root.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     */
    get asV9111(): {maybeXcmVersion: (number | undefined)} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletForceSubscribeVersionNotifyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.force_subscribe_version_notify')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('XcmPallet.force_subscribe_version_notify') === 'f3f38b2278743e50bfd76c0f778560fb38a60c931275e9df42f2b9ce08c1d6fc'
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get asV9111(): {location: v9111.VersionedMultiLocation} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('XcmPallet.force_subscribe_version_notify') === '56aed4b742721d521279794a608d71ae9db256750e90b7beb3d50a9d01aff0f9'
    }

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     */
    get asV9370(): {location: v9370.VersionedMultiLocation} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletForceUnsubscribeVersionNotifyCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.force_unsubscribe_version_notify')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('XcmPallet.force_unsubscribe_version_notify') === 'f3f38b2278743e50bfd76c0f778560fb38a60c931275e9df42f2b9ce08c1d6fc'
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get asV9111(): {location: v9111.VersionedMultiLocation} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('XcmPallet.force_unsubscribe_version_notify') === '56aed4b742721d521279794a608d71ae9db256750e90b7beb3d50a9d01aff0f9'
    }

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     * 
     * - `origin`: Must be Root.
     * - `location`: The location to which we are currently subscribed for XCM version
     *   notifications which we no longer desire.
     */
    get asV9370(): {location: v9370.VersionedMultiLocation} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletForceXcmVersionCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.force_xcm_version')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be Root.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('XcmPallet.force_xcm_version') === '3bdd3ba3db54facd962462ff1c2c0ede1b428cf9119b36a4e96fa86916145f75'
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be Root.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get asV9111(): {location: v9111.V1MultiLocation, xcmVersion: number} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be Root.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('XcmPallet.force_xcm_version') === '855b9a66c3d6c203c5e887917dc681372ed5d32210a8c6cc86c7d5f227944d9c'
    }

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     * 
     * - `origin`: Must be Root.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     */
    get asV9370(): {location: v9370.V1MultiLocation, xcmVersion: number} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletLimitedReserveTransferAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.limited_reserve_transfer_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     * a notification XCM.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('XcmPallet.limited_reserve_transfer_assets') === '3c203a3f95b9fe53b8c376802c4fe60fa6077815af7432dcd2a3e458169a5d2a'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     * a notification XCM.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asV9122(): {dest: v9122.VersionedMultiLocation, beneficiary: v9122.VersionedMultiLocation, assets: v9122.VersionedMultiAssets, feeAssetItem: number, weightLimit: v9122.V2WeightLimit} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('XcmPallet.limited_reserve_transfer_assets') === '1818300d2dec2685942619973f1ec81b7ecf2b979534f1965b98b7b6c9d833ea'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asV9370(): {dest: v9370.VersionedMultiLocation, beneficiary: v9370.VersionedMultiLocation, assets: v9370.VersionedMultiAssets, feeAssetItem: number, weightLimit: v9370.V2WeightLimit} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletLimitedTeleportAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.limited_teleport_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *   `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isV9122(): boolean {
        return this._chain.getCallHash('XcmPallet.limited_teleport_assets') === '3c203a3f95b9fe53b8c376802c4fe60fa6077815af7432dcd2a3e458169a5d2a'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *   `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asV9122(): {dest: v9122.VersionedMultiLocation, beneficiary: v9122.VersionedMultiLocation, assets: v9122.VersionedMultiAssets, feeAssetItem: number, weightLimit: v9122.V2WeightLimit} {
        assert(this.isV9122)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('XcmPallet.limited_teleport_assets') === '1818300d2dec2685942619973f1ec81b7ecf2b979534f1965b98b7b6c9d833ea'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the assets send may be
     * at risk.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     */
    get asV9370(): {dest: v9370.VersionedMultiLocation, beneficiary: v9370.VersionedMultiLocation, assets: v9370.VersionedMultiAssets, feeAssetItem: number, weightLimit: v9370.V2WeightLimit} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletReserveTransferAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.reserve_transfer_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     *  a notification XCM.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *    `dest` side.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `ReserveAssetDeposit { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get isV9030(): boolean {
        return this._chain.getCallHash('XcmPallet.reserve_transfer_assets') === '3c069703413ed53ed30061e5da3bc55ab8fa9032fc014ba18afc7afe32930ebd'
    }

    /**
     *  Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     *  a notification XCM.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *    `dest` side.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `ReserveAssetDeposit { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get asV9030(): {dest: v9030.MultiLocation, beneficiary: v9030.MultiLocation, assets: v9030.MultiAsset[], destWeight: bigint} {
        assert(this.isV9030)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     *  a notification XCM.
     * 
     *  Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *    `dest` side.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `ReserveAssetDeposited { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('XcmPallet.reserve_transfer_assets') === 'c4558a18f0400069c14aaa3575bad0bb84b99ac94f206e8ab02890276f174ff4'
    }

    /**
     *  Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     *  a notification XCM.
     * 
     *  Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *    `dest` side.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `ReserveAssetDeposited { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get asV9100(): {dest: v9100.VersionedMultiLocation, beneficiary: v9100.VersionedMultiLocation, assets: v9100.VersionedMultiAssets, feeAssetItem: number, destWeight: bigint} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     * a notification XCM.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('XcmPallet.reserve_transfer_assets') === '123b8170fa49ede01f38623e457f4e4d417c90cff5b93ced45a9eb8fe8e6ca2e'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination chain and forward
     * a notification XCM.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get asV9111(): {dest: v9111.VersionedMultiLocation, beneficiary: v9111.VersionedMultiLocation, assets: v9111.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('XcmPallet.reserve_transfer_assets') === 'b79cf2a68b1db82f94409ee603047fcd82f4343b83df6736c115e3338c04cecc'
    }

    /**
     * Transfer some assets from the local chain to the sovereign account of a destination
     * chain and forward a notification XCM.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *   `dest` side.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get asV9370(): {dest: v9370.VersionedMultiLocation, beneficiary: v9370.VersionedMultiLocation, assets: v9370.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletSendCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.send')
        this._chain = ctx._chain
        this.call = call
    }

    get isV9010(): boolean {
        return this._chain.getCallHash('XcmPallet.send') === '8fe0974e74c786d3f8bb01dc13650a419fe9b97da675546b666d5fe67e5722d0'
    }

    get asV9010(): {dest: v9010.MultiLocation, message: v9010.Xcm} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    get isV9100(): boolean {
        return this._chain.getCallHash('XcmPallet.send') === 'b9446b649ff7dbe4e0f16a4dbefc5f448b11996984d1113c46c0e449cd846f9f'
    }

    get asV9100(): {dest: v9100.VersionedMultiLocation, message: v9100.VersionedXcm} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    get isV9111(): boolean {
        return this._chain.getCallHash('XcmPallet.send') === '9ec4149ae6cee6240a6e2aa06a8ef90285e68be29dd0de109b35af7922311609'
    }

    get asV9111(): {dest: v9111.VersionedMultiLocation, message: v9111.VersionedXcm} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    get isV9160(): boolean {
        return this._chain.getCallHash('XcmPallet.send') === '3ca4beb317aeed3e0a00ae870ffd3bef841bb6f4e766db0b286c7fc5d8eef886'
    }

    get asV9160(): {dest: v9160.VersionedMultiLocation, message: v9160.VersionedXcm} {
        assert(this.isV9160)
        return this._chain.decodeCall(this.call)
    }

    get isV9370(): boolean {
        return this._chain.getCallHash('XcmPallet.send') === '23ee62671c78b4c334d1aac87969a94e2d7514e9e9acd1949878df4525736480'
    }

    get asV9370(): {dest: v9370.VersionedMultiLocation, message: v9370.VersionedXcm} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}

export class XcmPalletTeleportAssetsCall {
    private readonly _chain: Chain
    private readonly call: Call

    constructor(ctx: CallContext)
    constructor(ctx: ChainContext, call: Call)
    constructor(ctx: CallContext, call?: Call) {
        call = call || ctx.call
        assert(call.name === 'XcmPallet.teleport_assets')
        this._chain = ctx._chain
        this.call = call
    }

    /**
     *  Teleport some assets from the local chain to some destination chain.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *    `dest` side.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get isV9010(): boolean {
        return this._chain.getCallHash('XcmPallet.teleport_assets') === '3c069703413ed53ed30061e5da3bc55ab8fa9032fc014ba18afc7afe32930ebd'
    }

    /**
     *  Teleport some assets from the local chain to some destination chain.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. This should include the assets used to pay the fee on the
     *    `dest` side.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get asV9010(): {dest: v9010.MultiLocation, beneficiary: v9010.MultiLocation, assets: v9010.MultiAsset[], destWeight: bigint} {
        assert(this.isV9010)
        return this._chain.decodeCall(this.call)
    }

    /**
     *  Teleport some assets from the local chain to some destination chain.
     * 
     *  Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *    `dest` side. May not be empty.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get isV9100(): boolean {
        return this._chain.getCallHash('XcmPallet.teleport_assets') === 'c4558a18f0400069c14aaa3575bad0bb84b99ac94f206e8ab02890276f174ff4'
    }

    /**
     *  Teleport some assets from the local chain to some destination chain.
     * 
     *  Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     *  - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     *  - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *    from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     *  - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *    an `AccountId32` value.
     *  - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *    `dest` side. May not be empty.
     *  - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *    `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get asV9100(): {dest: v9100.VersionedMultiLocation, beneficiary: v9100.VersionedMultiLocation, assets: v9100.VersionedMultiAssets, feeAssetItem: number, destWeight: bigint} {
        assert(this.isV9100)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *   `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get isV9111(): boolean {
        return this._chain.getCallHash('XcmPallet.teleport_assets') === '123b8170fa49ede01f38623e457f4e4d417c90cff5b93ced45a9eb8fe8e6ca2e'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the first asset listed in the `assets` vector.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `dest_weight`: Equal to the total weight on `dest` of the XCM message
     *   `Teleport { assets, effects: [ BuyExecution{..}, DepositAsset{..} ] }`.
     */
    get asV9111(): {dest: v9111.VersionedMultiLocation, beneficiary: v9111.VersionedMultiLocation, assets: v9111.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isV9111)
        return this._chain.decodeCall(this.call)
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get isV9370(): boolean {
        return this._chain.getCallHash('XcmPallet.teleport_assets') === 'b79cf2a68b1db82f94409ee603047fcd82f4343b83df6736c115e3338c04cecc'
    }

    /**
     * Teleport some assets from the local chain to some destination chain.
     * 
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     * 
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent, Parachain(..))` to send
     *   from parachain to parachain, or `X1(Parachain(..))` to send from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will generally be
     *   an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. The first item should be the currency used to to pay the fee on the
     *   `dest` side. May not be empty.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     *   fees.
     */
    get asV9370(): {dest: v9370.VersionedMultiLocation, beneficiary: v9370.VersionedMultiLocation, assets: v9370.VersionedMultiAssets, feeAssetItem: number} {
        assert(this.isV9370)
        return this._chain.decodeCall(this.call)
    }
}
