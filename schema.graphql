type EventNorm @entity {
  id: ID!
  blockHash: String!
  timestamp: DateTime! @index
  name: String! @index
  args: JSON
  extrinsicSuccess: Boolean
}

type CallNorm @entity {
  id: ID!
  blockHash: String!
  timestamp: DateTime! @index
  name: String! @index
  args: JSON
  success: Boolean
  origin: JSON
}

type AddressMapping @entity {
  id: ID! @index
  ss58: String
}

type Trace @entity {
  id: ID!
  transaction: Transaction!
  transactionIndex: Int
  type: TraceType
  subtraces: Int
  error: String
  action: Action
  result: Result
}

enum TraceType {
  CREATE
  CALL
  SUICIDE
  REWARD
}

union Action = CreateAction | CallAction | SuicideAction | RewardAction
union Result = CreateResult | CallResult

# Create type-related fields and result
type CreateAction {
  from: String
  value: BigInt
  gas: BigInt
  init: String
}

type CreateResult {
  gasUsed: BigInt
  code: String
  address: String
}

# Call type-related fields and result
type CallAction {
  from: String
  to: String
  value: BigInt
  gas: BigInt
  sighash: String
  input: String
}

type CallResult {
  gasUsed: BigInt
  output: String
}

# Suicide type-related fields
type SuicideAction {
  address: String
  refundAddress: String
  balance: BigInt
}

# Reward type-related fields
type RewardAction {
  author: String
  value: BigInt
  rewardType: String
}

type Transaction @entity {
  id: ID! # Matches your 'id: string'
  transactionIndex: Int! # Matches 'transactionIndex: number'
  blockHash: String!
  timestamp: DateTime! @index
  from: String! # Matches 'from: string'
  to: String # Matches 'to?: string'
  hash: String! # Matches 'hash: string'
  gas: BigInt! # Matches 'gas: bigint'
  gasPrice: BigInt! # Matches 'gasPrice: bigint'
  maxFeePerGas: BigInt # Matches 'maxFeePerGas?: bigint'
  maxPriorityFeePerGas: BigInt # Matches 'maxPriorityFeePerGas?: bigint'
  input: String! # Matches 'input: string'
  nonce: Int! # Matches 'nonce: number'
  value: BigInt! # Matches 'value: bigint'
  chainId: Int # Matches 'chainId?: number'
  gasUsed: BigInt # Matches 'gasUsed?: bigint'
  cumulativeGasUsed: BigInt # Matches 'cumulativeGasUsed?: bigint'
  effectiveGasPrice: BigInt # Matches 'effectiveGasPrice?: bigint'
  contractAddress: String # Matches 'contractAddress?: string'
  type: Int # Matches 'type?: number'
  status: Int # Matches 'status?: number'
  sighash: String # Matches 'sighash: string'
  traces: [Trace!] @derivedFrom(field: "transaction")
}
